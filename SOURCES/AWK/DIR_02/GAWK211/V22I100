From: rsalz@uunet.uu.net (Rich Salz)
Newsgroups: comp.sources.unix
Subject: v22i100:  GNU AWK, version 2.11, Part14/16
Message-ID: <2639@papaya.bbn.com>
Date: 7 Jun 90 20:31:28 GMT
Approved: rsalz@uunet.UU.NET

Submitted-by: "Arnold D. Robbins" <arnold@unix.cc.emory.edu>
Posting-number: Volume 22, Issue 100
Archive-name: gawk2.11/part14

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  ./COPYING ./debug.c ./main.c ./regex.h
# Wrapped by rsalz@litchi.bbn.com on Wed Jun  6 12:25:00 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 14 (of 16)."'
if test -f './COPYING' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./COPYING'\"
else
  echo shar: Extracting \"'./COPYING'\" \(12488 characters\)
  sed "s/^X//" >'./COPYING' <<'END_OF_FILE'
X
X		    GNU GENERAL PUBLIC LICENSE
X		     Version 1, February 1989
X
X Copyright (C) 1989 Free Software Foundation, Inc.
X                    675 Mass Ave, Cambridge, MA 02139, USA
X Everyone is permitted to copy and distribute verbatim copies
X of this license document, but changing it is not allowed.
X
X			    Preamble
X
X  The license agreements of most software companies try to keep users
Xat the mercy of those companies.  By contrast, our General Public
XLicense is intended to guarantee your freedom to share and change free
Xsoftware--to make sure the software is free for all its users.  The
XGeneral Public License applies to the Free Software Foundation's
Xsoftware and to any other program whose authors commit to using it.
XYou can use it for your programs, too.
X
X  When we speak of free software, we are referring to freedom, not
Xprice.  Specifically, the General Public License is designed to make
Xsure that you have the freedom to give away or sell copies of free
Xsoftware, that you receive source code or can get it if you want it,
Xthat you can change the software or use pieces of it in new free
Xprograms; and that you know you can do these things.
X
X  To protect your rights, we need to make restrictions that forbid
Xanyone to deny you these rights or to ask you to surrender the rights.
XThese restrictions translate to certain responsibilities for you if you
Xdistribute copies of the software, or if you modify it.
X
X  For example, if you distribute copies of a such a program, whether
Xgratis or for a fee, you must give the recipients all the rights that
Xyou have.  You must make sure that they, too, receive or can get the
Xsource code.  And you must tell them their rights.
X
X  We protect your rights with two steps: (1) copyright the software, and
X(2) offer you this license which gives you legal permission to copy,
Xdistribute and/or modify the software.
X
X  Also, for each author's protection and ours, we want to make certain
Xthat everyone understands that there is no warranty for this free
Xsoftware.  If the software is modified by someone else and passed on, we
Xwant its recipients to know that what they have is not the original, so
Xthat any problems introduced by others will not reflect on the original
Xauthors' reputations.
X
X  The precise terms and conditions for copying, distribution and
Xmodification follow.
X
X		    GNU GENERAL PUBLIC LICENSE
X   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
X
X  0. This License Agreement applies to any program or other work which
Xcontains a notice placed by the copyright holder saying it may be
Xdistributed under the terms of this General Public License.  The
X"Program", below, refers to any such program or work, and a "work based
Xon the Program" means either the Program or any work containing the
XProgram or a portion of it, either verbatim or with modifications.  Each
Xlicensee is addressed as "you".
X
X  1. You may copy and distribute verbatim copies of the Program's source
Xcode as you receive it, in any medium, provided that you conspicuously and
Xappropriately publish on each copy an appropriate copyright notice and
Xdisclaimer of warranty; keep intact all the notices that refer to this
XGeneral Public License and to the absence of any warranty; and give any
Xother recipients of the Program a copy of this General Public License
Xalong with the Program.  You may charge a fee for the physical act of
Xtransferring a copy.
X
X  2. You may modify your copy or copies of the Program or any portion of
Xit, and copy and distribute such modifications under the terms of Paragraph
X1 above, provided that you also do the following:
X
X    a) cause the modified files to carry prominent notices stating that
X    you changed the files and the date of any change; and
X
X    b) cause the whole of any work that you distribute or publish, that
X    in whole or in part contains the Program or any part thereof, either
X    with or without modifications, to be licensed at no charge to all
X    third parties under the terms of this General Public License (except
X    that you may choose to grant warranty protection to some or all
X    third parties, at your option).
X
X    c) If the modified program normally reads commands interactively when
X    run, you must cause it, when started running for such interactive use
X    in the simplest and most usual way, to print or display an
X    announcement including an appropriate copyright notice and a notice
X    that there is no warranty (or else, saying that you provide a
X    warranty) and that users may redistribute the program under these
X    conditions, and telling the user how to view a copy of this General
X    Public License.
X
X    d) You may charge a fee for the physical act of transferring a
X    copy, and you may at your option offer warranty protection in
X    exchange for a fee.
X
XMere aggregation of another independent work with the Program (or its
Xderivative) on a volume of a storage or distribution medium does not bring
Xthe other work under the scope of these terms.
X
X  3. You may copy and distribute the Program (or a portion or derivative of
Xit, under Paragraph 2) in object code or executable form under the terms of
XParagraphs 1 and 2 above provided that you also do one of the following:
X
X    a) accompany it with the complete corresponding machine-readable
X    source code, which must be distributed under the terms of
X    Paragraphs 1 and 2 above; or,
X
X    b) accompany it with a written offer, valid for at least three
X    years, to give any third party free (except for a nominal charge
X    for the cost of distribution) a complete machine-readable copy of the
X    corresponding source code, to be distributed under the terms of
X    Paragraphs 1 and 2 above; or,
X
X    c) accompany it with the information you received as to where the
X    corresponding source code may be obtained.  (This alternative is
X    allowed only for noncommercial distribution and only if you
X    received the program in object code or executable form alone.)
X
XSource code for a work means the preferred form of the work for making
Xmodifications to it.  For an executable file, complete source code means
Xall the source code for all modules it contains; but, as a special
Xexception, it need not include source code for modules which are standard
Xlibraries that accompany the operating system on which the executable
Xfile runs, or for standard header files or definitions files that
Xaccompany that operating system.
X
X  4. You may not copy, modify, sublicense, distribute or transfer the
XProgram except as expressly provided under this General Public License.
XAny attempt otherwise to copy, modify, sublicense, distribute or transfer
Xthe Program is void, and will automatically terminate your rights to use
Xthe Program under this License.  However, parties who have received
Xcopies, or rights to use copies, from you under this General Public
XLicense will not have their licenses terminated so long as such parties
Xremain in full compliance.
X
X  5. By copying, distributing or modifying the Program (or any work based
Xon the Program) you indicate your acceptance of this license to do so,
Xand all its terms and conditions.
X
X  6. Each time you redistribute the Program (or any work based on the
XProgram), the recipient automatically receives a license from the original
Xlicensor to copy, distribute or modify the Program subject to these
Xterms and conditions.  You may not impose any further restrictions on the
Xrecipients' exercise of the rights granted herein.
X
X  7. The Free Software Foundation may publish revised and/or new versions
Xof the General Public License from time to time.  Such new versions will
Xbe similar in spirit to the present version, but may differ in detail to
Xaddress new problems or concerns.
X
XEach version is given a distinguishing version number.  If the Program
Xspecifies a version number of the license which applies to it and "any
Xlater version", you have the option of following the terms and conditions
Xeither of that version or of any later version published by the Free
XSoftware Foundation.  If the Program does not specify a version number of
Xthe license, you may choose any version ever published by the Free Software
XFoundation.
X
X  8. If you wish to incorporate parts of the Program into other free
Xprograms whose distribution conditions are different, write to the author
Xto ask for permission.  For software which is copyrighted by the Free
XSoftware Foundation, write to the Free Software Foundation; we sometimes
Xmake exceptions for this.  Our decision will be guided by the two goals
Xof preserving the free status of all derivatives of our free software and
Xof promoting the sharing and reuse of software generally.
X
X			    NO WARRANTY
X
X  9. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
XFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
XOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
XPROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
XOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
XMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
XTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
XPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
XREPAIR OR CORRECTION.
X
X  10. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
XWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
XREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
XINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
XOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
XTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
XYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
XPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
XPOSSIBILITY OF SUCH DAMAGES.
X
X		     END OF TERMS AND CONDITIONS
X
X	Appendix: How to Apply These Terms to Your New Programs
X
X  If you develop a new program, and you want it to be of the greatest
Xpossible use to humanity, the best way to achieve this is to make it
Xfree software which everyone can redistribute and change under these
Xterms.
X
X  To do so, attach the following notices to the program.  It is safest to
Xattach them to the start of each source file to most effectively convey
Xthe exclusion of warranty; and each file should have at least the
X"copyright" line and a pointer to where the full notice is found.
X
X    <one line to give the program's name and a brief idea of what it does.>
X    Copyright (C) 19yy  <name of author>
X
X    This program is free software; you can redistribute it and/or modify
X    it under the terms of the GNU General Public License as published by
X    the Free Software Foundation; either version 1, or (at your option)
X    any later version.
X
X    This program is distributed in the hope that it will be useful,
X    but WITHOUT ANY WARRANTY; without even the implied warranty of
X    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X    GNU General Public License for more details.
X
X    You should have received a copy of the GNU General Public License
X    along with this program; if not, write to the Free Software
X    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
XAlso add information on how to contact you by electronic and paper mail.
X
XIf the program is interactive, make it output a short notice like this
Xwhen it starts in an interactive mode:
X
X    Gnomovision version 69, Copyright (C) 19xx name of author
X    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
X    This is free software, and you are welcome to redistribute it
X    under certain conditions; type `show c' for details.
X
XThe hypothetical commands `show w' and `show c' should show the
Xappropriate parts of the General Public License.  Of course, the
Xcommands you use may be called something other than `show w' and `show
Xc'; they could even be mouse-clicks or menu items--whatever suits your
Xprogram.
X
XYou should also get your employer (if you work as a programmer) or your
Xschool, if any, to sign a "copyright disclaimer" for the program, if
Xnecessary.  Here a sample; alter the names:
X
X  Yoyodyne, Inc., hereby disclaims all copyright interest in the
X  program `Gnomovision' (a program to direct compilers to make passes
X  at assemblers) written by James Hacker.
X
X  <signature of Ty Coon>, 1 April 1989
X  Ty Coon, President of Vice
X
XThat's all there is to it!
END_OF_FILE
  if test 12488 -ne `wc -c <'./COPYING'`; then
    echo shar: \"'./COPYING'\" unpacked with wrong size!
  fi
  # end of './COPYING'
fi
if test -f './debug.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./debug.c'\"
else
  echo shar: Extracting \"'./debug.c'\" \(10721 characters\)
  sed "s/^X//" >'./debug.c' <<'END_OF_FILE'
X/*
X * debug.c -- Various debugging routines 
X */
X
X/* 
X * Copyright (C) 1986, 1988, 1989 the Free Software Foundation, Inc.
X * 
X * This file is part of GAWK, the GNU implementation of the
X * AWK Progamming Language.
X * 
X * GAWK is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X * 
X * GAWK is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X * 
X * You should have received a copy of the GNU General Public License
X * along with GAWK; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X#include "awk.h"
X
X#ifdef DEBUG
X
Xextern NODE **fields_arr;
X
X
X/* This is all debugging stuff.  Ignore it and maybe it'll go away. */
X
X/*
X * Some of it could be turned into a really cute trace command, if anyone
X * wants to.  
X */
Xchar *nnames[] = {
X	"illegal", "times", "quotient", "mod", "plus",
X	"minus", "cond_pair", "subscript", "concat", "exp",
X	/* 10 */
X	"preincrement", "predecrement", "postincrement", "postdecrement",
X	"unary_minus",
X	"field_spec", "assign", "assign_times", "assign_quotient", "assign_mod",
X	/* 20 */
X	"assign_plus", "assign_minus", "assign_exp", "and", "or",
X	"equal", "notequal", "less", "greater", "leq",
X	/* 30 */
X	"geq", "match", "nomatch", "not", "rule_list",
X	"rule_node", "statement_list", "if_branches", "expression_list",
X	"param_list",
X	/* 40 */
X	"K_if", "K_while", "K_for", "K_arrayfor", "K_break",
X	"K_continue", "K_print", "K_printf", "K_next", "K_exit",
X	/* 50 */
X	"K_do", "K_return", "K_delete", "K_getline", "K_function",
X	"redirect_output", "redirect_append", "redirect_pipe",
X	"redirect_pipein", "redirect_input",
X	/* 60 */
X	"var", "var_array", "val", "builtin", "line_range",
X	"in_array", "func", "func_call", "cond_exp", "regex",
X	/* 70 */
X	"hashnode", "ahash"
X};
X
Xptree(n)
XNODE *n;
X{
X	print_parse_tree(n);
X}
X
Xpt()
X{
X	long x;
X
X	(void) scanf("%x", &x);
X	printf("0x%x\n", x);
X	print_parse_tree((NODE *) x);
X	fflush(stdout);
X}
X
Xstatic depth = 0;
X
Xprint_parse_tree(ptr)
XNODE *ptr;
X{
X	if (!ptr) {
X		printf("NULL\n");
X		return;
X	}
X	if ((int) (ptr->type) < 0 || (int) (ptr->type) > sizeof(nnames) / sizeof(nnames[0])) {
X		printf("(0x%x Type %d??)\n", ptr, ptr->type);
X		return;
X	}
X	printf("(%d)%*s", depth, depth, "");
X	switch ((int) ptr->type) {
X	case (int) Node_val:
X		printf("(0x%x Value ", ptr);
X		if (ptr->flags&STR)
X			printf("str: \"%.*s\" ", ptr->stlen, ptr->stptr);
X		if (ptr->flags&NUM)
X			printf("num: %g", ptr->numbr);
X		printf(")\n");
X		return;
X	case (int) Node_var_array:
X		{
X		struct search *l;
X
X		printf("(0x%x Array)\n", ptr);
X		for (l = assoc_scan(ptr); l; l = assoc_next(l)) {
X			printf("\tindex: ");
X			print_parse_tree(l->retval);
X			printf("\tvalue: ");
X			print_parse_tree(*assoc_lookup(ptr, l->retval));
X			printf("\n");
X		}
X		return;
X		}
X	case Node_param_list:
X		printf("(0x%x Local variable %s)\n", ptr, ptr->param);
X		if (ptr->rnode)
X			print_parse_tree(ptr->rnode);
X		return;
X	case Node_regex:
X		printf("(0x%x Regular expression %s\n", ptr, ptr->re_text);
X		return;
X	}
X	if (ptr->lnode)
X		printf("0x%x = left<--", ptr->lnode);
X	printf("(0x%x %s.%d)", ptr, nnames[(int) (ptr->type)], ptr->type);
X	if (ptr->rnode)
X		printf("-->right = 0x%x", ptr->rnode);
X	printf("\n");
X	depth++;
X	if (ptr->lnode)
X		print_parse_tree(ptr->lnode);
X	switch ((int) ptr->type) {
X	case (int) Node_line_range:
X	case (int) Node_match:
X	case (int) Node_nomatch:
X		break;
X	case (int) Node_builtin:
X		printf("Builtin: %d\n", ptr->proc);
X		break;
X	case (int) Node_K_for:
X	case (int) Node_K_arrayfor:
X		printf("(%s:)\n", nnames[(int) (ptr->type)]);
X		print_parse_tree(ptr->forloop->init);
X		printf("looping:\n");
X		print_parse_tree(ptr->forloop->cond);
X		printf("doing:\n");
X		print_parse_tree(ptr->forloop->incr);
X		break;
X	default:
X		if (ptr->rnode)
X			print_parse_tree(ptr->rnode);
X		break;
X	}
X	--depth;
X}
X
X
X/*
X * print out all the variables in the world 
X */
X
Xdump_vars()
X{
X	register int n;
X	register NODE *buc;
X
X#ifdef notdef
X	printf("Fields:");
X	dump_fields();
X#endif
X	printf("Vars:\n");
X	for (n = 0; n < HASHSIZE; n++) {
X		for (buc = variables[n]; buc; buc = buc->hnext) {
X			printf("'%.*s': ", buc->hlength, buc->hname);
X			print_parse_tree(buc->hvalue);
X		}
X	}
X	printf("End\n");
X}
X
X#ifdef notdef
Xdump_fields()
X{
X	register NODE **p;
X	register int n;
X
X	printf("%d fields\n", f_arr_siz);
X	for (n = 0, p = &fields_arr[0]; n < f_arr_siz; n++, p++) {
X		printf("$%d is '", n);
X		print_simple(*p, stdout);
X		printf("'\n");
X	}
X}
X#endif
X
X/* VARARGS1 */
Xprint_debug(str, n)
Xchar *str;
X{
X	extern int debugging;
X
X	if (debugging)
X		printf("%s:0x%x\n", str, n);
X}
X
Xint indent = 0;
X
Xprint_a_node(ptr)
XNODE *ptr;
X{
X	NODE *p1;
X	char *str, *str2;
X	int n;
X	NODE *buc;
X
X	if (!ptr)
X		return;		/* don't print null ptrs */
X	switch (ptr->type) {
X	case Node_val:
X		if (ptr->flags&NUM)
X			printf("%g", ptr->numbr);
X		else
X			printf("\"%.*s\"", ptr->stlen, ptr->stptr);
X		return;
X	case Node_times:
X		str = "*";
X		goto pr_twoop;
X	case Node_quotient:
X		str = "/";
X		goto pr_twoop;
X	case Node_mod:
X		str = "%";
X		goto pr_twoop;
X	case Node_plus:
X		str = "+";
X		goto pr_twoop;
X	case Node_minus:
X		str = "-";
X		goto pr_twoop;
X	case Node_exp:
X		str = "^";
X		goto pr_twoop;
X	case Node_concat:
X		str = " ";
X		goto pr_twoop;
X	case Node_assign:
X		str = "=";
X		goto pr_twoop;
X	case Node_assign_times:
X		str = "*=";
X		goto pr_twoop;
X	case Node_assign_quotient:
X		str = "/=";
X		goto pr_twoop;
X	case Node_assign_mod:
X		str = "%=";
X		goto pr_twoop;
X	case Node_assign_plus:
X		str = "+=";
X		goto pr_twoop;
X	case Node_assign_minus:
X		str = "-=";
X		goto pr_twoop;
X	case Node_assign_exp:
X		str = "^=";
X		goto pr_twoop;
X	case Node_and:
X		str = "&&";
X		goto pr_twoop;
X	case Node_or:
X		str = "||";
X		goto pr_twoop;
X	case Node_equal:
X		str = "==";
X		goto pr_twoop;
X	case Node_notequal:
X		str = "!=";
X		goto pr_twoop;
X	case Node_less:
X		str = "<";
X		goto pr_twoop;
X	case Node_greater:
X		str = ">";
X		goto pr_twoop;
X	case Node_leq:
X		str = "<=";
X		goto pr_twoop;
X	case Node_geq:
X		str = ">=";
X		goto pr_twoop;
X
Xpr_twoop:
X		print_a_node(ptr->lnode);
X		printf("%s", str);
X		print_a_node(ptr->rnode);
X		return;
X
X	case Node_not:
X		str = "!";
X		str2 = "";
X		goto pr_oneop;
X	case Node_field_spec:
X		str = "$(";
X		str2 = ")";
X		goto pr_oneop;
X	case Node_postincrement:
X		str = "";
X		str2 = "++";
X		goto pr_oneop;
X	case Node_postdecrement:
X		str = "";
X		str2 = "--";
X		goto pr_oneop;
X	case Node_preincrement:
X		str = "++";
X		str2 = "";
X		goto pr_oneop;
X	case Node_predecrement:
X		str = "--";
X		str2 = "";
X		goto pr_oneop;
Xpr_oneop:
X		printf(str);
X		print_a_node(ptr->subnode);
X		printf(str2);
X		return;
X
X	case Node_expression_list:
X		print_a_node(ptr->lnode);
X		if (ptr->rnode) {
X			printf(",");
X			print_a_node(ptr->rnode);
X		}
X		return;
X
X	case Node_var:
X		for (n = 0; n < HASHSIZE; n++) {
X			for (buc = variables[n]; buc; buc = buc->hnext) {
X				if (buc->hvalue == ptr) {
X					printf("%.*s", buc->hlength, buc->hname);
X					n = HASHSIZE;
X					break;
X				}
X			}
X		}
X		return;
X	case Node_subscript:
X		print_a_node(ptr->lnode);
X		printf("[");
X		print_a_node(ptr->rnode);
X		printf("]");
X		return;
X	case Node_builtin:
X		printf("some_builtin(");
X		print_a_node(ptr->subnode);
X		printf(")");
X		return;
X
X	case Node_statement_list:
X		printf("{\n");
X		indent++;
X		for (n = indent; n; --n)
X			printf("  ");
X		while (ptr) {
X			print_maybe_semi(ptr->lnode);
X			if (ptr->rnode)
X				for (n = indent; n; --n)
X					printf("  ");
X			ptr = ptr->rnode;
X		}
X		--indent;
X		for (n = indent; n; --n)
X			printf("  ");
X		printf("}\n");
X		for (n = indent; n; --n)
X			printf("  ");
X		return;
X
X	case Node_K_if:
X		printf("if(");
X		print_a_node(ptr->lnode);
X		printf(") ");
X		ptr = ptr->rnode;
X		if (ptr->lnode->type == Node_statement_list) {
X			printf("{\n");
X			indent++;
X			for (p1 = ptr->lnode; p1; p1 = p1->rnode) {
X				for (n = indent; n; --n)
X					printf("  ");
X				print_maybe_semi(p1->lnode);
X			}
X			--indent;
X			for (n = indent; n; --n)
X				printf("  ");
X			if (ptr->rnode) {
X				printf("} else ");
X			} else {
X				printf("}\n");
X				return;
X			}
X		} else {
X			print_maybe_semi(ptr->lnode);
X			if (ptr->rnode) {
X				for (n = indent; n; --n)
X					printf("  ");
X				printf("else ");
X			} else
X				return;
X		}
X		if (!ptr->rnode)
X			return;
X		deal_with_curls(ptr->rnode);
X		return;
X
X	case Node_K_while:
X		printf("while(");
X		print_a_node(ptr->lnode);
X		printf(") ");
X		deal_with_curls(ptr->rnode);
X		return;
X
X	case Node_K_do:
X		printf("do ");
X		deal_with_curls(ptr->rnode);
X		printf("while(");
X		print_a_node(ptr->lnode);
X		printf(") ");
X		return;
X
X	case Node_K_for:
X		printf("for(");
X		print_a_node(ptr->forloop->init);
X		printf(";");
X		print_a_node(ptr->forloop->cond);
X		printf(";");
X		print_a_node(ptr->forloop->incr);
X		printf(") ");
X		deal_with_curls(ptr->forsub);
X		return;
X	case Node_K_arrayfor:
X		printf("for(");
X		print_a_node(ptr->forloop->init);
X		printf(" in ");
X		print_a_node(ptr->forloop->incr);
X		printf(") ");
X		deal_with_curls(ptr->forsub);
X		return;
X
X	case Node_K_printf:
X		printf("printf(");
X		print_a_node(ptr->lnode);
X		printf(")");
X		return;
X	case Node_K_print:
X		printf("print(");
X		print_a_node(ptr->lnode);
X		printf(")");
X		return;
X	case Node_K_next:
X		printf("next");
X		return;
X	case Node_K_break:
X		printf("break");
X		return;
X	case Node_K_delete:
X		printf("delete ");
X		print_a_node(ptr->lnode);
X		return;
X	case Node_func:
X		printf("function %s (", ptr->lnode->param);
X		if (ptr->lnode->rnode)
X			print_a_node(ptr->lnode->rnode);
X		printf(")\n");
X		print_a_node(ptr->rnode);
X		return;
X	case Node_param_list:
X		printf("%s", ptr->param);
X		if (ptr->rnode) {
X			printf(", ");
X			print_a_node(ptr->rnode);
X		}
X		return;
X	default:
X		print_parse_tree(ptr);
X		return;
X	}
X}
X
Xprint_maybe_semi(ptr)
XNODE *ptr;
X{
X	print_a_node(ptr);
X	switch (ptr->type) {
X	case Node_K_if:
X	case Node_K_for:
X	case Node_K_arrayfor:
X	case Node_statement_list:
X		break;
X	default:
X		printf(";\n");
X		break;
X	}
X}
X
Xdeal_with_curls(ptr)
XNODE *ptr;
X{
X	int n;
X
X	if (ptr->type == Node_statement_list) {
X		printf("{\n");
X		indent++;
X		while (ptr) {
X			for (n = indent; n; --n)
X				printf("  ");
X			print_maybe_semi(ptr->lnode);
X			ptr = ptr->rnode;
X		}
X		--indent;
X		for (n = indent; n; --n)
X			printf("  ");
X		printf("}\n");
X	} else {
X		print_maybe_semi(ptr);
X	}
X}
X
XNODE *
Xdo_prvars()
X{
X	dump_vars();
X	return Nnull_string;
X}
X
XNODE *
Xdo_bp()
X{
X	return Nnull_string;
X}
X
X#endif
X
X#ifdef MEMDEBUG
X
X#undef free
Xextern void free();
X
Xvoid
Xdo_free(s)
Xchar *s;
X{
X	free(s);
X}
X
X#endif
END_OF_FILE
  if test 10721 -ne `wc -c <'./debug.c'`; then
    echo shar: \"'./debug.c'\" unpacked with wrong size!
  fi
  # end of './debug.c'
fi
if test -f './main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./main.c'\"
else
  echo shar: Extracting \"'./main.c'\" \(12595 characters\)
  sed "s/^X//" >'./main.c' <<'END_OF_FILE'
X/*
X * main.c -- Expression tree constructors and main program for gawk. 
X */
X
X/* 
X * Copyright (C) 1986, 1988, 1989 the Free Software Foundation, Inc.
X * 
X * This file is part of GAWK, the GNU implementation of the
X * AWK Progamming Language.
X * 
X * GAWK is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X * 
X * GAWK is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X * 
X * You should have received a copy of the GNU General Public License
X * along with GAWK; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X#include "awk.h"
X#include "patchlevel.h"
X#include <signal.h>
X
Xextern int yyparse();
Xextern void do_input();
Xextern int close_io();
Xextern void init_fields();
Xextern int getopt();
Xextern int re_set_syntax();
Xextern NODE *node();
X
Xstatic void usage();
Xstatic void set_fs();
Xstatic void init_vars();
Xstatic void init_args();
Xstatic NODE *spc_var();
Xstatic void pre_assign();
Xstatic void copyleft();
X
X/* These nodes store all the special variables AWK uses */
XNODE *FS_node, *NF_node, *RS_node, *NR_node;
XNODE *FILENAME_node, *OFS_node, *ORS_node, *OFMT_node;
XNODE *FNR_node, *RLENGTH_node, *RSTART_node, *SUBSEP_node;
XNODE *ENVIRON_node, *IGNORECASE_node;
XNODE *ARGC_node, *ARGV_node;
X
X/*
X * The parse tree and field nodes are stored here.  Parse_end is a dummy item
X * used to free up unneeded fields without freeing the program being run 
X */
Xint errcount = 0;	/* error counter, used by yyerror() */
X
X/* The global null string */
XNODE *Nnull_string;
X
X/* The name the program was invoked under, for error messages */
Xchar *myname;
X
X/* A block of AWK code to be run before running the program */
XNODE *begin_block = 0;
X
X/* A block of AWK code to be run after the last input file */
XNODE *end_block = 0;
X
Xint exiting = 0;		/* Was an "exit" statement executed? */
Xint exit_val = 0;		/* optional exit value */
X
X#ifdef DEBUG
X/* non-zero means in debugging is enabled.  Probably not very useful */
Xint debugging = 0;
Xextern int yydebug;
X#endif
X
Xint tempsource = 0;		/* source is in a temp file */
Xchar **sourcefile = NULL;	/* source file name(s) */
Xint numfiles = -1;		/* how many source files */
X
Xint strict = 0;			/* turn off gnu extensions */
X
Xint output_is_tty = 0;		/* control flushing of output */
X
XNODE *expression_value;
X
X/*
X * for strict to work, legal options must be first
X *
X * Unfortunately, -a and -e are orthogonal to -c.
X */
X#define EXTENSIONS	8	/* where to clear */
X#ifdef DEBUG
Xchar awk_opts[] = "F:f:v:caeCVdD";
X#else
Xchar awk_opts[] = "F:f:v:caeCV";
X#endif
X
Xint
Xmain(argc, argv)
Xint argc;
Xchar **argv;
X{
X#ifdef DEBUG
X	/* Print out the parse tree.   For debugging */
X	register int dotree = 0;
X#endif
X	extern char *version_string;
X	FILE *fp;
X	int c;
X	extern int opterr, optind;
X	extern char *optarg;
X 	extern char *strrchr();
X 	extern char *tmpnam();
X	extern SIGTYPE catchsig();
X	int i;
X	int nostalgia;
X#ifdef somtime_in_the_future
X	int regex_mode = RE_SYNTAX_POSIX_EGREP;
X#else
X	int regex_mode = RE_SYNTAX_AWK;
X#endif
X
X	(void) signal(SIGFPE, catchsig);
X	(void) signal(SIGSEGV, catchsig);
X
X	if (strncmp(version_string, "@(#)", 4) == 0)
X		version_string += 4;
X
X	myname = strrchr(argv[0], '/');
X	if (myname == NULL)
X		myname = argv[0];
X	else
X		myname++;
X	if (argc < 2)
X		usage();
X
X	/* initialize the null string */
X	Nnull_string = make_string("", 0);
X	Nnull_string->numbr = 0.0;
X	Nnull_string->type = Node_val;
X	Nnull_string->flags = (PERM|STR|NUM|NUMERIC);
X
X	/* Set up the special variables */
X
X	/*
X	 * Note that this must be done BEFORE arg parsing else -F
X	 * breaks horribly 
X	 */
X	init_vars();
X
X	/* worst case */
X	emalloc(sourcefile, char **, argc * sizeof(char *), "main");
X
X
X#ifdef STRICT	/* strict new awk compatibility */
X	strict = 1;
X	awk_opts[EXTENSIONS] = '\0';
X#endif
X
X#ifndef STRICT
X	/* undocumented feature, inspired by nostalgia, and a T-shirt */
X	nostalgia = 0;
X	for (i = 1; i < argc && argv[i][0] == '-'; i++) {
X		if (argv[i][1] == '-')		/* -- */
X			break;
X		else if (argv[i][1] == 'c') {	/* compatibility mode */
X			nostalgia = 0;
X			break;
X		} else if (STREQ(&argv[i][1], "nostalgia"))
X			nostalgia = 1;
X			/* keep looping, in case -c after -nostalgia */
X	}
X	if (nostalgia) {
X		fprintf (stderr, "awk: bailing out near line 1\n");
X		abort();
X	}
X#endif
X		
X	while ((c = getopt (argc, argv, awk_opts)) != EOF) {
X		switch (c) {
X#ifdef DEBUG
X		case 'd':
X			debugging++;
X			dotree++;
X			break;
X
X		case 'D':
X			debugging++;
X			yydebug = 2;
X			break;
X#endif
X
X#ifndef STRICT
X		case 'c':
X			strict = 1;
X			break;
X#endif
X
X		case 'F':
X			set_fs(optarg);
X			break;
X
X		case 'f':
X			/*
X			 * a la MKS awk, allow multiple -f options.
X			 * this makes function libraries real easy.
X			 * most of the magic is in the scanner.
X			 */
X			sourcefile[++numfiles] = optarg;
X			break;
X
X		case 'v':
X			pre_assign(optarg);
X			break;
X
X		case 'V':
X			fprintf(stderr, "%s, patchlevel %d\n",
X					version_string, PATCHLEVEL);
X			break;
X
X		case 'C':
X			copyleft();
X			break;
X
X		case 'a':	/* use old fashioned awk regexps */
X			regex_mode = RE_SYNTAX_AWK;
X			break;
X
X		case 'e':	/* use egrep style regexps, per Posix */
X			regex_mode = RE_SYNTAX_POSIX_EGREP;
X			break;
X
X		case '?':
X		default:
X			/* getopt will print a message for us */
X			/* S5R4 awk ignores bad options and keeps going */
X			break;
X		}
X	}
X
X	/* Tell the regex routines how they should work. . . */
X	(void) re_set_syntax(regex_mode);
X
X#ifdef DEBUG
X	setbuf(stdout, (char *) NULL);	/* make debugging easier */
X#endif
X	if (isatty(fileno(stdout)))
X		output_is_tty = 1;
X	/* No -f option, use next arg */
X	/* write to temp file and save sourcefile name */
X	if (numfiles == -1) {
X		int i;
X
X		if (optind > argc - 1)	/* no args left */
X			usage();
X		numfiles++;
X		i = strlen (argv[optind]);
X		if (i == 0) {	/* sanity check */
X			fprintf(stderr, "%s: empty program text\n", myname);
X			usage();
X			/* NOTREACHED */
X		}
X		sourcefile[0] = tmpnam((char *) NULL);
X		if ((fp = fopen (sourcefile[0], "w")) == NULL)
X			fatal("could not save source prog in temp file (%s)",
X			strerror(errno));
X		if (fwrite (argv[optind], 1, i, fp) == 0)
X			fatal(
X			"could not write source program to temp file (%s)",
X			strerror(errno));
X		if (argv[optind][i-1] != '\n')
X			putc ('\n', fp);
X		(void) fclose (fp);
X		tempsource++;
X		optind++;
X	}
X	init_args(optind, argc, myname, argv);
X
X	/* Read in the program */
X	if (yyparse() || errcount)
X		exit(1);
X
X#ifdef DEBUG
X	if (dotree)
X		print_parse_tree(expression_value);
X#endif
X	/* Set up the field variables */
X	init_fields();
X
X	if (begin_block)
X		(void) interpret(begin_block);
X	if (!exiting && (expression_value || end_block))
X		do_input();
X	if (end_block)
X		(void) interpret(end_block);
X	if (close_io() != 0 && exit_val == 0)
X		exit_val = 1;
X	exit(exit_val);
X	/* NOTREACHED */
X	return exit_val;
X}
X
Xstatic void
Xusage()
X{
X	char *opt1 = " -f progfile [--]";
X	char *opt2 = " [--] 'program'";
X#ifdef STRICT
X	char *regops = " [-ae] [-F fs] [-v var=val]"
X#else
X	char *regops = " [-aecCV] [-F fs] [-v var=val]";
X#endif
X
X	fprintf(stderr, "usage: %s%s%s file ...\n       %s%s%s file ...\n",
X		myname, regops, opt1, myname, regops, opt2);
X	exit(11);
X}
X
X/* Generate compiled regular expressions */
Xstruct re_pattern_buffer *
Xmake_regexp(s, ignorecase)
XNODE *s;
Xint ignorecase;
X{
X	struct re_pattern_buffer *rp;
X	char *err;
X
X	emalloc(rp, struct re_pattern_buffer *, sizeof(*rp), "make_regexp");
X	memset((char *) rp, 0, sizeof(*rp));
X	emalloc(rp->buffer, char *, 16, "make_regexp");
X	rp->allocated = 16;
X	emalloc(rp->fastmap, char *, 256, "make_regexp");
X
X	if (! strict && ignorecase)
X		rp->translate = casetable;
X	else
X		rp->translate = NULL;
X	if ((err = re_compile_pattern(s->stptr, s->stlen, rp)) != NULL)
X		fatal("%s: /%s/", err, s->stptr);
X	free_temp(s);
X	return rp;
X}
X
Xstruct re_pattern_buffer *
Xmk_re_parse(s, ignorecase)
Xchar *s;
Xint ignorecase;
X{
X	char *src;
X	register char *dest;
X	register int c;
X	int in_brack = 0;
X
X	for (dest = src = s; *src != '\0';) {
X		if (*src == '\\') {
X			c = *++src;
X			switch (c) {
X			case '/':
X			case 'a':
X			case 'b':
X			case 'f':
X			case 'n':
X			case 'r':
X			case 't':
X			case 'v':
X			case 'x':
X			case '0':
X			case '1':
X			case '2':
X			case '3':
X			case '4':
X			case '5':
X			case '6':
X			case '7':
X				c = parse_escape(&src);
X				if (c < 0)
X					cant_happen();
X				*dest++ = (char)c;
X				break;
X			default:
X				*dest++ = '\\';
X				*dest++ = (char)c;
X				src++;
X				break;
X			}
X		} else if (*src == '/' && ! in_brack)
X			break;
X		else {
X			if (*src == '[')
X				in_brack = 1;
X			else if (*src == ']')
X				in_brack = 0;
X
X			*dest++ = *src++;
X		}
X	}
X	return make_regexp(tmp_string(s, dest-s), ignorecase);
X}
X
Xstatic void
Xcopyleft ()
X{
X	extern char *version_string;
X	char *cp;
X	static char blurb[] =
X"Copyright (C) 1989, Free Software Foundation.\n\
XGNU Awk comes with ABSOLUTELY NO WARRANTY.  This is free software, and\n\
Xyou are welcome to distribute it under the terms of the GNU General\n\
XPublic License, which covers both the warranty information and the\n\
Xterms for redistribution.\n\n\
XYou should have received a copy of the GNU General Public License along\n\
Xwith this program; if not, write to the Free Software Foundation, Inc.,\n\
X675 Mass Ave, Cambridge, MA 02139, USA.\n";
X
X	fprintf (stderr, "%s, patchlevel %d\n", version_string, PATCHLEVEL);
X	fputs(blurb, stderr);
X	fflush(stderr);
X}
X
Xstatic void
Xset_fs(str)
Xchar *str;
X{
X	register NODE **tmp;
X
X	tmp = get_lhs(FS_node, 0);
X	/*
X	 * Only if in full compatibility mode check for the stupid special
X	 * case so -F\t works as documented in awk even though the shell
X	 * hands us -Ft.  Bleah!
X	 */
X	if (strict && str[0] == 't' && str[1] == '\0')
X		str[0] = '\t';
X	*tmp = make_string(str, 1);
X	do_deref();
X}
X
Xstatic void
Xinit_args(argc0, argc, argv0, argv)
Xint argc0, argc;
Xchar *argv0;
Xchar **argv;
X{
X	int i, j;
X	NODE **aptr;
X
X	ARGV_node = spc_var("ARGV", Nnull_string);
X	aptr = assoc_lookup(ARGV_node, tmp_number(0.0));
X	*aptr = make_string(argv0, strlen(argv0));
X	for (i = argc0, j = 1; i < argc; i++) {
X		aptr = assoc_lookup(ARGV_node, tmp_number((AWKNUM) j));
X		*aptr = make_string(argv[i], strlen(argv[i]));
X		j++;
X	}
X	ARGC_node = spc_var("ARGC", make_number((AWKNUM) j));
X}
X
X/*
X * Set all the special variables to their initial values.
X */
Xstatic void
Xinit_vars()
X{
X	extern char **environ;
X	char *var, *val;
X	NODE **aptr;
X	int i;
X
X	FS_node = spc_var("FS", make_string(" ", 1));
X	NF_node = spc_var("NF", make_number(-1.0));
X	RS_node = spc_var("RS", make_string("\n", 1));
X	NR_node = spc_var("NR", make_number(0.0));
X	FNR_node = spc_var("FNR", make_number(0.0));
X	FILENAME_node = spc_var("FILENAME", make_string("-", 1));
X	OFS_node = spc_var("OFS", make_string(" ", 1));
X	ORS_node = spc_var("ORS", make_string("\n", 1));
X	OFMT_node = spc_var("OFMT", make_string("%.6g", 4));
X	RLENGTH_node = spc_var("RLENGTH", make_number(0.0));
X	RSTART_node = spc_var("RSTART", make_number(0.0));
X	SUBSEP_node = spc_var("SUBSEP", make_string("\034", 1));
X	IGNORECASE_node = spc_var("IGNORECASE", make_number(0.0));
X
X	ENVIRON_node = spc_var("ENVIRON", Nnull_string);
X	for (i = 0; environ[i]; i++) {
X		static char nullstr[] = "";
X
X		var = environ[i];
X		val = strchr(var, '=');
X		if (val)
X			*val++ = '\0';
X		else
X			val = nullstr;
X		aptr = assoc_lookup(ENVIRON_node, tmp_string(var, strlen (var)));
X		*aptr = make_string(val, strlen (val));
X
X		/* restore '=' so that system() gets a valid environment */
X		if (val != nullstr)
X			*--val = '=';
X	}
X}
X
X/* Create a special variable */
Xstatic NODE *
Xspc_var(name, value)
Xchar *name;
XNODE *value;
X{
X	register NODE *r;
X
X	if ((r = lookup(variables, name)) == NULL)
X		r = install(variables, name, node(value, Node_var, (NODE *) NULL));
X	return r;
X}
X
Xstatic void
Xpre_assign(v)
Xchar *v;
X{
X	char *cp;
X
X	cp = strchr(v, '=');
X	if (cp != NULL) {
X		*cp++ = '\0';
X		variable(v)->var_value = make_string(cp, strlen(cp));
X	} else {
X		fprintf (stderr,
X			"%s: '%s' argument to -v not in 'var=value' form\n",
X				myname, v);
X		usage();
X	}
X}
X
XSIGTYPE
Xcatchsig(sig, code)
Xint sig, code;
X{
X#ifdef lint
X	code = 0; sig = code; code = sig;
X#endif
X	if (sig == SIGFPE) {
X		fatal("floating point exception");
X	} else if (sig == SIGSEGV) {
X		msg("fatal error: segmentation fault");
X		/* fatal won't abort() if not compiled for debugging */
X		abort();
X	} else
X		cant_happen();
X	/* NOTREACHED */
X}
END_OF_FILE
  if test 12595 -ne `wc -c <'./main.c'`; then
    echo shar: \"'./main.c'\" unpacked with wrong size!
  fi
  # end of './main.c'
fi
if test -f './regex.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./regex.h'\"
else
  echo shar: Extracting \"'./regex.h'\" \(12788 characters\)
  sed "s/^X//" >'./regex.h' <<'END_OF_FILE'
X/* Definitions for data structures callers pass the regex library.
X   Copyright (C) 1985 Free Software Foundation, Inc.
X
X		       NO WARRANTY
X
X  BECAUSE THIS PROGRAM IS LICENSED FREE OF CHARGE, WE PROVIDE ABSOLUTELY
XNO WARRANTY, TO THE EXTENT PERMITTED BY APPLICABLE STATE LAW.  EXCEPT
XWHEN OTHERWISE STATED IN WRITING, FREE SOFTWARE FOUNDATION, INC,
XRICHARD M. STALLMAN AND/OR OTHER PARTIES PROVIDE THIS PROGRAM "AS IS"
XWITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
XBUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
XFITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY
XAND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE
XDEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
XCORRECTION.
X
X IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW WILL RICHARD M.
XSTALLMAN, THE FREE SOFTWARE FOUNDATION, INC., AND/OR ANY OTHER PARTY
XWHO MAY MODIFY AND REDISTRIBUTE THIS PROGRAM AS PERMITTED BELOW, BE
XLIABLE TO YOU FOR DAMAGES, INCLUDING ANY LOST PROFITS, LOST MONIES, OR
XOTHER SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
XUSE OR INABILITY TO USE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR
XDATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD PARTIES OR
XA FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS) THIS
XPROGRAM, EVEN IF YOU HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH
XDAMAGES, OR FOR ANY CLAIM BY ANY OTHER PARTY.
X
X		GENERAL PUBLIC LICENSE TO COPY
X
X  1. You may copy and distribute verbatim copies of this source file
Xas you receive it, in any medium, provided that you conspicuously and
Xappropriately publish on each copy a valid copyright notice "Copyright
X(C) 1985 Free Software Foundation, Inc."; and include following the
Xcopyright notice a verbatim copy of the above disclaimer of warranty
Xand of this License.  You may charge a distribution fee for the
Xphysical act of transferring a copy.
X
X  2. You may modify your copy or copies of this source file or
Xany portion of it, and copy and distribute such modifications under
Xthe terms of Paragraph 1 above, provided that you also do the following:
X
X    a) cause the modified files to carry prominent notices stating
X    that you changed the files and the date of any change; and
X
X    b) cause the whole of any work that you distribute or publish,
X    that in whole or in part contains or is a derivative of this
X    program or any part thereof, to be licensed at no charge to all
X    third parties on terms identical to those contained in this
X    License Agreement (except that you may choose to grant more extensive
X    warranty protection to some or all third parties, at your option).
X
X    c) You may charge a distribution fee for the physical act of
X    transferring a copy, and you may at your option offer warranty
X    protection in exchange for a fee.
X
XMere aggregation of another unrelated program with this program (or its
Xderivative) on a volume of a storage or distribution medium does not bring
Xthe other program under the scope of these terms.
X
X  3. You may copy and distribute this program (or a portion or derivative
Xof it, under Paragraph 2) in object code or executable form under the terms
Xof Paragraphs 1 and 2 above provided that you also do one of the following:
X
X    a) accompany it with the complete corresponding machine-readable
X    source code, which must be distributed under the terms of
X    Paragraphs 1 and 2 above; or,
X
X    b) accompany it with a written offer, valid for at least three
X    years, to give any third party free (except for a nominal
X    shipping charge) a complete machine-readable copy of the
X    corresponding source code, to be distributed under the terms of
X    Paragraphs 1 and 2 above; or,
X
X    c) accompany it with the information you received as to where the
X    corresponding source code may be obtained.  (This alternative is
X    allowed only for noncommercial distribution and only if you
X    received the program in object code or executable form alone.)
X
XFor an executable file, complete source code means all the source code for
Xall modules it contains; but, as a special exception, it need not include
Xsource code for modules which are standard libraries that accompany the
Xoperating system on which the executable file runs.
X
X  4. You may not copy, sublicense, distribute or transfer this program
Xexcept as expressly provided under this License Agreement.  Any attempt
Xotherwise to copy, sublicense, distribute or transfer this program is void and
Xyour rights to use the program under this License agreement shall be
Xautomatically terminated.  However, parties who have received computer
Xsoftware programs from you with this License Agreement will not have
Xtheir licenses terminated so long as such parties remain in full compliance.
X
X  5. If you wish to incorporate parts of this program into other free
Xprograms whose distribution conditions are different, write to the Free
XSoftware Foundation at 675 Mass Ave, Cambridge, MA 02139.  We have not yet
Xworked out a simple rule that can be stated here, but we will often permit
Xthis.  We will be guided by the two goals of preserving the free status of
Xall derivatives of our free software and of promoting the sharing and reuse of
Xsoftware.
X
X
XIn other words, you are welcome to use, share and improve this program.
XYou are forbidden to forbid anyone else to use, share and improve
Xwhat you give them.   Help stamp out software-hoarding!  */
X
X
X/* Define number of parens for which we record the beginnings and ends.
X   This affects how much space the `struct re_registers' type takes up.  */
X#ifndef RE_NREGS
X#define RE_NREGS 10
X#endif
X
X/* These bits are used in the obscure_syntax variable to choose among
X   alternative regexp syntaxes.  */
X
X/* 1 means plain parentheses serve as grouping, and backslash
X     parentheses are needed for literal searching.
X   0 means backslash-parentheses are grouping, and plain parentheses
X     are for literal searching.  */
X#define RE_NO_BK_PARENS 1
X
X/* 1 means plain | serves as the "or"-operator, and \| is a literal.
X   0 means \| serves as the "or"-operator, and | is a literal.  */
X#define RE_NO_BK_VBAR 2
X
X/* 0 means plain + or ? serves as an operator, and \+, \? are literals.
X   1 means \+, \? are operators and plain +, ? are literals.  */
X#define RE_BK_PLUS_QM 4
X
X/* 1 means | binds tighter than ^ or $.
X   0 means the contrary.  */
X#define RE_TIGHT_VBAR 8
X
X/* 1 means treat \n as an _OR operator
X   0 means treat it as a normal character */
X#define RE_NEWLINE_OR 16
X
X/* 0 means that a special characters (such as *, ^, and $) always have
X     their special meaning regardless of the surrounding context.
X   1 means that special characters may act as normal characters in some
X     contexts.  Specifically, this applies to:
X	^ - only special at the beginning, or after ( or |
X	$ - only special at the end, or before ) or |
X	*, +, ? - only special when not after the beginning, (, or | */
X#define RE_CONTEXT_INDEP_OPS 32
X
X/* 0 means that \ before anything inside [ and ] is taken as a real \.
X   1 means that such a \ escapes the following character  This is a
X   special case for AWK. */
X#define RE_AWK_CLASS_HACK 64
X
X/* Now define combinations of bits for the standard possibilities.  */
X#define RE_SYNTAX_POSIX_EGREP (RE_NO_BK_PARENS | RE_NO_BK_VBAR \
X			| RE_CONTEXT_INDEP_OPS)
X#define RE_SYNTAX_AWK (RE_SYNTAX_POSIX_EGREP | RE_AWK_CLASS_HACK)
X#define RE_SYNTAX_EGREP (RE_SYNTAX_POSIX_EGREP | RE_NEWLINE_OR)
X#define RE_SYNTAX_GREP (RE_BK_PLUS_QM | RE_NEWLINE_OR)
X#define RE_SYNTAX_EMACS 0
X
X/* This data structure is used to represent a compiled pattern. */
X
Xstruct re_pattern_buffer
X  {
X    char *buffer;	/* Space holding the compiled pattern commands. */
X    int allocated;	/* Size of space that  buffer  points to */
X    int used;		/* Length of portion of buffer actually occupied */
X    char *fastmap;	/* Pointer to fastmap, if any, or zero if none. */
X			/* re_search uses the fastmap, if there is one,
X			   to skip quickly over totally implausible characters */
X    char *translate;	/* Translate table to apply to all characters before comparing.
X			   Or zero for no translation.
X			   The translation is applied to a pattern when it is compiled
X			   and to data when it is matched. */
X    char fastmap_accurate;
X			/* Set to zero when a new pattern is stored,
X			   set to one when the fastmap is updated from it. */
X    char can_be_null;   /* Set to one by compiling fastmap
X			   if this pattern might match the null string.
X			   It does not necessarily match the null string
X			   in that case, but if this is zero, it cannot.
X			   2 as value means can match null string
X			   but at end of range or before a character
X			   listed in the fastmap.  */
X  };
X
X/* Structure to store "register" contents data in.
X
X   Pass the address of such a structure as an argument to re_match, etc.,
X   if you want this information back.
X
X   start[i] and end[i] record the string matched by \( ... \) grouping i,
X   for i from 1 to RE_NREGS - 1.
X   start[0] and end[0] record the entire string matched. */
X
Xstruct re_registers
X  {
X    int start[RE_NREGS];
X    int end[RE_NREGS];
X  };
X
X/* These are the command codes that appear in compiled regular expressions, one per byte.
X  Some command codes are followed by argument bytes.
X  A command code can specify any interpretation whatever for its arguments.
X  Zero-bytes may appear in the compiled regular expression. */
X
Xenum regexpcode
X  {
X    unused,
X    exactn,    /* followed by one byte giving n, and then by n literal bytes */
X    begline,   /* fails unless at beginning of line */
X    endline,   /* fails unless at end of line */
X    jump,	 /* followed by two bytes giving relative address to jump to */
X    on_failure_jump,	 /* followed by two bytes giving relative address of place
X		            to resume at in case of failure. */
X    finalize_jump,	 /* Throw away latest failure point and then jump to address. */
X    maybe_finalize_jump, /* Like jump but finalize if safe to do so.
X			    This is used to jump back to the beginning
X			    of a repeat.  If the command that follows
X			    this jump is clearly incompatible with the
X			    one at the beginning of the repeat, such that
X			    we can be sure that there is no use backtracking
X			    out of repetitions already completed,
X			    then we finalize. */
X    dummy_failure_jump,  /* jump, and push a dummy failure point.
X			    This failure point will be thrown away
X			    if an attempt is made to use it for a failure.
X			    A + construct makes this before the first repeat.  */
X    anychar,	 /* matches any one character */
X    charset,     /* matches any one char belonging to specified set.
X		    First following byte is # bitmap bytes.
X		    Then come bytes for a bit-map saying which chars are in.
X		    Bits in each byte are ordered low-bit-first.
X		    A character is in the set if its bit is 1.
X		    A character too large to have a bit in the map
X		    is automatically not in the set */
X    charset_not, /* similar but match any character that is NOT one of those specified */
X    start_memory, /* starts remembering the text that is matched
X		    and stores it in a memory register.
X		    followed by one byte containing the register number.
X		    Register numbers must be in the range 0 through NREGS. */
X    stop_memory, /* stops remembering the text that is matched
X		    and stores it in a memory register.
X		    followed by one byte containing the register number.
X		    Register numbers must be in the range 0 through NREGS. */
X    duplicate,    /* match a duplicate of something remembered.
X		    Followed by one byte containing the index of the memory register. */
X    before_dot,	 /* Succeeds if before dot */
X    at_dot,	 /* Succeeds if at dot */
X    after_dot,	 /* Succeeds if after dot */
X    begbuf,      /* Succeeds if at beginning of buffer */
X    endbuf,      /* Succeeds if at end of buffer */
X    wordchar,    /* Matches any word-constituent character */
X    notwordchar, /* Matches any char that is not a word-constituent */
X    wordbeg,	 /* Succeeds if at word beginning */
X    wordend,	 /* Succeeds if at word end */
X    wordbound,   /* Succeeds if at a word boundary */
X    notwordbound, /* Succeeds if not at a word boundary */
X    syntaxspec,  /* Matches any character whose syntax is specified.
X		    followed by a byte which contains a syntax code, Sword or such like */
X    notsyntaxspec /* Matches any character whose syntax differs from the specified. */
X  };
X
Xextern char *re_compile_pattern ();
X/* Is this really advertised? */
Xextern void re_compile_fastmap ();
Xextern int re_search (), re_search_2 ();
Xextern int re_match (), re_match_2 ();
X
X/* 4.2 bsd compatibility (yuck) */
Xextern char *re_comp ();
Xextern int re_exec ();
X
X#ifdef SYNTAX_TABLE
Xextern char *re_syntax_table;
X#endif
END_OF_FILE
  if test 12788 -ne `wc -c <'./regex.h'`; then
    echo shar: \"'./regex.h'\" unpacked with wrong size!
  fi
  # end of './regex.h'
fi
echo shar: End of archive 14 \(of 16\).
cp /dev/null ark14isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 16 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
-- 
Please send comp.sources.unix-related mail to rsalz@uunet.uu.net.
Use a domain-based address or give alternate paths, or you may lose out.
