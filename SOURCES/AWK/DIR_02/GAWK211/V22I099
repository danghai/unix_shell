From: rsalz@uunet.uu.net (Rich Salz)
Newsgroups: comp.sources.unix
Subject: v22i099:  GNU AWK, version 2.11, Part13/16
Message-ID: <2638@papaya.bbn.com>
Date: 7 Jun 90 20:31:22 GMT
Approved: rsalz@uunet.UU.NET

Submitted-by: "Arnold D. Robbins" <arnold@unix.cc.emory.edu>
Posting-number: Volume 22, Issue 99
Archive-name: gawk2.11/part13

[ There are about 15 control characters in the texinfo.tex.02 file.
  CTRL/A through CTRL/Z.  Look at lines 625-647.  --r$ ]

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  ./awk.h ./pc.d/Makefile.pc ./support/texinfo.tex.02
# Wrapped by rsalz@litchi.bbn.com on Wed Jun  6 12:24:59 1990
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 13 (of 16)."'
if test -f './awk.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./awk.h'\"
else
  echo shar: Extracting \"'./awk.h'\" \(16647 characters\)
  sed "s/^X//" >'./awk.h' <<'END_OF_FILE'
X/*
X * awk.h -- Definitions for gawk. 
X */
X
X/* 
X * Copyright (C) 1986, 1988, 1989 the Free Software Foundation, Inc.
X * 
X * This file is part of GAWK, the GNU implementation of the
X * AWK Progamming Language.
X * 
X * GAWK is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X * 
X * GAWK is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X * 
X * You should have received a copy of the GNU General Public License
X * along with GAWK; see the file COPYING.  If not, write to
X * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X
X/* ------------------------------ Includes ------------------------------ */
X#include <stdio.h>
X#include <ctype.h>
X#include <setjmp.h>
X#include <varargs.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <errno.h>
X
X#include "regex.h"
X
X/* ------------------- System Functions, Variables, etc ------------------- */
X/* nasty nasty SunOS-ism */
X#ifdef sparc
X#include <alloca.h>
X#ifdef lint
Xextern char *alloca();
X#endif
X#else
Xextern char *alloca();
X#endif
X#ifdef SPRINTF_INT
Xextern int sprintf();
X#else	/* not USG */
X/* nasty nasty berkelixm */
X#define setjmp	_setjmp
X#define longjmp	_longjmp
X
Xextern char *sprintf();
X#endif
X/*
X * if you don't have vprintf, but you are BSD, the version defined in
X * vprintf.c should do the trick.  Otherwise, use this and cross your fingers.
X */
X#if defined(VPRINTF_MISSING) && !defined(DOPRNT_MISSING) && !defined(BSDSTDIO)
X#define vfprintf(fp,fmt,arg)	_doprnt((fmt), (arg), (fp))
X#endif
X
X#ifdef __STDC__
Xextern void *malloc(unsigned), *realloc(void *, unsigned);
Xextern void free(char *);
Xextern char *getenv(char *);
X
Xextern char *strcpy(char *, char *), *strcat(char *, char *), *strncpy(char *, char *, int);
Xextern int strcmp(char *, char *);
Xextern int strncmp(char *, char *, int);
Xextern int strncasecmp(char *, char *, int);
Xextern char *strerror(int);
Xextern char *strchr(char *, int);
Xextern int strlen(char *);
Xextern	char *memcpy(char *, char *, int);
Xextern	int memcmp(char *, char *, int);
Xextern	char *memset(char *, int, int);
X
X/* extern int fprintf(FILE *, char *, ...); */
Xextern int fprintf();
Xextern int vfprintf();
X#ifndef MSDOS
Xextern int fwrite(char *, int, int, FILE *);
X#endif
Xextern int fflush(FILE *);
Xextern int fclose(FILE *);
Xextern int pclose(FILE *);
X#ifndef MSDOS
Xextern int fputs(char *, FILE *);
X#endif
Xextern void abort();
Xextern int isatty(int);
Xextern void exit(int);
Xextern int system(char *);
Xextern int sscanf(/* char *, char *, ... */);
X
Xextern double atof(char *);
Xextern int fstat(int, struct stat *);
Xextern off_t lseek(int, off_t, int);
Xextern int fseek(FILE *, long, int);
Xextern int close(int);
Xextern int open();
Xextern int pipe(int *);
Xextern int dup2(int, int);
X#ifndef MSDOS
Xextern int unlink(char *);
X#endif
Xextern int fork();
Xextern int execl(/* char *, char *, ... */);
Xextern int read(int, char *, int);
Xextern int wait(int *);
Xextern void _exit(int);
X#else
Xextern void _exit();
Xextern int wait();
Xextern int read();
Xextern int execl();
Xextern int fork();
Xextern int unlink();
Xextern int dup2();
Xextern int pipe();
Xextern int open();
Xextern int close();
Xextern int fseek();
Xextern off_t lseek();
Xextern int fstat();
Xextern void exit();
Xextern int system();
Xextern int isatty();
Xextern void abort();
Xextern int fputs();
Xextern int fclose();
Xextern int pclose();
Xextern int fflush();
Xextern int fwrite();
Xextern int fprintf();
Xextern int vfprintf();
Xextern int sscanf();
Xextern char *malloc(), *realloc();
Xextern void free();
Xextern char *getenv();
X
Xextern int strcmp();
Xextern int strncmp();
Xextern int strncasecmp();
Xextern int strlen();
Xextern char *strcpy(), *strcat(), *strncpy();
Xextern	char *memset();
Xextern	int memcmp();
Xextern	char *memcpy();
Xextern char *strerror();
Xextern char *strchr();
X
Xextern double atof();
X#endif
X
X#ifndef MSDOS
Xextern int errno;
X#endif	/* MSDOS */
X
X/* ------------------ Constants, Structures, Typedefs  ------------------ */
X#define AWKNUM	double
X
Xtypedef enum {
X	/* illegal entry == 0 */
X	Node_illegal,
X
X	/* binary operators  lnode and rnode are the expressions to work on */
X	Node_times,
X	Node_quotient,
X	Node_mod,
X	Node_plus,
X	Node_minus,
X	Node_cond_pair,		/* conditional pair (see Node_line_range) */
X	Node_subscript,
X	Node_concat,
X	Node_exp,
X
X	/* unary operators   subnode is the expression to work on */
X/*10*/	Node_preincrement,
X	Node_predecrement,
X	Node_postincrement,
X	Node_postdecrement,
X	Node_unary_minus,
X	Node_field_spec,
X
X	/* assignments   lnode is the var to assign to, rnode is the exp */
X	Node_assign,
X	Node_assign_times,
X	Node_assign_quotient,
X	Node_assign_mod,
X/*20*/	Node_assign_plus,
X	Node_assign_minus,
X	Node_assign_exp,
X
X	/* boolean binaries   lnode and rnode are expressions */
X	Node_and,
X	Node_or,
X
X	/* binary relationals   compares lnode and rnode */
X	Node_equal,
X	Node_notequal,
X	Node_less,
X	Node_greater,
X	Node_leq,
X/*30*/	Node_geq,
X	Node_match,
X	Node_nomatch,
X
X	/* unary relationals   works on subnode */
X	Node_not,
X
X	/* program structures */
X	Node_rule_list,		/* lnode is a rule, rnode is rest of list */
X	Node_rule_node,		/* lnode is pattern, rnode is statement */
X	Node_statement_list,	/* lnode is statement, rnode is more list */
X	Node_if_branches,	/* lnode is to run on true, rnode on false */
X	Node_expression_list,	/* lnode is an exp, rnode is more list */
X	Node_param_list,	/* lnode is a variable, rnode is more list */
X
X	/* keywords */
X/*40*/	Node_K_if,		/* lnode is conditonal, rnode is if_branches */
X	Node_K_while,		/* lnode is condtional, rnode is stuff to run */
X	Node_K_for,		/* lnode is for_struct, rnode is stuff to run */
X	Node_K_arrayfor,	/* lnode is for_struct, rnode is stuff to run */
X	Node_K_break,		/* no subs */
X	Node_K_continue,	/* no stuff */
X	Node_K_print,		/* lnode is exp_list, rnode is redirect */
X	Node_K_printf,		/* lnode is exp_list, rnode is redirect */
X	Node_K_next,		/* no subs */
X	Node_K_exit,		/* subnode is return value, or NULL */
X	Node_K_do,		/* lnode is conditional, rnode stuff to run */
X	Node_K_return,
X	Node_K_delete,
X	Node_K_getline,
X	Node_K_function,	/* lnode is statement list, rnode is params */
X
X	/* I/O redirection for print statements */
X	Node_redirect_output,	/* subnode is where to redirect */
X	Node_redirect_append,	/* subnode is where to redirect */
X	Node_redirect_pipe,	/* subnode is where to redirect */
X	Node_redirect_pipein,	/* subnode is where to redirect */
X	Node_redirect_input,	/* subnode is where to redirect */
X
X	/* Variables */
X	Node_var,		/* rnode is value, lnode is array stuff */
X	Node_var_array,		/* array is ptr to elements, asize num of
X				 * eles */
X	Node_val,		/* node is a value - type in flags */
X
X	/* Builtins   subnode is explist to work on, proc is func to call */
X	Node_builtin,
X
X	/*
X	 * pattern: conditional ',' conditional ;  lnode of Node_line_range
X	 * is the two conditionals (Node_cond_pair), other word (rnode place)
X	 * is a flag indicating whether or not this range has been entered.
X	 */
X	Node_line_range,
X
X	/*
X	 * boolean test of membership in array lnode is string-valued
X	 * expression rnode is array name 
X	 */
X	Node_in_array,
X
X	Node_func,		/* lnode is param. list, rnode is body */
X	Node_func_call,		/* lnode is name, rnode is argument list */
X
X	Node_cond_exp,		/* lnode is conditonal, rnode is if_branches */
X	Node_regex,
X	Node_hashnode,
X	Node_ahash,
X} NODETYPE;
X
X/*
X * NOTE - this struct is a rather kludgey -- it is packed to minimize
X * space usage, at the expense of cleanliness.  Alter at own risk.
X */
Xtypedef struct exp_node {
X	union {
X		struct {
X			union {
X				struct exp_node *lptr;
X				char *param_name;
X				char *retext;
X				struct exp_node *nextnode;
X			} l;
X			union {
X				struct exp_node *rptr;
X				struct exp_node *(*pptr) ();
X				struct re_pattern_buffer *preg;
X				struct for_loop_header *hd;
X				struct exp_node **av;
X				int r_ent;	/* range entered */
X			} r;
X			char *name;
X			short number;
X			unsigned char recase;
X		} nodep;
X		struct {
X			AWKNUM fltnum;	/* this is here for optimal packing of
X					 * the structure on many machines
X					 */
X			char *sp;
X			short slen;
X			unsigned char sref;
X		} val;
X		struct {
X			struct exp_node *next;
X			char *name;
X			int length;
X			struct exp_node *value;
X		} hash;
X#define	hnext	sub.hash.next
X#define	hname	sub.hash.name
X#define	hlength	sub.hash.length
X#define	hvalue	sub.hash.value
X		struct {
X			struct exp_node *next;
X			struct exp_node *name;
X			struct exp_node *value;
X		} ahash;
X#define	ahnext	sub.ahash.next
X#define	ahname	sub.ahash.name
X#define	ahvalue	sub.ahash.value
X	} sub;
X	NODETYPE type;
X	unsigned char flags;
X#			define	MEM	0x7
X#			define	MALLOC	1	/* can be free'd */
X#			define	TEMP	2	/* should be free'd */
X#			define	PERM	4	/* can't be free'd */
X#			define	VAL	0x18
X#			define	NUM	8	/* numeric value is valid */
X#			define	STR	16	/* string value is valid */
X#			define	NUMERIC	32	/* entire field is numeric */
X} NODE;
X
X#define lnode	sub.nodep.l.lptr
X#define nextp	sub.nodep.l.nextnode
X#define rnode	sub.nodep.r.rptr
X#define source_file	sub.nodep.name
X#define	source_line	sub.nodep.number
X#define	param_cnt	sub.nodep.number
X#define param	sub.nodep.l.param_name
X
X#define subnode	lnode
X#define proc	sub.nodep.r.pptr
X
X#define reexp	lnode
X#define rereg	sub.nodep.r.preg
X#define re_case sub.nodep.recase
X#define re_text sub.nodep.l.retext
X
X#define forsub	lnode
X#define forloop	rnode->sub.nodep.r.hd
X
X#define stptr	sub.val.sp
X#define stlen	sub.val.slen
X#define stref	sub.val.sref
X#define	valstat	flags
X
X#define numbr	sub.val.fltnum
X
X#define var_value lnode
X#define var_array sub.nodep.r.av
X
X#define condpair lnode
X#define triggered sub.nodep.r.r_ent
X
X#define HASHSIZE 101
X
Xtypedef struct for_loop_header {
X	NODE *init;
X	NODE *cond;
X	NODE *incr;
X} FOR_LOOP_HEADER;
X
X/* for "for(iggy in foo) {" */
Xstruct search {
X	int numleft;
X	NODE **arr_ptr;
X	NODE *bucket;
X	NODE *retval;
X};
X
X/* for faster input, bypass stdio */
Xtypedef struct iobuf {
X	int fd;
X	char *buf;
X	char *off;
X	int size;	/* this will be determined by an fstat() call */
X	int cnt;
X	char *secbuf;
X	int secsiz;
X	int flag;
X#	define		IOP_IS_TTY	1
X} IOBUF;
X
X/*
X * structure used to dynamically maintain a linked-list of open files/pipes
X */
Xstruct redirect {
X	int flag;
X#		define		RED_FILE	1
X#		define		RED_PIPE	2
X#		define		RED_READ	4
X#		define		RED_WRITE	8
X#		define		RED_APPEND	16
X#		define		RED_NOBUF	32
X	char *value;
X	FILE *fp;
X	IOBUF *iop;
X	int pid;
X	int status;
X	long offset;		/* used for dynamic management of open files */
X	struct redirect *prev;
X	struct redirect *next;
X};
X
X/* longjmp return codes, must be nonzero */
X/* Continue means either for loop/while continue, or next input record */
X#define TAG_CONTINUE 1
X/* Break means either for/while break, or stop reading input */
X#define TAG_BREAK 2
X/* Return means return from a function call; leave value in ret_node */
X#define	TAG_RETURN 3
X
X#ifdef MSDOS
X#define HUGE	0x7fff
X#else
X#define HUGE	0x7fffffff
X#endif
X
X/* -------------------------- External variables -------------------------- */
X/* gawk builtin variables */
Xextern NODE *FS_node, *NF_node, *RS_node, *NR_node;
Xextern NODE *FILENAME_node, *OFS_node, *ORS_node, *OFMT_node;
Xextern NODE *FNR_node, *RLENGTH_node, *RSTART_node, *SUBSEP_node;
Xextern NODE *IGNORECASE_node;
X
Xextern NODE **stack_ptr;
Xextern NODE *Nnull_string;
Xextern NODE *deref;
Xextern NODE **fields_arr;
Xextern int sourceline;
Xextern char *source;
Xextern NODE *expression_value;
X
Xextern NODE *variables[];
X
Xextern NODE *_t;	/* used as temporary in tree_eval */
X
Xextern char *myname;
X
Xextern int node0_valid;
Xextern int field_num;
Xextern int strict;
X
X/* ------------------------- Pseudo-functions ------------------------- */
X#define is_identchar(c) (isalnum(c) || (c) == '_')
X
X
X#define	free_temp(n)	if ((n)->flags&TEMP) { deref = (n); do_deref(); } else
X#define	tree_eval(t)	(_t = (t),(_t) == NULL ? Nnull_string : \
X			((_t)->type == Node_val ? (_t) : r_tree_eval((_t))))
X#define	make_string(s,l)	make_str_node((s),(l),0)
X
X#define	cant_happen()	fatal("line %d, file: %s; bailing out", \
X				__LINE__, __FILE__);
X#ifdef MEMDEBUG
X#define memmsg(x,y,z,zz)	fprintf(stderr, "malloc: %s: %s: %d %0x\n", z, x, y, zz)
X#define free(s)	fprintf(stderr, "free: s: %0x\n", s), do_free(s)
X#else
X#define memmsg(x,y,z,zz)
X#endif
X
X#define	emalloc(var,ty,x,str)	if ((var = (ty) malloc((unsigned)(x))) == NULL)\
X				    fatal("%s: %s: can't allocate memory (%s)",\
X					(str), "var", strerror(errno)); else\
X				    memmsg("var", x, str, var)
X#define	erealloc(var,ty,x,str)	if((var=(ty)realloc((char *)var,\
X						(unsigned)(x)))==NULL)\
X				    fatal("%s: %s: can't allocate memory (%s)",\
X					(str), "var", strerror(errno)); else\
X				    memmsg("re: var", x, str, var)
X#ifdef DEBUG
X#define	force_number	r_force_number
X#define	force_string	r_force_string
X#else
X#ifdef lint
Xextern AWKNUM force_number();
X#endif
X#ifdef MSDOS
Xextern double _msc51bug;
X#define	force_number(n)	(_msc51bug=(_t = (n),(_t->flags & NUM) ? _t->numbr : r_force_number(_t)))
X#else
X#define	force_number(n)	(_t = (n),(_t->flags & NUM) ? _t->numbr : r_force_number(_t))
X#endif
X#define	force_string(s)	(_t = (s),(_t->flags & STR) ? _t : r_force_string(_t))
X#endif
X
X#define	STREQ(a,b)	(*(a) == *(b) && strcmp((a), (b)) == 0)
X#define	STREQN(a,b,n)	((n) && *(a) == *(b) && strncmp((a), (b), (n)) == 0)
X
X#define	WHOLELINE	(node0_valid ? fields_arr[0] : *get_field(0,0))
X
X/* ------------- Function prototypes or defs (as appropriate) ------------- */
X#ifdef __STDC__
Xextern	int parse_escape(char **);
Xextern	int devopen(char *, char *);
Xextern	struct re_pattern_buffer *make_regexp(NODE *, int);
Xextern	struct re_pattern_buffer *mk_re_parse(char *, int);
Xextern	NODE *variable(char *);
Xextern	NODE *install(NODE **, char *, NODE *);
Xextern	NODE *lookup(NODE **, char *);
Xextern	NODE *make_name(char *, NODETYPE);
Xextern	int interpret(NODE *);
Xextern	NODE *r_tree_eval(NODE *);
Xextern	void assign_number(NODE **, double);
Xextern	int cmp_nodes(NODE *, NODE *);
Xextern	struct redirect *redirect(NODE *, int *);
Xextern	int flush_io(void);
Xextern	void print_simple(NODE *, FILE *);
X/* extern	void warning(char *,...); */
Xextern	void warning();
X/* extern	void fatal(char *,...); */
Xextern	void fatal();
Xextern	void set_record(char *, int);
Xextern	NODE **get_field(int, int);
Xextern	NODE **get_lhs(NODE *, int);
Xextern	void do_deref(void );
Xextern	struct search *assoc_scan(NODE *);
Xextern	struct search *assoc_next(struct search *);
Xextern	NODE **assoc_lookup(NODE *, NODE *);
Xextern	double r_force_number(NODE *);
Xextern	NODE *r_force_string(NODE *);
Xextern	NODE *newnode(NODETYPE);
Xextern	NODE *dupnode(NODE *);
Xextern	NODE *make_number(double);
Xextern	NODE *tmp_number(double);
Xextern	NODE *make_str_node(char *, int, int);
Xextern	NODE *tmp_string(char *, int);
Xextern	char *re_compile_pattern(char *, int, struct re_pattern_buffer *);
Xextern	int re_search(struct re_pattern_buffer *, char *, int, int, int, struct re_registers *);
Xextern	void freenode(NODE *);
X
X#else
Xextern	int parse_escape();
Xextern	void freenode();
Xextern	int devopen();
Xextern	struct re_pattern_buffer *make_regexp();
Xextern	struct re_pattern_buffer *mk_re_parse();
Xextern	NODE *variable();
Xextern	NODE *install();
Xextern	NODE *lookup();
Xextern	int interpret();
Xextern	NODE *r_tree_eval();
Xextern	void assign_number();
Xextern	int cmp_nodes();
Xextern	struct redirect *redirect();
Xextern	int flush_io();
Xextern	void print_simple();
Xextern	void warning();
Xextern	void fatal();
Xextern	void set_record();
Xextern	NODE **get_field();
Xextern	NODE **get_lhs();
Xextern	void do_deref();
Xextern	struct search *assoc_scan();
Xextern	struct search *assoc_next();
Xextern	NODE **assoc_lookup();
Xextern	double r_force_number();
Xextern	NODE *r_force_string();
Xextern	NODE *newnode();
Xextern	NODE *dupnode();
Xextern	NODE *make_number();
Xextern	NODE *tmp_number();
Xextern	NODE *make_str_node();
Xextern	NODE *tmp_string();
Xextern	char *re_compile_pattern();
Xextern	int re_search();
X#endif
X
X#if !defined(__STDC__) || __STDC__ <= 0
X#define volatile
X#endif
X
X/* Figure out what '\a' really is. */
X#ifdef __STDC__
X#define BELL	'\a'		/* sure makes life easy, don't it? */
X#else
X#	if 'z' - 'a' == 25	/* ascii */
X#		if 'a' != 97	/* machine is dumb enough to use mark parity */
X#			define BELL	'\207'
X#		else
X#			define BELL	'\07'
X#		endif
X#	else
X#		define BELL	'\057'
X#	endif
X#endif
X
X#ifndef SIGTYPE
X#define SIGTYPE	void
X#endif
X
Xextern char casetable[];	/* for case-independent regexp matching */
END_OF_FILE
  if test 16647 -ne `wc -c <'./awk.h'`; then
    echo shar: \"'./awk.h'\" unpacked with wrong size!
  fi
  # end of './awk.h'
fi
if test -f './pc.d/Makefile.pc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./pc.d/Makefile.pc'\"
else
  echo shar: Extracting \"'./pc.d/Makefile.pc'\" \(8503 characters\)
  sed "s/^X//" >'./pc.d/Makefile.pc' <<'END_OF_FILE'
X# Makefile for GNU Awk.
X#
X# Copyright (C) 1986, 1988, 1989 the Free Software Foundation, Inc.
X# 
X# This file is part of GAWK, the GNU implementation of the
X# AWK Progamming Language.
X# 
X# GAWK is free software; you can redistribute it and/or modify
X# it under the terms of the GNU General Public License as published by
X# the Free Software Foundation; either version 1, or (at your option)
X# any later version.
X# 
X# GAWK is distributed in the hope that it will be useful,
X# but WITHOUT ANY WARRANTY; without even the implied warranty of
X# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X# GNU General Public License for more details.
X# 
X# You should have received a copy of the GNU General Public License
X# along with GAWK; see the file COPYING.  If not, write to
X# the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X
X# User tunable macros
X
X# CFLAGS: options to the C compiler
X#
X#	-O	optimize
X#	-g	include dbx/sdb info
X#	-gg	include gdb debugging info; only for GCC (deprecated)
X#	-pg	include new (gmon) profiling info
X#	-p	include old style profiling info (System V)
X#
X#	To port GAWK, examine and adjust the following flags carefully.
X#	In addition, you will have to look at alloca below.
X#	The intent (eventual) is to not penalize the most-standard-conforming
X#	systems with a lot of #define's.
X#
X#	-DBCOPY_MISSING		- bcopy() et al. are missing; will replace
X#				  with a #define'd memcpy() et al. -- use at
X#				  your own risk (should really use a memmove())
X#	-DSPRINTF_INT		- sprintf() returns int (most USG systems)
X#	-DBLKSIZE_MISSING	- st_blksize missing from stat() structure
X#				  (most USG systems)
X#	-DBSDSTDIO		- has a BSD internally-compatible stdio
X#	-DDOPRNT_MISSING	- lacks doprnt() routine
X#	-DDUP2_MISSING		- lacks dup2() system call (S5Rn, n < 4)
X#	-DGCVT_MISSING		- lacks gcvt() routine
X#	-DGETOPT_MISSING	- lacks getopt() routine
X#	-DMEMCMP_MISSING	- lacks memcmp() routine
X#	-DMEMCPY_MISSING	- lacks memcpy() routine
X#	-DMEMSET_MISSING	- lacks memset() routine
X#	-DRANDOM_MISSING	- lacks random() routine
X#	-DSTRCASE_MISSING	- lacks strcasecmp() routine
X#	-DSTRCHR_MISSING	- lacks strchr() and strrchr() routines
X#	-DSTRERROR_MISSING	- lacks (ANSI C) strerror() routine
X#	-DSTRTOD_MISSING	- lacks strtod() routine
X#	-DTMPNAM_MISSING	- lacks or deficient tmpnam() routine
X#	-DVPRINTF_MISSING	- lacks vprintf and associated routines
X#	-DSIGTYPE=int		- signal routines return int (default void)
X
X# Sun running SunOS 4.x
X# MISSING = -DSTRERROR_MISSING -DSTRCASE_MISSING
X
X# SGI Personal Iris (Sys V derived)
X# MISSING = -DSPRINTF_INT -DBLKSIZE_MISSING -DSTRERROR_MISSING -DRANDOM_MISSING
X
X# VAX running Ultrix 3.x
X# MISSING = -DSTRERROR_MISSING
X
X# A generic 4.2 BSD machine
X# (eliminate GETOPT_MISSING for 4.3 release)
X# (eliminate STRCASE_MISSING and TMPNAM_MISSING for Tahoe release)
X# MISSING = -DBSDSTDIO -DMEMCMP_MISSING -DMEMCPY_MISSING -DMEMSET_MISSING \
X#	-DSTRERROR_MISSING -DSTRTOD_MISSING -DVPRINTF_MISSING \
X#	-DSTRCASE_MISSING -DTMPNAM_MISSING \
X#	-DGETOPT_MISSING -DSTRCHR_MISSING -DSIGTYPE=int
X
X# On Amdahl UTS, a SysVr2-derived system
X# MISSING = -DBCOPY_MISSING -DSPRINTF_INT -DRANDOM_MISSING -DSTRERROR_MISSING \
X#	-DSTRCASE_MISSING -DDUP2_MISSING # -DBLKSIZE_MISSING ??????
X
X# Comment out the next line if you don't have gcc.
X# Also choose just one of -g and -O.
X# CC=		 gcc
X# for DOS
XCC= cl
XPOPEN = popen.o
X
X# for DOS, most of the missing symbols are defined in MISSING.C in order to
X# get around the command line length limitations
XMISSING = -DSPRINTF_INT -DBLKSIZE_MISSING -DBCOPY_MISSING
XLINKFLAGS= /MAP /CO /FAR /PACKC /NOE /NOIG /st:0x1800
X
X# also give suffixes and explicit rule for DOS
X.SUFFIXES : .o .c
X.c.o:
X	$(CC) -c $(CFLAGS) -Ipc.d -W2 -AL -Fo$*.o $<
X	
XOPTIMIZE=	-Od -Zi
XPROFILE=	#-pg
XDEBUG=		#-DDEBUG #-DMEMDEBUG #-DFUNC_TRACE #-DMPROF
XDEBUGGER=	#-g -Bstatic
XWARN=		#-W -Wunused -Wimplicit -Wreturn-type -Wcomment	# for gcc only
X
X# Parser to use on grammar -- if you don't have bison use the first one
X#PARSER = yacc
XPARSER = bison
X
X# ALLOCA
X#	Set equal to alloca.o if your system is S5 and you don't have
X#	alloca. Uncomment one of the rules below to make alloca.o from
X#	either alloca.s or alloca.c.
XALLOCA= #alloca.o
X
X#
X# With the exception of the alloca rule referred to above, you shouldn't
X# need to customize this file below this point.
X#
X
XFLAGS= $(MISSING) $(DEBUG)
XCFLAGS= $(FLAGS) $(DEBUGGER) $(PROFILE) $(OPTIMIZE) $(WARN)
X
X# object files
XO1 = main.o eval.o builtin.o msg.o debug.o io.o field.o array.o node.o
XO2 = version.o missing.o $(POPEN)
X
XAWKOBJS = $(O1) $(O2)
X
X
X# for unix
X# AWKTAB = awk.tab.o
X# for dos
XAWKTAB = awk_tab.o
X
X
X
XALLOBJS = $(AWKOBJS) $(AWKTAB)
X
X# GNUOBJS
X#	GNU stuff that gawk uses as library routines.
XGNUOBJS= regex.o $(ALLOCA)
X
X# source and documentation files
XSRC =	main.c eval.c builtin.c msg.c \
X	debug.c io.c field.c array.c node.c missing.c
X
XALLSRC= $(SRC) awk.tab.c
X
XAWKSRC= awk.h awk.y $(ALLSRC) version.sh patchlevel.h
X
XGNUSRC = alloca.c alloca.s regex.c regex.h
X
XCOPIES = missing.d/dup2.c missing.d/gcvt.c missing.d/getopt.c \
X	missing.d/memcmp.c missing.d/memcpy.c missing.d/memset.c \
X	missing.d/random.c missing.d/strcase.c missing.d/strchr.c \
X	missing.d/strerror.c missing.d/strtod.c missing.d/tmpnam.c \
X	missing.d/vprintf.c
X
XSUPPORT = support/texindex.c support/texinfo.tex
X
XDOCS= gawk.1 gawk.texinfo
X
XINFOFILES= gawk-info gawk-info-1 gawk-info-2 gawk-info-3 gawk-info-4 \
X	   gawk-info-5 gawk-info-6 gawk.aux gawk.cp gawk.cps gawk.fn \
X	   gawk.fns gawk.ky gawk.kys gawk.pg gawk.pgs gawk.toc \
X	   gawk.tp gawk.tps gawk.vr gawk.vrs
X
XMISC = CHANGES COPYING FUTURES Makefile PROBLEMS README
X
XPCSTUFF= pc.d/Makefile.pc pc.d/popen.c pc.d/popen.h
X
XALLDOC= gawk.dvi $(INFOFILES)
X
XALLFILES= $(AWKSRC) $(GNUSRC) $(COPIES) $(MISC) $(DOCS) $(ALLDOC) $(PCSTUFF) $(SUPPORT)
X
X# Release of gawk.  There can be no leading or trailing white space here!
XREL=2.11
X# for unix
X# GAWK = gawk
X# for DOS
XGAWK = gawk.exe
X$(GAWK) : $(ALLOBJS) $(GNUOBJS) names.lnk
X	link @names.lnk
X
X#GNULIB = ..\lib\lgnu.lib 
XGNULIB = 
Xnames.lnk : makefile
X	echo $(O1) + > $@
X	echo $(O2) + >> $@
X	echo $(AWKTAB) + >> $@
X	echo $(GNUOBJS) >> $@
X	echo $(GAWK) >> $@
X	echo gawk.map >> $@
X	echo $(GNULIB) $(LINKFLAGS) >> $@
X
Xpopen.o : pc.d\popen.c
X	$(CC) -c $(CFLAGS) -Ipc.d -W2 -AL -Fo$*.o pc.d\popen.c
X
X# rules to build gawk
X#$(GAWK) : $(ALLOBJS) $(GNUOBJS)
X#	$(CC) -o gawk $(CFLAGS) $(ALLOBJS) $(GNUOBJS) -lm
X
X$(AWKOBJS): awk.h
X
Xmain.o: patchlevel.h
X
X#awk.tab.o: awk.h awk.tab.c
X#
X#awk.tab.c: awk.y
X#	$(PARSER) -v awk.y
X#	-mv -f y.tab.c awk.tab.c
X
X# for dos
Xawk_tab.o : awk.y awk.h
X	bison -y awk.y
X	$(CC) -c $(CFLAGS) -Ipc.d -W2 -AL -Fo$@ y_tab.c
X	@-rm y_tab.c
X
Xversion.c: version.sh
X	sh version.sh $(REL) > version.c
X
X# Alloca: uncomment this if your system (notably System V boxen)
X# does not have alloca in /lib/libc.a
X#
X#alloca.o: alloca.s
X#	/lib/cpp < alloca.s | sed '/^#/d' > t.s
X#	as t.s -o alloca.o
X#	rm t.s
X
X# If your machine is not supported by the assembly version of alloca.s,
X# use the C version instead.  This uses the default rules to make alloca.o.
X#
X#alloca.o: alloca.c
X
X# auxiliary rules for release maintenance
Xlint: $(ALLSRC)
X	lint -hcbax $(FLAGS) $(ALLSRC)
X
Xxref:
X	cxref -c $(FLAGS) $(ALLSRC) | grep -v '	/' >xref
X
Xclean:
X	rm -f gawk *.o core awk.output awk.tab.c gmon.out make.out version.c
X
Xclobber: clean
X	rm -f $(ALLDOC) gawk.log
X
Xgawk.dvi: gawk.texinfo
X	tex gawk.texinfo ; texindex gawk.??
X	tex gawk.texinfo ; texindex gawk.??
X	tex gawk.texinfo
X
X$(INFOFILES): gawk.texinfo
X	makeinfo gawk.texinfo
X
Xsrcrelease: $(AWKSRC) $(GNUSRC) $(DOCS) $(MISC) $(COPIES) $(PCSTUFF) $(SUPPORT)
X	-mkdir gawk-$(REL)
X	cp -p $(AWKSRC) $(GNUSRC) $(DOCS) $(MISC) gawk-$(REL)
X	-mkdir gawk-$(REL)/missing.d
X	cp -p $(COPIES) gawk-$(REL)/missing.d
X	-mkdir gawk-$(REL)/pc.d
X	cp -p $(PCSTUFF) gawk-$(REL)/pc.d
X	-mkdir gawk-$(REL)/support
X	cp -p $(SUPPORT) gawk-$(REL)/support
X	tar -cf - gawk-$(REL) | compress > gawk-$(REL).tar.Z
X
Xdocrelease: $(ALLDOC)
X	-mkdir gawk-$(REL)-doc
X	cp -p $(INFOFILES) gawk.dvi gawk-$(REL)-doc
X	nroff -man gawk.1 > gawk-$(REL)-doc/gawk.1.pr
X	tar -cf - gawk-$(REL)-doc | compress > gawk-doc-$(REL).tar.Z
X
Xpsrelease: docrelease
X	-mkdir gawk-postscript
X	dvi2ps gawk.dvi > gawk-postscript/gawk.postscript
X	psroff -t -man gawk.1 > gawk-postscript/gawk.1.ps
X	tar -cf - gawk-postscript | compress > gawk.postscript.tar.Z
X
Xrelease: srcrelease docrelease psrelease
X	rm -fr gawk-postscript gawk-$(REL) gawk-$(REL)-doc
X
Xdiff:
X	for i in RCS/*; do rcsdiff -c -b $$i > `basename $$i ,v`.diff; done
END_OF_FILE
  if test 8503 -ne `wc -c <'./pc.d/Makefile.pc'`; then
    echo shar: \"'./pc.d/Makefile.pc'\" unpacked with wrong size!
  fi
  # end of './pc.d/Makefile.pc'
fi
if test -f './support/texinfo.tex.02' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'./support/texinfo.tex.02'\"
else
  echo shar: Extracting \"'./support/texinfo.tex.02'\" \(25529 characters\)
  sed "s/^X//" >'./support/texinfo.tex.02' <<'END_OF_FILE'
X   \line{\chapentryfonts #1\dotfill \dopageno{#2}}%
X   \nobreak\vskip .25\baselineskip
X}
X
X\def\dosecentry#1#2{%
X   \line{\secentryfonts \hskip\tocindent #1\dotfill \dopageno{#2}}%
X}
X
X\def\dosubsecentry#1#2{%
X   \line{\subsecentryfonts \hskip2\tocindent #1\dotfill \dopageno{#2}}%
X}
X
X\def\dosubsubsecentry#1#2{%
X   \line{\subsubsecentryfonts \hskip3\tocindent #1\dotfill \dopageno{#2}}%
X}
X
X% Space between chapter (or whatever) number and the title.
X\def\labelspace{\hskip1em \relax}
X
X\def\dopageno#1{{\rm #1}}
X\def\doshortpageno#1{{\rm #1}}
X
X\def\chapentryfonts{\secfonts \rm}
X\def\secentryfonts{\textfonts}
X\let\subsecentryfonts = \textfonts
X\let\subsubsecentryfonts = \textfonts
X
X
X\message{environments,}
X
X% Since these characters are used in examples, it should be an even number of 
X% \tt widths. Each \tt character is 1en, so two makes it 1em.
X% Furthermore, these definitions must come after we define our fonts.
X\newbox\dblarrowbox    \newbox\longdblarrowbox
X\newbox\pushcharbox    \newbox\bullbox
X\newbox\equivbox       \newbox\errorbox
X
X\let\ptexequiv = \equiv
X
X{\tentt
X\global\setbox\dblarrowbox = \hbox to 1em{\hfil$\Rightarrow$\hfil}
X\global\setbox\longdblarrowbox = \hbox to 1em{\hfil$\mapsto$\hfil}
X\global\setbox\pushcharbox = \hbox to 1em{\hfil$\dashv$\hfil}
X\global\setbox\equivbox = \hbox to 1em{\hfil$\ptexequiv$\hfil}
X% Adapted from the manmac format (p.420 of TeXbook)
X\global\setbox\bullbox = \hbox to 1em{\kern.15em\vrule height .75ex width .85ex
X                                      depth .1ex\hfil}
X}
X
X\def\point{$\star$}
X
X\def\result{\leavevmode\raise.15ex\copy\dblarrowbox}
X\def\expansion{\leavevmode\raise.1ex\copy\longdblarrowbox}
X\def\print{\leavevmode\lower.1ex\copy\pushcharbox}
X
X\def\equiv{\leavevmode\lower.1ex\copy\equivbox}
X
X% Does anyone really want this?
X% \def\bull{\leavevmode\copy\bullbox}
X
X% Adapted from the TeXbook's \boxit.
X\dimen0 = 3em % Width of the box.
X\dimen2 = .55pt % Thickness of rules
X% The text. (`r' is open on the right, `e' somewhat less so on the left.)
X\setbox0 = \hbox{\kern-.75pt \tensf error\kern-1.5pt}
X
X\global\setbox\errorbox=\hbox to \dimen0{\hfil
X   \vbox{\hsize = \dimen0 \advance\hsize by -5.8pt % Space to left+right.
X      \advance\hsize by -2\dimen2 % Rules.
X      \hrule height\dimen2
X      \hbox{\vrule width\dimen2 \kern3pt          % Space to left of text.
X         \vtop{\kern2.4pt \box0 \kern2.4pt}% Space above/below.
X         \kern3pt\vrule width\dimen2}% Space to right.
X      \hrule height\dimen2}
X    \hfil}
X
X% The @error{} command.
X\def\error{\leavevmode\lower.7ex\copy\errorbox}
X
X% @tex ... @end tex    escapes into raw Tex temporarily.
X% One exception: @ is still an escape character, so that @end tex works.
X% But \@ or @@ will get a plain tex @ character.
X
X\def\tex{\begingroup
X\catcode `\\=0 \catcode `\{=1 \catcode `\}=2
X\catcode `\$=3 \catcode `\&=4 \catcode `\#=6
X\catcode `\^=7 \catcode `\_=8 \catcode `\~=13 \let~=\tie
X\catcode `\%=14
X\catcode`\"=12
X\catcode`\==12
X\catcode`\|=12
X\catcode`\<=12
X\catcode`\>=12
X\escapechar=`\\
X%
X\let\{=\ptexlbrace
X\let\}=\ptexrbrace
X\let\.=\ptexdot
X\let\*=\ptexstar
X\def\@={@}%
X\let\bullet=\ptexbullet
X\let\b=\ptexb \let\c=\ptexc \let\i=\ptexi \let\t=\ptext \let\l=\ptexl
X\let\L=\ptexL
X%
X\let\Etex=\endgroup}
X
X% Define @lisp ... @endlisp.
X% @lisp does a \begingroup so it can rebind things,
X% including the definition of @endlisp (which normally is erroneous).
X
X% Amount to narrow the margins by for @lisp.
X\newskip\lispnarrowing \lispnarrowing=0.4in
X
X% This is the definition that ^M gets inside @lisp
X% phr: changed space to \null, to avoid overfull hbox problems.
X{\obeyspaces%
X\gdef\lisppar{\null\endgraf}}
X
X% Cause \obeyspaces to make each Space cause a word-separation
X% rather than the default which is that it acts punctuation.
X% This is because space in tt font looks funny.
X{\obeyspaces %
X\gdef\sepspaces{\def {\ }}}
X
X\newskip\aboveenvskipamount \aboveenvskipamount= 0pt
X\def\aboveenvbreak{{\advance\aboveenvskipamount by \parskip
X\endgraf \ifdim\lastskip<\aboveenvskipamount
X\removelastskip \penalty-50 \vskip\aboveenvskipamount \fi}}
X
X\def\afterenvbreak{\endgraf \ifdim\lastskip<\aboveenvskipamount
X\removelastskip \penalty-50 \vskip\aboveenvskipamount \fi}
X
X\def\lisp{\aboveenvbreak\begingroup\inENV %This group ends at the end of the @lisp body
X\hfuzz=12truept % Don't be fussy
X% Make spaces be word-separators rather than space tokens.
X\sepspaces %
X% Single space lines
X\singlespace %
X% The following causes blank lines not to be ignored
X% by adding a space to the end of each line.
X\let\par=\lisppar
X\def\Elisp{\endgroup\afterenvbreak}%
X\parskip=0pt
X\advance \leftskip by \lispnarrowing
X\parindent=0pt
X\let\exdent=\internalexdent
X\obeyspaces \obeylines \tt \rawbackslash
X\def\next##1{}\next}
X
X
X\let\example=\lisp
X\def\Eexample{\Elisp}
X
X\let\smallexample=\lisp
X\def\Esmallexample{\Elisp}
X
X% Macro for 9 pt. examples, necessary to print with 5" lines.
X% From Pavel@xerox.  This is not really used unless the
X% @smallbook command is given.
X
X\def\smalllispx{\aboveenvbreak\begingroup\inENV
X%			This group ends at the end of the @lisp body
X\hfuzz=12truept % Don't be fussy
X% Make spaces be word-separators rather than space tokens.
X\sepspaces %
X% Single space lines
X\singlespace %
X% The following causes blank lines not to be ignored
X% by adding a space to the end of each line.
X\let\par=\lisppar
X\def\Esmalllisp{\endgroup\afterenvbreak}%
X\parskip=0pt
X\advance \leftskip by \lispnarrowing
X\parindent=0pt
X\let\exdent=\internalexdent
X\obeyspaces \obeylines \ninett \rawbackslash
X\def\next##1{}\next}
X
X% This is @display; same as @lisp except use roman font.
X
X\def\display{\begingroup\inENV %This group ends at the end of the @display body
X\aboveenvbreak
X% Make spaces be word-separators rather than space tokens.
X\sepspaces %
X% Single space lines
X\singlespace %
X% The following causes blank lines not to be ignored
X% by adding a space to the end of each line.
X\let\par=\lisppar
X\def\Edisplay{\endgroup\afterenvbreak}%
X\parskip=0pt
X\advance \leftskip by \lispnarrowing
X\parindent=0pt
X\let\exdent=\internalexdent
X\obeyspaces \obeylines
X\def\next##1{}\next}
X
X% This is @format; same as @lisp except use roman font and don't narrow margins
X
X\def\format{\begingroup\inENV %This group ends at the end of the @format body
X\aboveenvbreak
X% Make spaces be word-separators rather than space tokens.
X\sepspaces %
X\singlespace %
X% The following causes blank lines not to be ignored
X% by adding a space to the end of each line.
X\let\par=\lisppar
X\def\Eformat{\endgroup\afterenvbreak}
X\parskip=0pt \parindent=0pt
X\obeyspaces \obeylines
X\def\next##1{}\next}
X
X% @flushleft and @flushright
X
X\def\flushleft{\begingroup\inENV %This group ends at the end of the @format body
X\aboveenvbreak
X% Make spaces be word-separators rather than space tokens.
X\sepspaces %
X% The following causes blank lines not to be ignored
X% by adding a space to the end of each line.
X% This also causes @ to work when the directive name
X% is terminated by end of line.
X\let\par=\lisppar
X\def\Eflushleft{\endgroup\afterenvbreak}%
X\parskip=0pt \parindent=0pt
X\obeyspaces \obeylines
X\def\next##1{}\next}
X
X\def\flushright{\begingroup\inENV %This group ends at the end of the @format body
X\aboveenvbreak
X% Make spaces be word-separators rather than space tokens.
X\sepspaces %
X% The following causes blank lines not to be ignored
X% by adding a space to the end of each line.
X% This also causes @ to work when the directive name
X% is terminated by end of line.
X\let\par=\lisppar
X\def\Eflushright{\endgroup\afterenvbreak}%
X\parskip=0pt \parindent=0pt
X\advance \leftskip by 0pt plus 1fill
X\obeyspaces \obeylines
X\def\next##1{}\next}
X
X% @quotation - narrow the margins.
X
X\def\quotation{\begingroup\inENV %This group ends at the end of the @quotation body
X{\parskip=0pt  % because we will skip by \parskip too, later
X\aboveenvbreak}%
X\singlespace
X\parindent=0pt
X\def\Equotation{\par\endgroup\afterenvbreak}%
X\advance \rightskip by \lispnarrowing 
X\advance \leftskip by \lispnarrowing}
X
X\message{defuns,}
X% Define formatter for defuns
X% First, allow user to change definition object font (\df) internally
X\def\setdeffont #1 {\csname DEF#1\endcsname}
X
X\newskip\defbodyindent \defbodyindent=.4in
X\newskip\defargsindent \defargsindent=50pt
X\newskip\deftypemargin \deftypemargin=12pt
X\newskip\deflastargmargin \deflastargmargin=18pt
X
X\newcount\parencount
X% define \functionparens, which makes ( and ) and & do special things.
X% \functionparens affects the group it is contained in.
X\def\activeparens{%
X\catcode`\(=\active \catcode`\)=\active \catcode`\&=\active
X\catcode`\[=\active \catcode`\]=\active}
X{\activeparens % Now, smart parens don't turn on until &foo (see \amprm)
X\gdef\functionparens{\boldbrax\let&=\amprm\parencount=0 }
X\gdef\boldbrax{\let(=\opnr\let)=\clnr\let[=\lbrb\let]=\rbrb}
X
X% Definitions of (, ) and & used in args for functions.
X% This is the definition of ( outside of all parentheses.
X\gdef\oprm#1 {{\rm\char`\(}#1 \bf \let(=\opnested %
X\global\advance\parencount by 1 }
X%
X% This is the definition of ( when already inside a level of parens.
X\gdef\opnested{\char`\(\global\advance\parencount by 1 }
X%
X\gdef\clrm{% Print a paren in roman if it is taking us back to depth of 0.
X% also in that case restore the outer-level definition of (.
X\ifnum \parencount=1 {\rm \char `\)}\sl \let(=\oprm \else \char `\) \fi
X\global\advance \parencount by -1 }
X% If we encounter &foo, then turn on ()-hacking afterwards
X\gdef\amprm#1 {{\rm\&#1}\let(=\oprm \let)=\clrm\ }
X%
X\gdef\normalparens{\boldbrax\let&=\ampnr}
X} % End of definition inside \activeparens
X%% These parens (in \boldbrax) actually are a little bolder than the
X%% contained text.  This is especially needed for [ and ]
X\def\opnr{{\sf\char`\(}} \def\clnr{{\sf\char`\)}} \def\ampnr{\&}
X\def\lbrb{{\tt\char`\[}} \def\rbrb{{\tt\char`\]}}
X
X% First, defname, which formats the header line itself.
X% #1 should be the function name.
X% #2 should be the type of definition, such as "Function".
X
X\def\defname #1#2{%
X\leftskip = 0in  %
X\noindent        %
X\setbox0=\hbox{\hskip \deflastargmargin{\rm #2}\hskip \deftypemargin}%
X\dimen0=\hsize \advance \dimen0 by -\wd0 % compute size for first line
X\dimen1=\hsize \advance \dimen1 by -\defargsindent %size for continuations
X\parshape 2 0in \dimen0 \defargsindent \dimen1     %
X% Now output arg 2 ("Function" or some such)
X% ending at \deftypemargin from the right margin,
X% but stuck inside a box of width 0 so it does not interfere with linebreaking
X\rlap{\rightline{{\rm #2}\hskip \deftypemargin}}%
X\tolerance=10000 \hbadness=10000    % Make all lines underfull and no complaints
X{\df #1}\enskip        % Generate function name
X}
X
X% Actually process the body of a definition
X% #1 should be the terminating control sequence, such as \Edefun.
X% #2 should be the "another name" control sequence, such as \defunx.
X% #3 should be the control sequence that actually processes the header,
X%    such as \defunheader.
X
X\def\defparsebody #1#2#3{\begingroup\inENV% Environment for definitionbody
X\medbreak %
X% Define the end token that this defining construct specifies
X% so that it will exit this group.
X\def#1{\endgraf\endgroup\medbreak}%
X\def#2{\begingroup\obeylines\activeparens\spacesplit#3}%
X\parindent=0in \leftskip=\defbodyindent \rightskip=\defbodyindent %
X\begingroup\obeylines\activeparens\spacesplit#3}
X
X\def\defmethparsebody #1#2#3#4 {\begingroup\inENV %
X\medbreak %
X% Define the end token that this defining construct specifies
X% so that it will exit this group.
X\def#1{\endgraf\endgroup\medbreak}%
X\def#2##1 {\begingroup\obeylines\activeparens\spacesplit{#3{##1}}}%
X\parindent=0in \leftskip=\defbodyindent \rightskip=\defbodyindent %
X\begingroup\obeylines\activeparens\spacesplit{#3{#4}}}
X
X\def\defopparsebody #1#2#3#4#5 {\begingroup\inENV %
X\medbreak %
X% Define the end token that this defining construct specifies
X% so that it will exit this group.
X\def#1{\endgraf\endgroup\medbreak}%
X\def#2##1 ##2 {\def#4{##1}%
X\begingroup\obeylines\activeparens\spacesplit{#3{##2}}}%
X\parindent=0in \leftskip=\defbodyindent %
X\begingroup\obeylines\activeparens\spacesplit{#3{#5}}}
X
X% Split up #2 at the first space token.
X% call #1 with two arguments:
X%  the first is all of #2 before the space token,
X%  the second is all of #2 after that space token.
X% If #2 contains no space token, all of it is passed as the first arg
X% and the second is passed as empty.
X
X{\obeylines
X\gdef\spacesplit#1#2^^M{\endgroup\spacesplitfoo{#1}#2 \relax\spacesplitfoo}%
X\long\gdef\spacesplitfoo#1#2 #3#4\spacesplitfoo{%
X\ifx\relax #3%
X#1{#2}{}\else #1{#2}{#3#4}\fi}}
X
X% So much for the things common to all kinds of definitions.
X
X% Define @defun.
X
X% First, define the processing that is wanted for arguments of \defun
X% Use this to expand the args and terminate the paragraph they make up
X
X\def\defunargs #1{\functionparens \sl
X% Expand, preventing hyphenation at `-' chars.
X% Note that groups don't affect changes in \hyphenchar.
X\hyphenchar\sl=0
X#1%
X\hyphenchar\sl=45
X\ifnum\parencount=0 \else \errmessage{unbalanced parens in @def arguments}\fi%
X\interlinepenalty=10000
X\endgraf\penalty10000\vskip -\parskip }
X
X% Do complete processing of one @defun or @defunx line already parsed.
X
X% @deffn Command forward-char nchars
X
X\def\deffn{\defmethparsebody\Edeffn\deffnx\deffnheader}
X
X\def\deffnheader #1#2#3{\doind {fn}{\code{#2}}%
X\begingroup\defname {#2}{#1}\defunargs{#3}\endgroup}
X
X% @defun == @deffn Function
X
X\def\defun{\defparsebody\Edefun\defunx\defunheader}
X
X\def\defunheader #1#2{\doind {fn}{\code{#1}}% Make entry in function index
X\begingroup\defname {#1}{Function}%
X\defunargs {#2}\endgroup %
X}
X
X% @defmac == @deffn Macro
X
X\def\defmac{\defparsebody\Edefmac\defmacx\defmacheader}
X
X\def\defmacheader #1#2{\doind {fn}{\code{#1}}% Make entry in function index
X\begingroup\defname {#1}{Macro}%
X\defunargs {#2}\endgroup %
X}
X
X% @defspec == @deffn Special Form
X
X\def\defspec{\defparsebody\Edefspec\defspecx\defspecheader}
X
X\def\defspecheader #1#2{\doind {fn}{\code{#1}}% Make entry in function index
X\begingroup\defname {#1}{Special form}%
X\defunargs {#2}\endgroup %
X}
X
X% This definition is run if you use @defunx
X% anywhere other than immediately after a @defun or @defunx.
X
X\def\deffnx #1 {\errmessage{@deffnx in invalid context}}
X\def\defunx #1 {\errmessage{@defunx in invalid context}}
X\def\defmacx #1 {\errmessage{@defmacx in invalid context}}
X\def\defspecx #1 {\errmessage{@defspecx in invalid context}}
X
X% @defmethod, and so on
X
X% @defop {Funny Method} foo-class frobnicate argument
X
X\def\defop #1 {\def\defoptype{#1}%
X\defopparsebody\Edefop\defopx\defopheader\defoptype}
X
X\def\defopheader #1#2#3{\dosubind {fn}{\code{#2}}{on #1}% Make entry in function index
X\begingroup\defname {#2}{\defoptype{} on #1}%
X\defunargs {#3}\endgroup %
X}
X
X% @defmethod == @defop Method
X
X\def\defmethod{\defmethparsebody\Edefmethod\defmethodx\defmethodheader}
X
X\def\defmethodheader #1#2#3{\dosubind {fn}{\code{#2}}{on #1}% entry in function index
X\begingroup\defname {#2}{Operation on #1}%
X\defunargs {#3}\endgroup %
X}
X
X% @defcv {Class Option} foo-class foo-flag
X
X\def\defcv #1 {\def\defcvtype{#1}%
X\defopparsebody\Edefcv\defcvx\defcvheader\defcvtype}
X
X\def\defcvarheader #1#2#3{%
X\dosubind {vr}{\code{#2}}{of #1}% Make entry in var index
X\begingroup\defname {#2}{\defcvtype of #1}%
X\defvarargs {#3}\endgroup %
X}
X
X% @defivar == @defcv {Instance Variable}
X
X\def\defivar{\defmethparsebody\Edefivar\defivarx\defivarheader}
X
X\def\defivarheader #1#2#3{%
X\dosubind {vr}{\code{#2}}{of #1}% Make entry in var index
X\begingroup\defname {#2}{Instance variable of #1}%
X\defvarargs {#3}\endgroup %
X}
X
X% These definitions are run if you use @defmethodx, etc.,
X% anywhere other than immediately after a @defmethod, etc.
X
X\def\defopx #1 {\errmessage{@defopx in invalid context}}
X\def\defmethodx #1 {\errmessage{@defmethodx in invalid context}}
X\def\defcvx #1 {\errmessage{@defcvx in invalid context}}
X\def\defivarx #1 {\errmessage{@defivarx in invalid context}}
X
X% Now @defvar
X
X% First, define the processing that is wanted for arguments of @defvar.
X% This is actually simple: just print them in roman.
X% This must expand the args and terminate the paragraph they make up
X\def\defvarargs #1{\normalparens #1%
X\interlinepenalty=10000
X\endgraf\penalty 10000\vskip -\parskip}
X
X% @defvr Counter foo-count
X
X\def\defvr{\defmethparsebody\Edefvr\defvrx\defvrheader}
X
X\def\defvrheader #1#2#3{\doind {vr}{\code{#2}}%
X\begingroup\defname {#2}{#1}\defvarargs{#3}\endgroup}
X
X% @defvar == @defvr Variable
X
X\def\defvar{\defparsebody\Edefvar\defvarx\defvarheader}
X
X\def\defvarheader #1#2{\doind {vr}{\code{#1}}% Make entry in var index
X\begingroup\defname {#1}{Variable}%
X\defvarargs {#2}\endgroup %
X}
X
X% @defopt == @defvr {User Option}
X
X\def\defopt{\defparsebody\Edefopt\defoptx\defoptheader}
X
X\def\defoptheader #1#2{\doind {vr}{\code{#1}}% Make entry in var index
X\begingroup\defname {#1}{User Option}%
X\defvarargs {#2}\endgroup %
X}
X
X% This definition is run if you use @defvarx
X% anywhere other than immediately after a @defvar or @defvarx.
X
X\def\defvrx #1 {\errmessage{@defvrx in invalid context}}
X\def\defvarx #1 {\errmessage{@defvarx in invalid context}}
X\def\defoptx #1 {\errmessage{@defoptx in invalid context}}
X
X% Now define @deftp
X% Args are printed in bold, a slight difference from @defvar.
X
X\def\deftpargs #1{\bf \defvarargs{#1}}
X
X% @deftp Class window height width ...
X
X\def\deftp{\defmethparsebody\Edeftp\deftpx\deftpheader}
X
X\def\deftpheader #1#2#3{\doind {tp}{\code{#2}}%
X\begingroup\defname {#2}{#1}\deftpargs{#3}\endgroup}
X
X% This definition is run if you use @deftpx, etc
X% anywhere other than immediately after a @deftp, etc.
X
X\def\deftpx #1 {\errmessage{@deftpx in invalid context}}
X
X\message{cross reference,}
X% Define cross-reference macros
X\newwrite \auxfile
X
X% \setref{foo} defines a cross-reference point named foo.
X
X\def\setref#1{%
X\dosetq{#1-pg}{Ypagenumber}%
X\dosetq{#1-snt}{Ysectionnumberandtype}}
X
X\def\unnumbsetref#1{%
X\dosetq{#1-pg}{Ypagenumber}%
X\dosetq{#1-snt}{Ynothing}}
X
X\def\appendixsetref#1{%
X\dosetq{#1-pg}{Ypagenumber}%
X\dosetq{#1-snt}{Yappendixletterandtype}}
X
X% \xref and \pxref generate cross references to specified points.
X
X\def\pxref #1{see \xrefX [#1,,,,,,,]}
X\def\xref #1{See \xrefX [#1,,,,,,,]}
X\def\ref #1{\xrefX [#1,,,,,,,]}
X\def\xrefX [#1,#2,#3,#4,#5,#6]{%
X\setbox1=\hbox{\i{\losespace#5{}}}%
X\setbox0=\hbox{\losespace#3{}}%
X\ifdim \wd0 =0pt \setbox0=\hbox{\losespace#1{}}\fi%
X\ifdim \wd1 >0pt%
Xsection `\unhbox0' in \unhbox1%
X\else%
X\refx{#1-snt}{} [\unhbox0], page\tie \refx{#1-pg}{}%
X\fi }
X
X% \dosetq is the interface for calls from other macros
X
X\def\dosetq #1#2{{\let\folio=0%
X\edef\next{\write\auxfile{\internalsetq {#1}{#2}}}%
X\next}}
X
X% \internalsetq {foo}{page} expands into CHARACTERS 'xrdef {foo}{...expansion of \Ypage...}
X% When the aux file is read, ' is the escape character
X
X\def\internalsetq #1#2{'xrdef {#1}{\csname #2\endcsname}}
X
X% Things to be expanded by \internalsetq
X
X\def\Ypagenumber{\folio}
X
X\def\Ynothing{}
X
X\def\Ysectionnumberandtype{%
X\ifnum\secno=0 chapter\xreftie\the\chapno %
X\else \ifnum \subsecno=0 section\xreftie\the\chapno.\the\secno %
X\else \ifnum \subsubsecno=0 %
Xsection\xreftie\the\chapno.\the\secno.\the\subsecno %
X\else %
Xsection\xreftie\the\chapno.\the\secno.\the\subsecno.\the\subsubsecno %
X\fi \fi \fi }
X
X\def\Yappendixletterandtype{%
X\ifnum\secno=0 appendix\xreftie'char\the\appendixno %
X\else \ifnum \subsecno=0 section\xreftie'char\the\appendixno.\the\secno %
X\else \ifnum \subsubsecno=0 %
Xsection\xreftie'char\the\appendixno.\the\secno.\the\subsecno %
X\else %
Xsection\xreftie'char\the\appendixno.\the\secno.\the\subsecno.\the\subsubsecno %
X\fi \fi \fi }
X
X\gdef\xreftie{'tie}
X
X% Define \refx{NAME}{SUFFIX} to reference a cross-reference string named NAME.
X% If its value is nonempty, SUFFIX is output afterward.
X
X\def\refx#1#2{%
X{%
X\expandafter\ifx\csname X#1\endcsname\relax
X% If not defined, say something at least.
X\expandafter\gdef\csname X#1\endcsname {$\langle$un\-def\-in\-ed$\rangle$}#2%
X\message {WARNING: Cross-reference "#1" used but not yet defined}%
X\message {}%
X\fi %
X\setbox0=\hbox{\csname X#1\endcsname}%It's defined, so just use it.
X\ifdim\wd0>0pt \unhbox0{}#2\fi
X}}
X
X% Read the last existing aux file, if any.  No error if none exists.
X
X% This is the macro invoked by entries in the aux file.
X\def\xrdef #1#2{
X{\catcode`\'=\other\expandafter \gdef \csname X#1\endcsname {#2}}}
X
X\def\readauxfile{%
X\begingroup
X\catcode `\^^@=\other
X\catcode `\=\other
X\catcode `\=\other
X\catcode `\^^C=\other
X\catcode `\^^D=\other
X\catcode `\^^E=\other
X\catcode `\^^F=\other
X\catcode `\^^G=\other
X\catcode `\^^H=\other
X\catcode `\=\other
X\catcode `\^^L=\other
X\catcode `\=\other
X\catcode `\=\other
X\catcode `\=\other
X\catcode `\=\other
X\catcode `\=\other
X\catcode `\=\other
X\catcode `\=\other
X\catcode `\=\other
X\catcode `\=\other
X\catcode `\=\other
X\catcode `\=\other
X\catcode `\=\other
X\catcode `\=\other
X\catcode `\^^[=\other
X\catcode `\^^\=\other
X\catcode `\^^]=\other
X\catcode `\^^^=\other
X\catcode `\^^_=\other
X\catcode `\@=\other
X\catcode `\^=\other
X\catcode `\~=\other
X\catcode `\[=\other
X\catcode `\]=\other
X\catcode`\"=\other
X\catcode`\_=\other
X\catcode`\|=\other
X\catcode`\<=\other
X\catcode`\>=\other
X\catcode `\$=\other
X\catcode `\#=\other
X\catcode `\&=\other
X% the aux file uses ' as the escape.
X% Turn off \ as an escape so we do not lose on
X% entries which were dumped with control sequences in their names.
X% For example, 'xrdef {$\leq $-fun}{page ...} made by @defun ^^
X% Reference to such entries still does not work the way one would wish,
X% but at least they do not bomb out when the aux file is read in.
X\catcode `\{=1 \catcode `\}=2
X\catcode `\%=\other
X\catcode `\'=0
X\catcode `\\=\other
X\openin 1 \jobname.aux
X\ifeof 1 \else \closein 1 \input \jobname.aux
X\fi
X% Open the new aux file.  Tex will close it automatically at exit.
X\openout \auxfile=\jobname.aux
X\endgroup}
X
X
X% Footnotes.
X
X\newcount \footnoteno
X
X\def\supereject{\par\penalty -20000\footnoteno =0 }
X
X\let\ptexfootnote=\footnote
X
X{\catcode `\@=11
X\gdef\footnote{\global\advance \footnoteno by \@ne
X\edef\thisfootno{$^{\the\footnoteno}$}%
X\let\@sf\empty
X\ifhmode\edef\@sf{\spacefactor\the\spacefactor}\/\fi
X\thisfootno\@sf\parsearg\footnotezzz}
X
X\gdef\footnotezzz #1{\insert\footins{
X\interlinepenalty\interfootnotelinepenalty
X\splittopskip\ht\strutbox % top baseline for broken footnotes
X\splitmaxdepth\dp\strutbox \floatingpenalty\@MM
X\leftskip\z@skip \rightskip\z@skip \spaceskip\z@skip \xspaceskip\z@skip
X\footstrut\hang\textindent{\thisfootno}#1\strut}}
X
X}%end \catcode `\@=11
X
X% End of control word definitions.
X
X\message{and turning on texinfo input format.}
X
X\def\openindices{%
X   \newindex{cp}%
X   \newcodeindex{fn}%
X   \newcodeindex{vr}%
X   \newcodeindex{tp}%
X   \newcodeindex{ky}%
X   \newcodeindex{pg}%
X}
X
X% Set some numeric style parameters, for 8.5 x 11 format.
X
X\hsize = 6.5in
X\parindent 15pt
X\parskip 18pt plus 1pt
X\baselineskip 15pt
X\advance\topskip by 1.2cm
X
X% Prevent underfull vbox error messages.
X\vbadness=10000
X
X% Use @smallbook to reset parameters for 7x9.5 format
X\def\smallbook{
X\global\lispnarrowing = 0.3in
X\global\baselineskip 12pt
X\global\parskip 3pt plus 1pt
X\global\hsize = 5in
X\global\doublecolumnhsize=2.4in \global\doublecolumnvsize=15.0in
X\global\vsize=7.5in
X\global\tolerance=700
X\global\hfuzz=1pt
X
X\global\pagewidth=\hsize
X\global\pageheight=\vsize
X\global\font\ninett=cmtt9
X
X\global\let\smalllisp=\smalllispx
X\global\let\smallexample=\smalllispx
X\global\def\Esmallexample{\Esmalllisp}
X}
X
X%% For a final copy, take out the rectangles
X%% that mark overfull boxes (in case you have decided
X%% that the text looks ok even though it passes the margin).
X\def\finalout{\overfullrule=0pt}
X
X% Turn off all special characters except @
X% (and those which the user can use as if they were ordinary)
X% Define certain chars to be always in tt font.
X
X\catcode`\"=\active
X\def\activedoublequote{{\tt \char '042}}
X\let"=\activedoublequote
X\catcode`\~=\active
X\def~{{\tt \char '176}}
X\chardef\hat=`\^
X\catcode`\^=\active
X\def^{{\tt \hat}}
X\catcode`\_=\active
X\def_{{\tt \char '137}}
X\catcode`\|=\active
X\def|{{\tt \char '174}}
X\chardef \less=`\<
X\catcode`\<=\active
X\def<{{\tt \less}}
X\chardef \gtr=`\>
X\catcode`\>=\active
X\def>{{\tt \gtr}}
X\catcode`\+=\active
X\def+{{\tt \char 43}}
X%\catcode 27=\active
X%\def^^[{$\diamondsuit$}
X
X\catcode`\@=0
X
X% \rawbackslashxx output one backslash character in current font
X{\catcode`\\=\other
X@gdef@rawbackslashxx{\}}
X
X% \rawbackslash redefines \ as input to do \rawbackslashxx.
X{\catcode`\\=\active
X@gdef@rawbackslash{@let\=@rawbackslashxx }}
X
X% \normalbackslash outputs one backslash in fixed width font.
X\def\normalbackslash{{\tt\rawbackslashxx}}
X
X% Say @foo, not \foo, in error messages.
X\escapechar=`\@
X
X@c \catcode 17=0   @c Define control-q
X\catcode`\\=\active
X
X% If a .fmt file is being used, we don't want the `\input texinfo' to show up.
X% That is what \eatinput is for; after that, the `\' should revert to printing 
X% a backslash.
X%
X@gdef@eatinput input texinfo{@fixbackslash}
X@global@let\ = @eatinput
X
X% On the other hand, perhaps the file did not have a `\input texinfo'. Then
X% the first `\{ in the file would cause an error. This macro tries to fix 
X% that, assuming it is called before the first `\' could plausibly occur.
X% 
X@gdef@fixbackslash{@ifx\@eatinput @let\ = @normalbackslash @fi}
X
X%% These look ok in all fonts, so just make them not special.  The @rm below
X%% makes sure that the current font starts out as the newly loaded cmr10
X@catcode`@$=@other @catcode`@%=@other @catcode`@&=@other @catcode`@#=@other
X
X@textfonts
X@rm
END_OF_FILE
  echo shar: 15 control characters may be missing from \"'./support/texinfo.tex.02'\"
  if test 25529 -ne `wc -c <'./support/texinfo.tex.02'`; then
    echo shar: \"'./support/texinfo.tex.02'\" unpacked with wrong size!
  fi
  # end of './support/texinfo.tex.02'
fi
echo shar: End of archive 13 \(of 16\).
cp /dev/null ark13isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 16 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
-- 
Please send comp.sources.unix-related mail to rsalz@uunet.uu.net.
Use a domain-based address or give alternate paths, or you may lose out.
