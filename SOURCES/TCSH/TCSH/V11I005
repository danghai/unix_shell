Path: uunet!rs
From: rs@uunet.UU.NET (Rich Salz)
Newsgroups: comp.sources.unix
Subject: v11i005:  New version of T-shell, Part05/06
Message-ID: <863@uunet.UU.NET>
Date: 11 Aug 87 23:53:04 GMT
Organization: UUNET Communications Services, Arlington, VA
Lines: 2319
Approved: rs@uunet.UU.NET

Submitted-by: Paul Placeway <osu-eddie!paul>
Posting-number: Volume 11, Issue 5
Archive-name: tcsh/Part05

# This is a shell archive.  Remove anything before this line
# then unpack it by saving it in a file and typing "sh file"
# (Files unpacked will be owned by you and have default permissions).
# This archive contains the following files:
#	./DIFFS.2
#
if `test ! -s ./DIFFS.2`
then
echo "writing ./DIFFS.2"
sed 's/^x//' > ./DIFFS.2 << '\Rogue\Monster\'
x*** ../csh4.2/sh.glob.c	Tue Jun 23 12:13:49 1987
x--- sh.glob.c	Sat Jul  4 12:10:23 1987
x***************
x*** 1,7
x  static	char *sccsid = "@(#)sh.glob.c 4.5 7/3/83";
x  
x  #include "sh.h"
x! #include <sys/dir.h>
x  
x  /*
x   * C Shell
x
x--- 1,7 -----
x  static	char *sccsid = "@(#)sh.glob.c 4.5 7/3/83";
x  
x  #include "sh.h"
x! /* #include <sys/dir.h> */
x  
x  /*
x   * C Shell
x***************
x*** 101,107
x  		sort();
x  }
x  
x! sort()
x  {
x  	register char **p1, **p2, *c;
x  	char **Gvp = &gargv[gargc];
x
x--- 101,109 -----
x  		sort();
x  }
x  
x! static
x! sortcmp(a, b)
x! register char **a, **b;
x  {
x      if (!a)			/* check for NULL */
x  	return (b?1:0);
x***************
x*** 103,108
x  
x  sort()
x  {
x  	register char **p1, **p2, *c;
x  	char **Gvp = &gargv[gargc];
x  
x
x--- 105,125 -----
x  sortcmp(a, b)
x  register char **a, **b;
x  {
x+     if (!a)			/* check for NULL */
x+ 	return (b?1:0);
x+     if (!b)
x+ 	return (-1);
x+ 
x+     if (!*a)			/* check for NULL */
x+ 	return (*b?1:0);
x+     if (!*b)
x+ 	return (-1);
x+ 
x+     return (strcmp(*a, *b));
x+ }
x+ 
x+ #ifdef COMMENT
x+ This was in the sort() routine below.
x  	register char **p1, **p2, *c;
x  
x  
x***************
x*** 104,110
x  sort()
x  {
x  	register char **p1, **p2, *c;
x- 	char **Gvp = &gargv[gargc];
x  
x  	p1 = sortbas;
x  	while (p1 < Gvp-1) {
x
x--- 121,126 -----
x  #ifdef COMMENT
x  This was in the sort() routine below.
x  	register char **p1, **p2, *c;
x  
x  
x  	p1 = sortbas;
x***************
x*** 106,111
x  	register char **p1, **p2, *c;
x  	char **Gvp = &gargv[gargc];
x  
x  	p1 = sortbas;
x  	while (p1 < Gvp-1) {
x  		p2 = p1;
x
x--- 122,128 -----
x  This was in the sort() routine below.
x  	register char **p1, **p2, *c;
x  
x+ 
x  	p1 = sortbas;
x  	while (p1 < Gvp-1) {	/* a BUBBLE SORT! how gross!! -- PWP */
x  		p2 = p1;
x***************
x*** 107,113
x  	char **Gvp = &gargv[gargc];
x  
x  	p1 = sortbas;
x! 	while (p1 < Gvp-1) {
x  		p2 = p1;
x  		while (++p2 < Gvp)
x  			if (strcmp(*p1, *p2) > 0)
x
x--- 124,130 -----
x  
x  
x  	p1 = sortbas;
x! 	while (p1 < Gvp-1) {	/* a BUBBLE SORT! how gross!! -- PWP */
x  		p2 = p1;
x  		while (++p2 < Gvp)
x  			if (strcmp(*p1, *p2) > 0)
x***************
x*** 114,119
x  				c = *p1, *p1 = *p2, *p2 = c;
x  		p1++;
x  	}
x  	sortbas = Gvp;
x  }
x  
x
x--- 131,145 -----
x  				c = *p1, *p1 = *p2, *p2 = c;
x  		p1++;
x  	}
x+ #endif
x+ 
x+ sort()				/* changed to use a qsort() 7/05/87 PWP */
x+ {
x+ 	char **Gvp = &gargv[gargc];
x+ 
x+ 	if (Gvp-sortbas > 1)
x+ 	    qsort (sortbas, Gvp-sortbas, sizeof (char *), sortcmp);
x+ 
x  	sortbas = Gvp;
x  }
x  
x***************
x*** 126,131
x  
x  	sgpathp = gpathp;
x  	cs = as;
x  	if (*cs == '~' && gpathp == gpath) {
x  		addpath('~');
x  		for (cs++; letter(*cs) || digit(*cs) || *cs == '-';)
x
x--- 152,176 -----
x  
x  	sgpathp = gpathp;
x  	cs = as;
x+ 	/*
x+ 	 * kfk - 17 Jan 1984 - stack hack
x+ 	 * allows user to get at arbitrary dir names in stack.
x+ 	 */
x+ 	if (*cs == '=' && gpathp == gpath) {
x+ 		addpath ('=');
x+ 		if (digit (*++cs) || *cs == '-') {
x+ 			int dig;
x+ 			dig = (*cs == '-') ? -1 : *cs - '0';
x+ 			cs++;
x+ 			if (*cs && *cs != '/')
x+ 				error ("Stack hack: =<dig>{/path...}");
x+ 			getstakd (gpath, dig, 1);
x+ 				/* last "1" = call error if needed */
x+ 			gpathp = strend (gpath);
x+ 		}
x+ 	}
x+ 	/* kfk - end stack hack change */
x+ 
x  	if (*cs == '~' && gpathp == gpath) {
x  		addpath('~');
x  		for (cs++; letter(*cs) || digit(*cs) || *cs == '-';)
x***************
x*** 291,297
x  	register char *sentp;
x  	char sglobbed = globbed;
x  
x! 	if (*s == '.' && *p != '.')
x  		return (0);
x  	sentp = entp;
x  	entp = s;
x
x--- 336,342 -----
x  	register char *sentp;
x  	char sglobbed = globbed;
x  
x! 	if (*s == '.' && *p != '.') /* PWP: this makes [.]login != .login */
x  		return (0);
x  	sentp = entp;
x  	entp = s;
x***************
x*** 305,311
x  	register char *s, *p;
x  {
x  	register int scc;
x! 	int ok, lc;
x  	char *sgpathp;
x  	struct stat stb;
x  	int c, cc;
x
x--- 350,356 -----
x  	register char *s, *p;
x  {
x  	register int scc;
x! 	int ok, lc, notin;
x  	char *sgpathp;
x  	struct stat stb;
x  	int c, cc;
x***************
x*** 318,324
x  		case '{':
x  			return (execbrc(p - 1, s - 1));
x  
x! 		case '[':
x  			ok = 0;
x  			lc = 077777;
x  			while (cc = *p++) {
x
x--- 363,370 -----
x  		case '{':
x  			return (execbrc(p - 1, s - 1));
x  
x! 		case '[':	/* PWP -- BRACKET IS HERE!! */
x! 			if (!scc) return 0; /* if at end if string */
x  			ok = 0;
x  			lc = 077777;
x  			if (*p == '^') {
x***************
x*** 321,326
x  		case '[':
x  			ok = 0;
x  			lc = 077777;
x  			while (cc = *p++) {
x  				if (cc == ']') {
x  					if (ok)
x
x--- 367,377 -----
x  			if (!scc) return 0; /* if at end if string */
x  			ok = 0;
x  			lc = 077777;
x+ 			if (*p == '^') {
x+ 			    notin = 1;
x+ 			    p++;
x+ 			} else
x+ 			    notin = 0;
x  			while (cc = *p++) {
x  				if (cc == ']') {
x  					if (notin) { /* PWP for not in list */
x***************
x*** 323,328
x  			lc = 077777;
x  			while (cc = *p++) {
x  				if (cc == ']') {
x  					if (ok)
x  						break;
x  					return (0);
x
x--- 374,385 -----
x  			    notin = 0;
x  			while (cc = *p++) {
x  				if (cc == ']') {
x+ 					if (notin) { /* PWP for not in list */
x+ 					    if (!ok)
x+ 						break;
x+ 					    else
x+ 						return (0);
x+ 					} else {
x  					    if (ok)
x  						break;
x  					    else
x***************
x*** 325,330
x  				if (cc == ']') {
x  					if (ok)
x  						break;
x  					return (0);
x  				}
x  				if (cc == '-') {
x
x--- 382,388 -----
x  					} else {
x  					    if (ok)
x  						break;
x+ 					    else
x  						return (0);
x  					}
x  				}
x***************
x*** 327,332
x  						break;
x  					return (0);
x  				}
x  				if (cc == '-') {
x  					if (lc <= scc && scc <= *p++)
x  						ok++;
x
x--- 385,391 -----
x  					    else
x  						return (0);
x  					}
x+ 				}
x  				if (cc == '-') {
x  					if (lc <= scc && scc <= *p++)
x  						ok++;
x***************
x*** 331,337
x  					if (lc <= scc && scc <= *p++)
x  						ok++;
x  				} else
x! 					if (scc == (lc = cc))
x  						ok++;
x  			}
x  			if (cc == 0)
x
x--- 390,396 -----
x  					if (lc <= scc && scc <= *p++)
x  						ok++;
x  				} else
x! 					if (scc && (scc == (lc = cc)))
x  						ok++;
x  			}
x  			if (cc == 0)
x***************
x*** 389,395
x  	register char *s, *p;
x  {
x  	register int scc;
x! 	int ok, lc;
x  	int c, cc;
x  
x  	for (;;) {
x
x--- 448,454 -----
x  	register char *s, *p;
x  {
x  	register int scc;
x! 	int ok, lc, notin;
x  	int c, cc;
x  
x  	for (;;) {
x***************
x*** 396,402
x  		scc = *s++ & TRIM;
x  		switch (c = *p++) {
x  
x! 		case '[':
x  			ok = 0;
x  			lc = 077777;
x  			while (cc = *p++) {
x
x--- 455,462 -----
x  		scc = *s++ & TRIM;
x  		switch (c = *p++) {
x  
x! 		case '[':	/* PWP -- HERE TOO!! */
x! 			if (!scc) return 0; /* if at end if string */
x  			ok = 0;
x  			lc = 077777;
x  			if (*p == '^') {
x***************
x*** 399,404
x  		case '[':
x  			ok = 0;
x  			lc = 077777;
x  			while (cc = *p++) {
x  				if (cc == ']') {
x  					if (ok)
x
x--- 459,469 -----
x  			if (!scc) return 0; /* if at end if string */
x  			ok = 0;
x  			lc = 077777;
x+ 			if (*p == '^') {
x+ 			    notin = 1;
x+ 			    p++;
x+ 			} else
x+ 			    notin = 0;
x  			while (cc = *p++) {
x  				if (cc == ']') {
x  					if (notin) { /* PWP for not in list */
x***************
x*** 401,406
x  			lc = 077777;
x  			while (cc = *p++) {
x  				if (cc == ']') {
x  					if (ok)
x  						break;
x  					return (0);
x
x--- 466,477 -----
x  			    notin = 0;
x  			while (cc = *p++) {
x  				if (cc == ']') {
x+ 					if (notin) { /* PWP for not in list */
x+ 					    if (!ok)
x+ 						break;
x+ 					    else
x+ 						return (0);
x+ 					} else {
x  					    if (ok)
x  						break;
x  					    else
x***************
x*** 403,408
x  				if (cc == ']') {
x  					if (ok)
x  						break;
x  					return (0);
x  				}
x  				if (cc == '-') {
x
x--- 474,480 -----
x  					} else {
x  					    if (ok)
x  						break;
x+ 					    else
x  						return (0);
x  					}
x  				}
x***************
x*** 405,410
x  						break;
x  					return (0);
x  				}
x  				if (cc == '-') {
x  					if (lc <= scc && scc <= *p++)
x  						ok++;
x
x--- 477,483 -----
x  					    else
x  						return (0);
x  					}
x+ 				}
x  				if (cc == '-') {
x  					if (lc <= scc && scc <= *p++)
x  						ok++;
x***************
x*** 409,415
x  					if (lc <= scc && scc <= *p++)
x  						ok++;
x  				} else
x! 					if (scc == (lc = cc))
x  						ok++;
x  			}
x  			if (cc == 0)
x
x--- 482,488 -----
x  					if (lc <= scc && scc <= *p++)
x  						ok++;
x  				} else
x! 					if (scc && (scc == (lc = cc)))
x  						ok++;
x  			}
x  			if (cc == 0)
x***************
x*** 470,476
x  
x  	while (p = *t++) {
x  		if (f == tglob)
x! 			if (*p == '~')
x  				gflag |= 2;
x  			else if (eq(p, "{") || eq(p, "{}"))
x  				continue;
x
x--- 543,550 -----
x  
x  	while (p = *t++) {
x  		if (f == tglob)
x! 			/* added additional '=' test for stack hack */
x! 			if ((*p == '~') || (*p == '='))
x  				gflag |= 2;
x  			else if (eq(p, "{") || eq(p, "{}"))
x  				continue;
x*** ../csh4.2/sh.h	Tue Jun 23 12:13:51 1987
x--- sh.h	Thu Jul 16 14:02:22 1987
x***************
x*** 13,18
x   * Jim Kulp, IIASA, Laxenburg Austria
x   * April, 1980
x   */
x  #include <sys/param.h>
x  #include <sys/stat.h>
x  
x
x--- 13,21 -----
x   * Jim Kulp, IIASA, Laxenburg Austria
x   * April, 1980
x   */
x+ #ifdef SVID
x+ #include <sys/types.h>
x+ #endif
x  #include <sys/param.h>
x  #include <sys/stat.h>
x  
x***************
x*** 22,27
x  #include <setjmp.h>
x  #include <signal.h>
x  #include <sys/times.h>
x  
x  typedef	char	bool;
x  
x
x--- 25,31 -----
x  #include <setjmp.h>
x  #include <signal.h>
x  #include <sys/times.h>
x+ #include <sys/ioctl.h>
x  
x  #ifndef SVID
x  #include <sgtty.h>
x***************
x*** 23,28
x  #include <signal.h>
x  #include <sys/times.h>
x  
x  typedef	char	bool;
x  
x  #define	eq(a, b)	(strcmp(a, b) == 0)
x
x--- 27,71 -----
x  #include <sys/times.h>
x  #include <sys/ioctl.h>
x  
x+ #ifndef SVID
x+ #include <sgtty.h>
x+ #include <sys/dir.h>
x+ #else SVID
x+ # ifdef OREO
x+ #include <sgtty.h>
x+ #include <sys/dir.h>
x+ # else OREO
x+ #include "dir.h"
x+ # endif OREO
x+ #endif SVID
x+ 
x+ #include <ctype.h>
x+ #include <pwd.h>
x+ 
x+ #ifdef SVID
x+ # ifndef pyr
x+ #include <time.h>
x+ # endif pyr
x+ #include <termio.h>
x+ #endif
x+ 
x+ /*
x+  * kfk 26 Jan 1984 - for login watch functions.
x+  */
x+ #include <utmp.h>
x+ struct who {
x+ 	struct who *w_next;
x+ 	struct who *w_prev;
x+ 	char w_name[10];
x+ 	char w_new[10];
x+ 	char w_tty[10];
x+ 	int w_status;
x+ };
x+ #define ONLINE		01
x+ #define OFFLINE		02
x+ #define CHANGED		04
x+ #define ANNOUNCE	010
x+ /* kfk - end change */
x  typedef	char	bool;
x  
x  /* kfk - additions to support scheduled commands */
x***************
x*** 25,30
x  
x  typedef	char	bool;
x  
x  #define	eq(a, b)	(strcmp(a, b) == 0)
x  
x  /*
x
x--- 68,82 -----
x  /* kfk - end change */
x  typedef	char	bool;
x  
x+ /* kfk - additions to support scheduled commands */
x+ struct sched_event {
x+ 	struct	sched_event	*t_next;
x+ 	long			t_when;
x+ 	char			**t_lex;
x+ };
x+ extern	long	time();
x+ /* kfk - end change */
x+ 
x  #define	eq(a, b)	(strcmp(a, b) == 0)
x  
x  /*
x***************
x*** 65,70
x  int	errno;			/* Error from C library routines */
x  char	*shtemp;		/* Temp name for << shell files in /tmp */
x  struct	timeval time0;		/* Time at which the shell started */
x  struct	rusage ru0;
x  
x  /*
x
x--- 117,123 -----
x  int	errno;			/* Error from C library routines */
x  char	*shtemp;		/* Temp name for << shell files in /tmp */
x  struct	timeval time0;		/* Time at which the shell started */
x+ #ifndef OREO
x  struct	rusage ru0;
x  #endif OREO
x  
x***************
x*** 66,71
x  char	*shtemp;		/* Temp name for << shell files in /tmp */
x  struct	timeval time0;		/* Time at which the shell started */
x  struct	rusage ru0;
x  
x  /*
x   * Miscellany
x
x--- 119,125 -----
x  struct	timeval time0;		/* Time at which the shell started */
x  #ifndef OREO
x  struct	rusage ru0;
x+ #endif OREO
x  
x  /*
x   * Miscellany
x***************
x*** 79,84
x  int	opgrp;			/* Initial pgrp and tty pgrp */
x  int	oldisc;			/* Initial line discipline or -1 */
x  struct	tms shtimes;		/* shell and child times for process timing */
x  
x  /*
x   * These are declared here because they want to be
x
x--- 133,141 -----
x  int	opgrp;			/* Initial pgrp and tty pgrp */
x  int	oldisc;			/* Initial line discipline or -1 */
x  struct	tms shtimes;		/* shell and child times for process timing */
x+ char PromptBuf[256];		/* buffer for the actual printed prompt.
x+ 				   this is used in tenex.c and sh.c for
x+ 				   pegets.c */
x  
x  /*
x   * These are declared here because they want to be
x***************
x*** 358,363
x  	struct	wordent Hlex;
x  	int	Hnum;
x  	int	Href;
x  	struct	Hist *Hnext;
x  } Histlist;
x  
x
x--- 415,421 -----
x  	struct	wordent Hlex;
x  	int	Hnum;
x  	int	Href;
x+ 	long	Htime;
x  	struct	Hist *Hnext;
x  } Histlist;
x  
x***************
x*** 398,403
x  char	*globone();
x  struct	biltins *isbfunc();
x  char	**glob();
x  char	*operate();
x  int	phup();
x  int	pintr();
x
x--- 456,462 -----
x  char	*globone();
x  struct	biltins *isbfunc();
x  char	**glob();
x+ struct	tm *localtime();
x  char	*operate();
x  int	phup();
x  int	pintr();
x*** ../csh4.2/sh.hist.c	Tue Jun 23 12:13:51 1987
x--- sh.hist.c	Fri Jul 17 13:59:16 1987
x***************
x*** 44,49
x  	register struct Hist *np;
x  
x  	np = (struct Hist *) calloc(1, sizeof *np);
x  	np->Hnum = np->Href = event;
x  	if (docopy)
x  		copylex(&np->Hlex, lp);
x
x--- 44,50 -----
x  	register struct Hist *np;
x  
x  	np = (struct Hist *) calloc(1, sizeof *np);
x+ 	time(&(np->Htime));
x  	np->Hnum = np->Href = event;
x  	if (docopy)
x  		copylex(&np->Hlex, lp);
x***************
x*** 119,124
x  	register struct Hist *hp;
x  	int hflg;
x  {
x  
x  	if (hflg == 0)
x  		printf("%6d\t", hp->Hnum);
x
x--- 120,127 -----
x  	register struct Hist *hp;
x  	int hflg;
x  {
x+ 	struct tm *t;
x+ 	char ampm = 'a';
x  
x  	if (hflg == 0)
x  	{
x***************
x*** 121,126
x  {
x  
x  	if (hflg == 0)
x  		printf("%6d\t", hp->Hnum);
x  	prlex(&hp->Hlex);
x  }
x
x--- 124,130 -----
x  	char ampm = 'a';
x  
x  	if (hflg == 0)
x+ 	{
x  		printf("%6d\t", hp->Hnum);
x  		t = localtime(&hp->Htime);
x  		if (t->tm_hour >= 12)
x***************
x*** 122,126
x  
x  	if (hflg == 0)
x  		printf("%6d\t", hp->Hnum);
x  	prlex(&hp->Hlex);
x  }
x
x--- 126,141 -----
x  	if (hflg == 0)
x  	{
x  		printf("%6d\t", hp->Hnum);
x+ 		t = localtime(&hp->Htime);
x+ 		if (t->tm_hour >= 12)
x+ 		{
x+ 			if (t->tm_hour > 12)
x+ 				t->tm_hour -= 12;
x+ 			ampm = 'p';
x+ 		}
x+ 		else if (t->tm_hour == 0)
x+ 			t->tm_hour = 12;
x+ 		printf ("%2d:%02d%cm\t", t->tm_hour, t->tm_min, ampm);
x+ 	}
x  	prlex(&hp->Hlex);
x  }
x*** ../csh4.2/sh.init.c	Tue Jun 23 12:13:53 1987
x--- sh.init.c	Tue Jun 30 15:50:52 1987
x***************
x*** 8,13
x  
x  extern	int doalias();
x  extern	int dobg();
x  extern	int dobreak();
x  extern	int dochngd();
x  extern	int docontin();
x
x--- 8,14 -----
x  
x  extern	int doalias();
x  extern	int dobg();
x+ extern	int dobind();
x  extern	int dobreak();
x  extern	int dochngd();
x  extern	int docontin();
x***************
x*** 29,34
x  extern	int dojobs();
x  extern	int dokill();
x  extern	int dolet();
x  extern	int dolimit();
x  extern	int dologin();
x  extern	int dologout();
x
x--- 30,36 -----
x  extern	int dojobs();
x  extern	int dokill();
x  extern	int dolet();
x+ #ifndef OREO
x  extern	int dolimit();
x  #endif
x  extern	int dolog();
x***************
x*** 30,35
x  extern	int dokill();
x  extern	int dolet();
x  extern	int dolimit();
x  extern	int dologin();
x  extern	int dologout();
x  #ifdef NEWGRP
x
x--- 32,39 -----
x  extern	int dolet();
x  #ifndef OREO
x  extern	int dolimit();
x+ #endif
x+ extern	int dolog();
x  extern	int dologin();
x  extern	int dologout();
x  #ifdef NEWGRP
x***************
x*** 42,47
x  extern	int dopopd();
x  extern	int dopushd();
x  extern	int dorepeat();
x  extern	int doset();
x  extern	int dosetenv();
x  extern	int dosource();
x
x--- 46,52 -----
x  extern	int dopopd();
x  extern	int dopushd();
x  extern	int dorepeat();
x+ extern	int dosched();
x  extern	int doset();
x  extern	int dosetenv();
x  extern	int dosource();
x***************
x*** 50,55
x  extern	int doswbrk();
x  extern	int doswitch();
x  extern	int dotime();
x  extern	int dounlimit();
x  extern	int doumask();
x  extern	int dowait();
x
x--- 55,61 -----
x  extern	int doswbrk();
x  extern	int doswitch();
x  extern	int dotime();
x+ #ifndef OREO
x  extern	int dounlimit();
x  #endif
x  extern	int doumask();
x***************
x*** 51,56
x  extern	int doswitch();
x  extern	int dotime();
x  extern	int dounlimit();
x  extern	int doumask();
x  extern	int dowait();
x  extern	int dowhile();
x
x--- 57,63 -----
x  extern	int dotime();
x  #ifndef OREO
x  extern	int dounlimit();
x+ #endif
x  extern	int doumask();
x  extern	int dowait();
x  extern	int dowhile();
x***************
x*** 66,71
x  extern	int dounhash();
x  extern	int unset();
x  extern	int dounsetenv();
x  
x  #define	INF	1000
x  
x
x--- 73,79 -----
x  extern	int dounhash();
x  extern	int unset();
x  extern	int dounsetenv();
x+ extern	int dolist();		/* for ls-F */
x  
x  #define	INF	1000
x  
x***************
x*** 76,82
x  } bfunc[] = {
x  	"@",		dolet,		0,	INF,
x  	"alias",	doalias,	0,	INF,
x- #ifdef debug
x  	"alloc",	showall,	0,	1,
x  #endif
x  	"bg",		dobg,		0,	INF,
x
x--- 84,89 -----
x  } bfunc[] = {
x  	"@",		dolet,		0,	INF,
x  	"alias",	doalias,	0,	INF,
x  	"alloc",	showall,	0,	1,
x  	"bg",		dobg,		0,	INF,
x  	"bind",		dobind,		0,	2,
x***************
x*** 78,84
x  	"alias",	doalias,	0,	INF,
x  #ifdef debug
x  	"alloc",	showall,	0,	1,
x- #endif
x  	"bg",		dobg,		0,	INF,
x  	"break",	dobreak,	0,	0,
x  	"breaksw",	doswbrk,	0,	0,
x
x--- 85,90 -----
x  	"@",		dolet,		0,	INF,
x  	"alias",	doalias,	0,	INF,
x  	"alloc",	showall,	0,	1,
x  	"bg",		dobg,		0,	INF,
x  	"bind",		dobind,		0,	2,
x  	"break",	dobreak,	0,	0,
x***************
x*** 80,85
x  	"alloc",	showall,	0,	1,
x  #endif
x  	"bg",		dobg,		0,	INF,
x  	"break",	dobreak,	0,	0,
x  	"breaksw",	doswbrk,	0,	0,
x  #ifdef IIASA
x
x--- 86,92 -----
x  	"alias",	doalias,	0,	INF,
x  	"alloc",	showall,	0,	1,
x  	"bg",		dobg,		0,	INF,
x+ 	"bind",		dobind,		0,	2,
x  	"break",	dobreak,	0,	0,
x  	"breaksw",	doswbrk,	0,	0,
x  #ifdef IIASA
x***************
x*** 113,118
x  	"if",		doif,		1,	INF,
x  	"jobs",		dojobs,		0,	1,
x  	"kill",		dokill,		1,	INF,
x  	"limit",	dolimit,	0,	3,
x  	"login",	dologin,	0,	1,
x  	"logout",	dologout,	0,	0,
x
x--- 120,126 -----
x  	"if",		doif,		1,	INF,
x  	"jobs",		dojobs,		0,	1,
x  	"kill",		dokill,		1,	INF,
x+ #ifndef OREO
x  	"limit",	dolimit,	0,	3,
x  #endif OREO
x  	"linedit",	doecho,		0,	INF,
x***************
x*** 114,119
x  	"jobs",		dojobs,		0,	1,
x  	"kill",		dokill,		1,	INF,
x  	"limit",	dolimit,	0,	3,
x  	"login",	dologin,	0,	1,
x  	"logout",	dologout,	0,	0,
x  #ifdef NEWGRP
x
x--- 122,130 -----
x  	"kill",		dokill,		1,	INF,
x  #ifndef OREO
x  	"limit",	dolimit,	0,	3,
x+ #endif OREO
x+ 	"linedit",	doecho,		0,	INF,
x+ 	"log",		dolog,		0,	0,
x  	"login",	dologin,	0,	1,
x  	"logout",	dologout,	0,	0,
x  	"ls-F",		dolist,		0,	INF,
x***************
x*** 116,121
x  	"limit",	dolimit,	0,	3,
x  	"login",	dologin,	0,	1,
x  	"logout",	dologout,	0,	0,
x  #ifdef NEWGRP
x  	"newgrp",	donewgrp,	1,	1,
x  #endif
x
x--- 127,133 -----
x  	"log",		dolog,		0,	0,
x  	"login",	dologin,	0,	1,
x  	"logout",	dologout,	0,	0,
x+ 	"ls-F",		dolist,		0,	INF,
x  #ifdef NEWGRP
x  	"newgrp",	donewgrp,	1,	1,
x  #endif
x***************
x*** 130,135
x  #endif
x  	"rehash",	dohash,		0,	0,
x  	"repeat",	dorepeat,	2,	INF,
x  	"set",		doset,		0,	INF,
x  	"setenv",	dosetenv,	2,	2,
x  	"shift",	shift,		0,	1,
x
x--- 142,148 -----
x  #endif
x  	"rehash",	dohash,		0,	0,
x  	"repeat",	dorepeat,	2,	INF,
x+ 	"sched",	dosched,	0,	INF,
x  	"set",		doset,		0,	INF,
x  	"setenv",	dosetenv,	2,	2,
x  	"shift",	shift,		0,	1,
x***************
x*** 141,146
x  	"umask",	doumask,	0,	1,
x  	"unalias",	unalias,	1,	INF,
x  	"unhash",	dounhash,	0,	0,
x  	"unlimit",	dounlimit,	0,	INF,
x  	"unset",	unset,		1,	INF,
x  	"unsetenv",	dounsetenv,	1,	INF,
x
x--- 154,160 -----
x  	"umask",	doumask,	0,	1,
x  	"unalias",	unalias,	1,	INF,
x  	"unhash",	dounhash,	0,	0,
x+ #ifndef OREO
x  	"unlimit",	dounlimit,	0,	INF,
x  #endif
x  	"unset",	unset,		1,	INF,
x***************
x*** 142,147
x  	"unalias",	unalias,	1,	INF,
x  	"unhash",	dounhash,	0,	0,
x  	"unlimit",	dounlimit,	0,	INF,
x  	"unset",	unset,		1,	INF,
x  	"unsetenv",	dounsetenv,	1,	INF,
x  	"wait",		dowait,		0,	0,
x
x--- 156,162 -----
x  	"unhash",	dounhash,	0,	0,
x  #ifndef OREO
x  	"unlimit",	dounlimit,	0,	INF,
x+ #endif
x  	"unset",	unset,		1,	INF,
x  	"unsetenv",	dounsetenv,	1,	INF,
x  	"wait",		dowait,		0,	0,
x***************
x*** 213,219
x  	"PIPE",	"Broken pipe",
x  	"ALRM",	"Alarm clock",
x  	"TERM",	"Terminated",
x! 	0,	"Signal 16",
x  	"STOP",	"Stopped (signal)",
x  	"TSTP",	"Stopped",
x  	"CONT",	"Continued",
x
x--- 228,236 -----
x  	"PIPE",	"Broken pipe",
x  	"ALRM",	"Alarm clock",
x  	"TERM",	"Terminated",
x! #ifdef SVID
x! # ifdef pyr			/* these are really the BSD sigs, plus a few */
x! 	"URG",	"Urgent condition on IO channel",
x  	"STOP",	"Stopped (signal)",
x  	"TSTP",	"Stopped",
x  	"CONT",	"Continued",
x***************
x*** 220,226
x  	"CHLD",	"Child exited",
x  	"TTIN", "Stopped (tty input)",
x  	"TTOU", "Stopped (tty output)",
x! 	"TINT", "Tty input interrupt",
x  	"XCPU",	"Cputime limit exceeded",
x  	"XFSZ", "Filesize limit exceeded",
x  	0,	"Signal 26",
x
x--- 237,243 -----
x  	"CHLD",	"Child exited",
x  	"TTIN", "Stopped (tty input)",
x  	"TTOU", "Stopped (tty output)",
x! 	"IO",   "IO possible interrupt",
x  	"XCPU",	"Cputime limit exceeded",
x  	"XFSZ", "Filesize limit exceeded",
x  	"VTALRM", "Virtual time alarm",
x***************
x*** 223,228
x  	"TINT", "Tty input interrupt",
x  	"XCPU",	"Cputime limit exceeded",
x  	"XFSZ", "Filesize limit exceeded",
x  	0,	"Signal 26",
x  	0,	"Signal 27",
x  	0,	"Signal 28",
x
x--- 240,275 -----
x  	"IO",   "IO possible interrupt",
x  	"XCPU",	"Cputime limit exceeded",
x  	"XFSZ", "Filesize limit exceeded",
x+ 	"VTALRM", "Virtual time alarm",
x+ 	"PROF",	"Profiling time alarm",
x+ 	"USR1",	"User signal 1",
x+ 	"USR2",	"User signal 2",
x+ 	"PWR",	"Power failure",
x+ 	0,	"Signal 31",
x+ 	0,	"Signal 32"
x+ # else pyr			/* the first four real SVID sigs. */
x+ 	"USR1",	"User signal 1",
x+ 	"USR2", "User signal 2",
x+ 	"CHLD",	"Child exited",
x+ 	"PWR",  "Power failure",
x+ #  ifdef OREO
x+ 	"TSTP",	"Stopped",
x+ 	"TTIN", "Stopped (tty input)",
x+ 	"TTOU", "Stopped (tty output)",
x+ 	"STOP",	"Stopped (signal)",
x+ 	"XCPU",	"Cputime limit exceeded",
x+ 	"XFSZ", "Filesize limit exceeded",
x+ 	"VTALRM", "Virtual time alarm",
x+ 	"PROF", "Profiling time alarm",
x+ 	"WINCH", "Window changed",
x+ 	"CONT",	"Continued",
x+ #  else OREO
x+ 	0,	"Signal 20",
x+ 	0,	"Signal 21",
x+ 	0,	"Signal 22",
x+ 	0,	"Signal 23",
x+ 	0,	"Signal 24",
x+ 	0,	"Signal 25",
x  	0,	"Signal 26",
x  	0,	"Signal 27",
x  	0,	"Signal 28",
x***************
x*** 227,232
x  	0,	"Signal 27",
x  	0,	"Signal 28",
x  	0,	"Signal 29",
x  	0,	"Signal 30",
x  	0,	"Signal 31",
x  	0,	"Signal 32"
x
x--- 274,280 -----
x  	0,	"Signal 27",
x  	0,	"Signal 28",
x  	0,	"Signal 29",
x+ #  endif OREO
x  	0,	"Signal 30",
x  	0,	"Signal 31",
x  	0,	"Signal 32"
x***************
x*** 230,233
x  	0,	"Signal 30",
x  	0,	"Signal 31",
x  	0,	"Signal 32"
x  };
x
x--- 278,317 -----
x  	0,	"Signal 30",
x  	0,	"Signal 31",
x  	0,	"Signal 32"
x+ # endif pyr
x+ #else SVID
x+ 	"URG",	"Urgent condition on IO channel",
x+ 	"STOP",	"Stopped (signal)",
x+ 	"TSTP",	"Stopped",
x+ 	"CONT",	"Continued",
x+ 	"CHLD",	"Child exited",
x+ 	"TTIN", "Stopped (tty input)",
x+ 	"TTOU", "Stopped (tty output)",
x+ 	"IO",   "IO possible interrupt",
x+ 	"XCPU",	"Cputime limit exceeded",
x+ 	"XFSZ", "Filesize limit exceeded",
x+ 	"VTALRM", "Virtual time alarm",
x+ 	"PROF",	"Profiling time alarm",
x+ # ifdef sun
x+ 	"WINCH", "Window changed",
x+ 	"LOST",	"Resource lost",
x+ 	"USR1",	"User signal 1",
x+ 	"USR2",	"User signal 2",
x+ 	0,	"Signal 32"
x+ # else sun
x+ #  ifdef pyr
x+ 	"USR1",	"User signal 1",
x+ 	"USR2",	"User signal 2",
x+ 	"PWR",	"Power failure",
x+ 	0,	"Signal 31",
x+ 	0,	"Signal 32"
x+ #  else pyr
x+ 	0,	"Signal 28",
x+ 	0,	"Signal 29",
x+ 	0,	"Signal 30",
x+ 	0,	"Signal 31",
x+ 	0,	"Signal 32"
x+ #  endif pyr
x+ # endif sun
x+ #endif SVID
x  };
x*** ../csh4.2/sh.lex.c	Tue Jun 23 12:13:57 1987
x--- sh.lex.c	Mon Jun 29 17:41:22 1987
x***************
x*** 179,184
x  				else {
x  					if (c == '\n' && c1 != '`')
x  						c |= QUOTE;
x  					ungetC(c), c = '\\';
x  				}
x  			}
x
x--- 179,189 -----
x  				else {
x  					if (c == '\n' && c1 != '`')
x  						c |= QUOTE;
x+ 					else if (c == '"')
x+ 						c |= QUOTE;
x+ 					else if (c == '\'')
x+ 						c |= QUOTE;
x+ 					else
x  						ungetC(c), c = '\\';
x  				}
x  			}
x***************
x*** 1126,1132
x  reread:
x  		c = bgetc();
x  		if (c < 0) {
x! #include <sgtty.h>
x  			struct sgttyb tty;
x  
x  			if (wanteof)
x
x--- 1131,1142 -----
x  reread:
x  		c = bgetc();
x  		if (c < 0) {
x! #ifdef SVID
x! #include <termio.h>
x! #include <sys/ioctl.h>
x! 			struct termio tty;
x! #else SVID
x! /* #include <sgtty.h> */
x  			struct sgttyb tty;
x  #endif SVID
x  
x***************
x*** 1128,1133
x  		if (c < 0) {
x  #include <sgtty.h>
x  			struct sgttyb tty;
x  
x  			if (wanteof)
x  				return (-1);
x
x--- 1138,1144 -----
x  #else SVID
x  /* #include <sgtty.h> */
x  			struct sgttyb tty;
x+ #endif SVID
x  
x  			if (wanteof)
x  				return (-1);
x***************
x*** 1132,1138
x  			if (wanteof)
x  				return (-1);
x  			/* was isatty but raw with ignoreeof yields problems */
x! 			if (ioctl(SHIN, TIOCGETP, &tty)==0 && (tty.sg_flags & RAW) == 0) {
x  				int ctpgrp;
x  
x  				if (++sincereal > 25)
x
x--- 1143,1155 -----
x  			if (wanteof)
x  				return (-1);
x  			/* was isatty but raw with ignoreeof yields problems */
x! #ifdef SVID
x! 			if (ioctl(SHIN, TCGETA, &tty)==0 &&
x! 			    (tty.c_cc[VEOF] != CEOF)) {
x! #else SVID
x! 			if (ioctl(SHIN, TIOCGETP, &tty)==0 &&
x! 			    (tty.sg_flags & RAW) == 0) {
x! #endif SVID
x  				int ctpgrp;
x  
x  				if (++sincereal > 25)
x***************
x*** 1137,1142
x  
x  				if (++sincereal > 25)
x  					goto oops;
x  				if (tpgrp != -1 &&
x  				    ioctl(FSHTTY, TIOCGPGRP, &ctpgrp) == 0 &&
x  				    tpgrp != ctpgrp) {
x
x--- 1154,1160 -----
x  
x  				if (++sincereal > 25)
x  					goto oops;
x+ #ifdef BSDJOBS
x  				if (tpgrp != -1 &&
x  				    ioctl(FSHTTY, TIOCGPGRP, &ctpgrp) == 0 &&
x  				    tpgrp != ctpgrp) {
x***************
x*** 1145,1150
x  printf("Reset tty pgrp from %d to %d\n", ctpgrp, tpgrp);
x  					goto reread;
x  				}
x  				if (adrof("ignoreeof")) {
x  					if (loginsh)
x  						printf("\nUse \"logout\" to logout.\n");
x
x--- 1163,1169 -----
x  printf("Reset tty pgrp from %d to %d\n", ctpgrp, tpgrp);
x  					goto reread;
x  				}
x+ #endif BSDJOBS
x  				if (adrof("ignoreeof")) {
x  					if (loginsh)
x  						printf("\nUse \"logout\" to logout.\n");
x***************
x*** 1149,1155
x  					if (loginsh)
x  						printf("\nUse \"logout\" to logout.\n");
x  					else
x! 						printf("\nUse \"exit\" to leave csh.\n");
x  					reset();
x  				}
x  				if (chkstop == 0)
x
x--- 1168,1174 -----
x  					if (loginsh)
x  						printf("\nUse \"logout\" to logout.\n");
x  					else
x! 						printf("\nUse \"exit\" to leave tcsh.\n");
x  					reset();
x  				}
x  				if (chkstop == 0)
x***************
x*** 1169,1174
x  bgetc()
x  {
x  	register int buf, off, c;
x  
x  #ifdef TELL
x  	if (cantell) {
x
x--- 1188,1195 -----
x  bgetc()
x  {
x  	register int buf, off, c;
x+ 	extern char InputBuf[];
x+ 	register int numleft = 0, roomleft;
x  
x  #ifdef TELL
x  	if (cantell) {
x***************
x*** 1202,1207
x  		fbuf = nfbuf;
x  		fbuf[fblocks] = calloc(BUFSIZ, sizeof (char));
x  		fblocks++;
x  		goto again;
x  	}
x  	if (fseekp >= feobp) {
x
x--- 1223,1229 -----
x  		fbuf = nfbuf;
x  		fbuf[fblocks] = calloc(BUFSIZ, sizeof (char));
x  		fblocks++;
x+ 		if (!intty)
x  		    goto again;
x  	}
x  	if (fseekp >= feobp) {
x***************
x*** 1207,1212
x  	if (fseekp >= feobp) {
x  		buf = (int) feobp / BUFSIZ;
x  		off = (int) feobp % BUFSIZ;
x  		do
x  			c = read(SHIN, fbuf[buf] + off, BUFSIZ - off);
x  		while (c < 0 && errno == EINTR);
x
x--- 1229,1235 -----
x  	if (fseekp >= feobp) {
x  		buf = (int) feobp / BUFSIZ;
x  		off = (int) feobp % BUFSIZ;
x+ 		roomleft = BUFSIZ - off;
x  		do
x  		    if (intty)			/* then use twenex routine */
x  		    {
x***************
x*** 1208,1214
x  		buf = (int) feobp / BUFSIZ;
x  		off = (int) feobp % BUFSIZ;
x  		do
x! 			c = read(SHIN, fbuf[buf] + off, BUFSIZ - off);
x  		while (c < 0 && errno == EINTR);
x  		if (c <= 0)
x  			return (-1);
x
x--- 1231,1253 -----
x  		off = (int) feobp % BUFSIZ;
x  		roomleft = BUFSIZ - off;
x  		do
x! 		    if (intty)			/* then use twenex routine */
x! 		    {
x! 			c = numleft ? numleft : Inputl(); /* PWP: get a line */
x! 			if (c > roomleft)	/* No room in this buffer? */
x! 			{
x! 			    /* start with fresh buffer */
x! 			    feobp = fseekp = fblocks * BUFSIZ;
x! 			    numleft = c;
x! 			    goto again;
x! 			}
x! 			if (c > 0)
x! 			    copy (fbuf[buf] + off, InputBuf, c);
x! 			    /* copy (fbuf[buf] + off, ttyline, c); */
x! 			numleft = 0;
x! 		    }
x! 		    else
x! 			c = read(SHIN, fbuf[buf] + off, roomleft);
x  		while (c < 0 && errno == EINTR);
x  		if (c <= 0)
x  			return (-1);
x***************
x*** 1213,1218
x  		if (c <= 0)
x  			return (-1);
x  		feobp += c;
x  		goto again;
x  	}
x  	c = fbuf[buf][(int) fseekp % BUFSIZ];
x
x--- 1252,1258 -----
x  		if (c <= 0)
x  			return (-1);
x  		feobp += c;
x+ 		if (!intty)
x  		    goto again;
x  	}
x  	c = fbuf[buf][(int) fseekp % BUFSIZ];
x*** ../csh4.2/sh.local.h	Tue Jun 23 12:13:57 1987
x--- sh.local.h	Tue Jun 30 16:10:30 1987
x***************
x*** 18,25
x   */
x  
x  #define	BUFSIZ	1024		/* default buffer size */
x! #define HZ	100		/* for division into seconds */
x! #define	SHELLPATH	"/bin/csh"
x  #define	OTHERSH		"/bin/sh"
x  #define FORKSLEEP	10	/* delay loop on non-interactive fork failure */
x  #define	MAILINTVL	600	/* 10 minutes */
x
x--- 18,27 -----
x   */
x  
x  #define	BUFSIZ	1024		/* default buffer size */
x! /* #define HZ	100		/* for division into seconds */
x! #ifndef SHELLPATH
x! #define	SHELLPATH	"/bin/tcsh"
x! #endif
x  #define	OTHERSH		"/bin/sh"
x  #define FORKSLEEP	10	/* delay loop on non-interactive fork failure */
x  #define	MAILINTVL	600	/* 10 minutes */
x***************
x*** 27,32
x  /*
x   * NCARGS and NOFILE are from <sys/param.h> which we choose not
x   * to wholly include
x   */
x  #define	NCARGS	10240		/* Max. chars in an argument list */
x  
x
x--- 29,35 -----
x  /*
x   * NCARGS and NOFILE are from <sys/param.h> which we choose not
x   * to wholly include
x+  * -- except that we DO include param.h... -- PWP
x   */
x  /* #define	NCARGS	10240		/* Max. chars in an argument list */
x  
x***************
x*** 28,34
x   * NCARGS and NOFILE are from <sys/param.h> which we choose not
x   * to wholly include
x   */
x! #define	NCARGS	10240		/* Max. chars in an argument list */
x  
x  /*
x   * The shell moves std in/out/diag and the old std input away from units
x
x--- 31,37 -----
x   * to wholly include
x   * -- except that we DO include param.h... -- PWP
x   */
x! /* #define	NCARGS	10240		/* Max. chars in an argument list */
x  
x  /*
x   * The shell moves std in/out/diag and the old std input away from units
x***************
x*** 35,41
x   * 0, 1, and 2 so that it is easy to set up these standards for invoked
x   * commands.  If possible they should go into descriptors closed by exec.
x   */
x! #define	NOFILE	20		/* Max number of open files */
x  #define	FSHTTY	15		/* /dev/tty when manip pgrps */
x  #define	FSHIN	16		/* Preferred desc for shell input */
x  #define	FSHOUT	17		/* ... shell output */
x
x--- 38,44 -----
x   * 0, 1, and 2 so that it is easy to set up these standards for invoked
x   * commands.  If possible they should go into descriptors closed by exec.
x   */
x! /* #define	NOFILE	20		/* Max number of open files */
x  #define	FSHTTY	15		/* /dev/tty when manip pgrps */
x  #define	FSHIN	16		/* Preferred desc for shell input */
x  #define	FSHOUT	17		/* ... shell output */
x*** ../csh4.2/sh.misc.c	Tue Jun 23 12:13:59 1987
x--- sh.misc.c	Sun Jun 28 23:20:28 1987
x***************
x*** 57,63
x  		showall(av);
x  		printf("i=%d, j=%d: ", i/j, j);
x  		printf("Out of memory\n");
x! 		chdir("/usr/bill/cshcore");
x  		abort();
x  #endif
x  	}
x
x--- 57,63 -----
x  		showall(av);
x  		printf("i=%d, j=%d: ", i/j, j);
x  		printf("Out of memory\n");
x! 		/* chdir("/usr/bill/cshcore"); */
x  		abort();
x  #endif
x  	}
xNo differences encountered
x*** ../csh4.2/sh.print.c	Tue Jun 23 12:14:01 1987
x--- sh.print.c	Sat Jul  4 12:33:06 1987
x***************
x*** 33,39
x  	printf("%d%d", i / 10, i % 10);
x  }
x  
x! char	linbuf[128];
x  char	*linp = linbuf;
x  
x  putchar(c)
x
x--- 33,39 -----
x  	printf("%d%d", i / 10, i % 10);
x  }
x  
x! char	linbuf[2048];		/* was 128 */
x  char	*linp = linbuf;
x  int lbuffed = 1;		/* true if line buffered */
x  
x***************
x*** 35,40
x  
x  char	linbuf[128];
x  char	*linp = linbuf;
x  
x  putchar(c)
x  	register int c;
x
x--- 35,41 -----
x  
x  char	linbuf[2048];		/* was 128 */
x  char	*linp = linbuf;
x+ int lbuffed = 1;		/* true if line buffered */
x  
x  putchar(c)
x  	register int c;
x***************
x*** 40,46
x  	register int c;
x  {
x  
x! 	if ((c & QUOTE) == 0 && (c == 0177 || c < ' ' && c != '\t' && c != '\n')) {
x  		putchar('^');
x  		if (c == 0177)
x  			c = '?';
x
x--- 41,47 -----
x  	register int c;
x  {
x  
x! 	if ((c & QUOTE) == 0 && (c == 0177 || c < ' ' && c != '\t' && c != '\n' && c != '\r')) {
x  		putchar('^');
x  		if (c == 0177)
x  			c = '?';
x***************
x*** 49,55
x  	}
x  	c &= TRIM;
x  	*linp++ = c;
x! 	if (c == '\n' || linp >= &linbuf[sizeof linbuf - 2])
x  		flush();
x  }
x  
x
x--- 50,56 -----
x  	}
x  	c &= TRIM;
x  	*linp++ = c;
x! 	if ((lbuffed && c == '\n') || linp >= &linbuf[sizeof linbuf - 2])
x  		flush();
x  }
x  
x***************
x*** 53,58
x  		flush();
x  }
x  
x  draino()
x  {
x  
x
x--- 54,68 -----
x  		flush();
x  }
x  
x+ putraw(c)
x+ 	register int c;
x+ {
x+ 	c &= TRIM;
x+ 	*linp++ = c;
x+ 	if (linp >= &linbuf[sizeof linbuf - 2])
x+ 		flush();
x+ }
x+ 
x  draino()
x  {
x  
x***************
x*** 80,86
x  		write(unit, "\n", 1);
x  	}
x  #endif
x! 	write(unit, linbuf, linp - linbuf);
x  	linp = linbuf;
x  }
x  
x
x--- 90,96 -----
x  		write(unit, "\n", 1);
x  	}
x  #endif
x! 	write(unit, linbuf, (int) (linp - linbuf));
x  	linp = linbuf;
x  }
x  
x*** ../csh4.2/sh.proc.c	Tue Jun 23 12:14:03 1987
x--- sh.proc.c	Mon Jun 29 17:52:26 1987
x***************
x*** 6,11
x  #include <sys/wait.h>
x  #include <sys/ioctl.h>
x  
x  /*
x   * C Shell - functions that manage processes, handling hanging, termination
x   */
x
x--- 6,15 -----
x  #include <sys/wait.h>
x  #include <sys/ioctl.h>
x  
x+ #ifndef HZ
x+ #define HZ	100		/* for division into seconds */
x+ #endif
x+ 
x  /*
x   * C Shell - functions that manage processes, handling hanging, termination
x   */
x***************
x*** 26,31
x  	register int pid;
x  	union wait w;
x  	int jobflags;
x  	struct rusage ru;
x  
x  	if (!timesdone)
x
x--- 30,36 -----
x  	register int pid;
x  	union wait w;
x  	int jobflags;
x+ #ifndef OREO
x  	struct rusage ru;
x  #endif
x  
x***************
x*** 27,32
x  	union wait w;
x  	int jobflags;
x  	struct rusage ru;
x  
x  	if (!timesdone)
x  		timesdone++, times(&shtimes);
x
x--- 32,38 -----
x  	int jobflags;
x  #ifndef OREO
x  	struct rusage ru;
x+ #endif
x  
x  	if (!timesdone)
x  		timesdone++, times(&shtimes);
x***************
x*** 32,37
x  		timesdone++, times(&shtimes);
x  loop:
x  	pid = wait3(&w.w_status, (setintr ? WNOHANG|WUNTRACED:WNOHANG),
x  	    &ru);
x  	if (pid <= 0) {
x  		if (errno == EINTR) {
x
x--- 38,46 -----
x  		timesdone++, times(&shtimes);
x  loop:
x  	pid = wait3(&w.w_status, (setintr ? WNOHANG|WUNTRACED:WNOHANG),
x+ #ifdef OREO
x+ 	    0);
x+ #else OREO
x  	    &ru);
x  #endif OREO
x  	if (pid <= 0) {
x***************
x*** 33,38
x  loop:
x  	pid = wait3(&w.w_status, (setintr ? WNOHANG|WUNTRACED:WNOHANG),
x  	    &ru);
x  	if (pid <= 0) {
x  		if (errno == EINTR) {
x  			errno = 0;
x
x--- 42,48 -----
x  	    0);
x  #else OREO
x  	    &ru);
x+ #endif OREO
x  	if (pid <= 0) {
x  		if (errno == EINTR) {
x  			errno = 0;
x***************
x*** 63,68
x  			pp->p_stime = shtimes.tms_cstime - oldcstimes;
x  		} else
x  			times(&shtimes);
x  		pp->p_rusage = ru;
x  		if (WIFSIGNALED(w)) {
x  			if (w.w_termsig == SIGINT)
x
x--- 73,79 -----
x  			pp->p_stime = shtimes.tms_cstime - oldcstimes;
x  		} else
x  			times(&shtimes);
x+ #ifndef OREO
x  		pp->p_rusage = ru;
x  #endif OREO
x  		if (WIFSIGNALED(w)) {
x***************
x*** 64,69
x  		} else
x  			times(&shtimes);
x  		pp->p_rusage = ru;
x  		if (WIFSIGNALED(w)) {
x  			if (w.w_termsig == SIGINT)
x  				pp->p_flags |= PINTERRUPTED;
x
x--- 75,81 -----
x  			times(&shtimes);
x  #ifndef OREO
x  		pp->p_rusage = ru;
x+ #endif OREO
x  		if (WIFSIGNALED(w)) {
x  			if (w.w_termsig == SIGINT)
x  				pp->p_flags |= PINTERRUPTED;
x***************
x*** 215,220
x  		sigpause(sigblock(0) &~ mask(SIGCHLD));
x  	}
x  	sigrelse(SIGCHLD);
x  	if (tpgrp > 0)
x  		ioctl(FSHTTY, TIOCSPGRP, &tpgrp);	/* get tty back */
x  	if ((jobflags&(PSIGNALED|PSTOPPED|PTIME)) ||
x
x--- 227,233 -----
x  		sigpause(sigblock(0) &~ mask(SIGCHLD));
x  	}
x  	sigrelse(SIGCHLD);
x+ #ifdef BSDJOBS
x  	if (tpgrp > 0)
x  		ioctl(FSHTTY, TIOCSPGRP, &tpgrp);	/* get tty back */
x  #endif BSDJOBS
x***************
x*** 217,222
x  	sigrelse(SIGCHLD);
x  	if (tpgrp > 0)
x  		ioctl(FSHTTY, TIOCSPGRP, &tpgrp);	/* get tty back */
x  	if ((jobflags&(PSIGNALED|PSTOPPED|PTIME)) ||
x  	     !eq(dcwd->di_name, fp->p_cwd->di_name)) {
x  		if (jobflags&PSTOPPED)
x
x--- 230,236 -----
x  #ifdef BSDJOBS
x  	if (tpgrp > 0)
x  		ioctl(FSHTTY, TIOCSPGRP, &tpgrp);	/* get tty back */
x+ #endif BSDJOBS
x  	if ((jobflags&(PSIGNALED|PSTOPPED|PTIME)) ||
x  	     !eq(dcwd->di_name, fp->p_cwd->di_name)) {
x  		if (jobflags&PSTOPPED)
x***************
x*** 622,627
x  		if (pp->p_flags&PPTIME && !(status&(PSTOPPED|PRUNNING))) {
x  			if (linp != linbuf)
x  				printf("\n\t");
x  			{ static struct rusage zru;
x  			  prusage(&zru, &pp->p_rusage, &pp->p_etime,
x  			    &pp->p_btime);
x
x--- 636,642 -----
x  		if (pp->p_flags&PPTIME && !(status&(PSTOPPED|PRUNNING))) {
x  			if (linp != linbuf)
x  				printf("\n\t");
x+ #ifndef OREO
x  			{ static struct rusage zru;
x  			  prusage(&zru, &pp->p_rusage, &pp->p_etime,
x  			    &pp->p_btime);
x***************
x*** 626,631
x  			  prusage(&zru, &pp->p_rusage, &pp->p_etime,
x  			    &pp->p_btime);
x  			}
x  		}
x  		if (tp == pp->p_friends) {
x  			if (linp != linbuf)
x
x--- 641,647 -----
x  			  prusage(&zru, &pp->p_rusage, &pp->p_etime,
x  			    &pp->p_btime);
x  			}
x+ #endif OREO
x  		}
x  		if (tp == pp->p_friends) {
x  			if (linp != linbuf)
x***************
x*** 648,653
x  ptprint(tp)
x  	register struct process *tp;
x  {
x  	struct timeval tetime, diff;
x  	static struct timeval ztime;
x  	struct rusage ru;
x
x--- 664,672 -----
x  ptprint(tp)
x  	register struct process *tp;
x  {
x+ #ifdef OREO
x+ 	printf ("There is no time stuff for OREO yet (sorry).\n");
x+ #else OREO
x  	struct timeval tetime, diff;
x  	static struct timeval ztime;
x  	struct rusage ru;
x***************
x*** 663,668
x  			tetime = diff;
x  	} while ((pp = pp->p_friends) != tp);
x  	prusage(&zru, &ru, &tetime, &ztime);
x  }
x  
x  /*
x
x--- 682,688 -----
x  			tetime = diff;
x  	} while ((pp = pp->p_friends) != tp);
x  	prusage(&zru, &ru, &tetime, &ztime);
x+ #endif OREO
x  }
x  
x  /*
x***************
x*** 892,897
x  	if (!foregnd)
x  		pclrcurr(pp);
x  	pprint(pp, foregnd ? NAME|JOBDIR : NUMBER|NAME|AMPERSAND);
x  	if (foregnd)
x  		ioctl(FSHTTY, TIOCSPGRP, &pp->p_jobid);
x  	if (jobflags&PSTOPPED)
x
x--- 912,918 -----
x  	if (!foregnd)
x  		pclrcurr(pp);
x  	pprint(pp, foregnd ? NAME|JOBDIR : NUMBER|NAME|AMPERSAND);
x+ #ifdef BSDJOBS
x  	if (foregnd)
x  		ioctl(FSHTTY, TIOCSPGRP, &pp->p_jobid);
x  	if (jobflags&PSTOPPED)
x***************
x*** 896,901
x  		ioctl(FSHTTY, TIOCSPGRP, &pp->p_jobid);
x  	if (jobflags&PSTOPPED)
x  		killpg(pp->p_jobid, SIGCONT);
x  	sigrelse(SIGCHLD);
x  }
x  
x
x--- 917,923 -----
x  		ioctl(FSHTTY, TIOCSPGRP, &pp->p_jobid);
x  	if (jobflags&PSTOPPED)
x  		killpg(pp->p_jobid, SIGCONT);
x+ #endif BSDJOBS
x  	sigrelse(SIGCHLD);
x  }
x  
x***************
x*** 1061,1066
x  			signal(SIGINT, SIG_IGN);
x  			signal(SIGQUIT, SIG_IGN);
x  		}
x  		if (wanttty > 0)
x  			ioctl(FSHTTY, TIOCSPGRP, &pgrp);
x  		if (wanttty >= 0 && tpgrp >= 0)
x
x--- 1083,1089 -----
x  			signal(SIGINT, SIG_IGN);
x  			signal(SIGQUIT, SIG_IGN);
x  		}
x+ #ifdef BSDJOBS
x  		if (wanttty > 0)
x  			ioctl(FSHTTY, TIOCSPGRP, &pgrp);
x  		if (wanttty >= 0 && tpgrp >= 0)
x***************
x*** 1067,1072
x  			setpgrp(0, pgrp);
x  		if (tpgrp > 0)
x  			tpgrp = 0;		/* gave tty away */
x  		/*
x  		 * Nohup and nice apply only to TCOM's but it would be
x  		 * nice (?!?) if you could say "nohup (foo;bar)"
x
x--- 1090,1096 -----
x  			setpgrp(0, pgrp);
x  		if (tpgrp > 0)
x  			tpgrp = 0;		/* gave tty away */
x+ #endif BSDJOBS
x  		/*
x  		 * Nohup and nice apply only to TCOM's but it would be
x  		 * nice (?!?) if you could say "nohup (foo;bar)"
x*** ../csh4.2/sh.proc.h	Tue Jun 23 12:14:04 1987
x--- sh.proc.h	Sun Jun 28 23:20:42 1987
x***************
x*** 24,29
x  	/* if a job is stopped/background p_jobid gives its pgrp */
x  	struct	timeval p_btime;	/* begin time */
x  	struct	timeval p_etime;	/* end time */
x  	struct	rusage p_rusage;
x  	long	p_utime;	/* XXX */
x  	long	p_stime;	/* XXX */
x
x--- 24,30 -----
x  	/* if a job is stopped/background p_jobid gives its pgrp */
x  	struct	timeval p_btime;	/* begin time */
x  	struct	timeval p_etime;	/* end time */
x+ #ifndef OREO
x  	struct	rusage p_rusage;
x  #endif OREO
x  	long	p_utime;	/* XXX */
x***************
x*** 25,30
x  	struct	timeval p_btime;	/* begin time */
x  	struct	timeval p_etime;	/* end time */
x  	struct	rusage p_rusage;
x  	long	p_utime;	/* XXX */
x  	long	p_stime;	/* XXX */
x  	char	*p_command;		/* first PMAXLEN chars of command */
x
x--- 26,32 -----
x  	struct	timeval p_etime;	/* end time */
x  #ifndef OREO
x  	struct	rusage p_rusage;
x+ #endif OREO
x  	long	p_utime;	/* XXX */
x  	long	p_stime;	/* XXX */
x  	char	*p_command;		/* first PMAXLEN chars of command */
x*** ../csh4.2/sh.sem.c	Tue Jun 23 12:14:05 1987
x--- sh.sem.c	Mon Jun 29 17:56:18 1987
x***************
x*** 168,173
x  					sigsys(SIGINT, SIG_IGN);
x  					sigsys(SIGQUIT, SIG_IGN);
x  				}
x  				if (wanttty > 0)
x  					ioctl(FSHTTY, TIOCSPGRP, &pgrp);
x  				if (wanttty >= 0 && tpgrp >= 0)
x
x--- 168,174 -----
x  					sigsys(SIGINT, SIG_IGN);
x  					sigsys(SIGQUIT, SIG_IGN);
x  				}
x+ #ifdef BSDJOBS
x  				if (wanttty > 0)
x  					ioctl(FSHTTY, TIOCSPGRP, &pgrp);
x  				if (wanttty >= 0 && tpgrp >= 0)
x***************
x*** 172,177
x  					ioctl(FSHTTY, TIOCSPGRP, &pgrp);
x  				if (wanttty >= 0 && tpgrp >= 0)
x  					setpgrp(0, pgrp);
x  				if (tpgrp > 0)
x  					tpgrp = 0;
x  				if (t->t_dflg & FNOHUP)
x
x--- 173,179 -----
x  					ioctl(FSHTTY, TIOCSPGRP, &pgrp);
x  				if (wanttty >= 0 && tpgrp >= 0)
x  					setpgrp(0, pgrp);
x+ #endif BSDJOBS
x  				if (tpgrp > 0)
x  					tpgrp = 0;
x  				if (t->t_dflg & FNOHUP)
x*** ../csh4.2/sh.set.c	Tue Jun 23 12:14:06 1987
x--- sh.set.c	Tue Jun 30 17:19:57 1987
x***************
x*** 73,79
x  
x  			HIST = *p++;
x  			HISTSUB = *p;
x! 		} else if (eq(vp, "user"))
x  			setenv("USER", value(vp));
x  		else if (eq(vp, "term"))
x  			setenv("TERM", value(vp));
x
x--- 73,79 -----
x  
x  			HIST = *p++;
x  			HISTSUB = *p;
x! 		} else if (eq(vp, "user")) {
x  			setenv("USER", value(vp));
x  		} else if (eq(vp, "term")) {
x  			setenv("TERM", value(vp));
x***************
x*** 75,81
x  			HISTSUB = *p;
x  		} else if (eq(vp, "user"))
x  			setenv("USER", value(vp));
x! 		else if (eq(vp, "term"))
x  			setenv("TERM", value(vp));
x  		else if (eq(vp, "home"))
x  			setenv("HOME", value(vp));
x
x--- 75,81 -----
x  			HISTSUB = *p;
x  		} else if (eq(vp, "user")) {
x  			setenv("USER", value(vp));
x! 		} else if (eq(vp, "term")) {
x  			setenv("TERM", value(vp));
x  			ed_Init(); /* reset the editor */
x  		} else if (eq(vp, "home")) {
x***************
x*** 77,83
x  			setenv("USER", value(vp));
x  		else if (eq(vp, "term"))
x  			setenv("TERM", value(vp));
x! 		else if (eq(vp, "home"))
x  			setenv("HOME", value(vp));
x  	} while (p = *v++);
x  }
x
x--- 77,84 -----
x  			setenv("USER", value(vp));
x  		} else if (eq(vp, "term")) {
x  			setenv("TERM", value(vp));
x! 			ed_Init(); /* reset the editor */
x! 		} else if (eq(vp, "home")) {
x  			setenv("HOME", value(vp));
x  		}
x  	} while (p = *v++);
x***************
x*** 79,84
x  			setenv("TERM", value(vp));
x  		else if (eq(vp, "home"))
x  			setenv("HOME", value(vp));
x  	} while (p = *v++);
x  }
x  
x
x--- 80,86 -----
x  			ed_Init(); /* reset the editor */
x  		} else if (eq(vp, "home")) {
x  			setenv("HOME", value(vp));
x+ 		}
x  	} while (p = *v++);
x  }
x  
x***************
x*** 253,258
x  	return (cp < end);
x  }
x  
x  xfree(cp)
x  	char *cp;
x  {
x
x--- 255,263 -----
x  	return (cp < end);
x  }
x  
x+ /* #include "malloc.h" */
x+ 
x+ /* changed 6/04/87 Paul Placeway for use with the faster malloc */
x  xfree(cp)
x  	char *cp;
x  {
x***************
x*** 258,264
x  {
x  	extern char end[];
x  
x! 	if (cp >= end && cp < (char *) &cp)
x  		cfree(cp);
x  }
x  
x
x--- 263,273 -----
x  {
x  	extern char end[];
x  
x! /*	if (cp && (cp >= (char *)adjhead.q_forw) &&
x! 	    (cp <= (char *)adjhead.q_back))
x! 		cfree(cp); */
x! 
x! 	if (cp && cp >= end /* && cp < (char *) &cp */)
x  	    cfree(cp);
x  }
x  
xNo differences encountered
x*** ../csh4.2/sh.time.c	Tue Jun 23 12:14:07 1987
x--- sh.time.c	Sun Jun 28 23:20:49 1987
x***************
x*** 1,5
x  #ifndef lint
x! static char sccsid[] = "@(#)sh.time.c	4.4 (Berkeley) 8/11/83";
x  #endif
x  
x  #include "sh.h"
x
x--- 1,5 -----
x  #ifndef lint
x! static char *sccsid = "@(#)sh.time.c	4.4 (Berkeley) 8/11/83";
x  #endif
x  
x  #include "sh.h"
x***************
x*** 12,17
x  
x  settimes()
x  {
x  	struct rusage ruch;
x  
x  	gettimeofday(&time0, (struct timezone *)0);
x
x--- 12,18 -----
x  
x  settimes()
x  {
x+ #ifndef OREO
x  	struct rusage ruch;
x  #endif
x  
x***************
x*** 13,18
x  settimes()
x  {
x  	struct rusage ruch;
x  
x  	gettimeofday(&time0, (struct timezone *)0);
x  	getrusage(RUSAGE_SELF, &ru0);
x
x--- 14,20 -----
x  {
x  #ifndef OREO
x  	struct rusage ruch;
x+ #endif
x  
x  	gettimeofday(&time0, (struct timezone *)0);
x  #ifndef OREO
x***************
x*** 15,20
x  	struct rusage ruch;
x  
x  	gettimeofday(&time0, (struct timezone *)0);
x  	getrusage(RUSAGE_SELF, &ru0);
x  	getrusage(RUSAGE_CHILDREN, &ruch);
x  	ruadd(&ru0, &ruch);
x
x--- 17,23 -----
x  #endif
x  
x  	gettimeofday(&time0, (struct timezone *)0);
x+ #ifndef OREO
x  	getrusage(RUSAGE_SELF, &ru0);
x  	getrusage(RUSAGE_CHILDREN, &ruch);
x  	ruadd(&ru0, &ruch);
x***************
x*** 18,23
x  	getrusage(RUSAGE_SELF, &ru0);
x  	getrusage(RUSAGE_CHILDREN, &ruch);
x  	ruadd(&ru0, &ruch);
x  }
x  
x  /*
x
x--- 21,27 -----
x  	getrusage(RUSAGE_SELF, &ru0);
x  	getrusage(RUSAGE_CHILDREN, &ruch);
x  	ruadd(&ru0, &ruch);
x+ #endif OREO
x  }
x  
x  /*
x***************
x*** 26,31
x   */
x  dotime()
x  {
x  	struct timeval timedol;
x  	struct rusage ru1, ruch;
x  
x
x--- 30,36 -----
x   */
x  dotime()
x  {
x+ #ifndef OREO
x  	struct timeval timedol;
x  	struct rusage ru1, ruch;
x  
x***************
x*** 34,39
x  	ruadd(&ru1, &ruch);
x  	gettimeofday(&timedol, (struct timezone *)0);
x  	prusage(&ru0, &ru1, &timedol, &time0);
x  }
x  
x  /*
x
x--- 39,45 -----
x  	ruadd(&ru1, &ruch);
x  	gettimeofday(&timedol, (struct timezone *)0);
x  	prusage(&ru0, &ru1, &timedol, &time0);
x+ #endif
x  }
x  
x  /*
x***************
x*** 60,65
x  	}
x  }
x  
x  ruadd(ru, ru2)
x  	register struct rusage *ru, *ru2;
x  {
x
x--- 66,72 -----
x  	}
x  }
x  
x+ #ifndef OREO
x  ruadd(ru, ru2)
x  	register struct rusage *ru, *ru2;
x  {
x***************
x*** 158,163
x  	}
x  	putchar('\n');
x  }
x  
x  pdeltat(t1, t0)
x  	struct timeval *t1, *t0;
x
x--- 165,171 -----
x  	}
x  	putchar('\n');
x  }
x+ #endif
x  
x  pdeltat(t1, t0)
x  	struct timeval *t1, *t0;
\Rogue\Monster\
else
  echo "will not over write ./DIFFS.2"
fi
if [ `wc -c ./DIFFS.2 | awk '{printf $1}'` -ne 46609 ]
then
echo `wc -c ./DIFFS.2 | awk '{print "Got " $1 ", Expected " 46609}'`
fi
echo "Finished archive 5 of 6"
# if you want to concatenate archives, remove anything after this line
exit

-- 

Rich $alz
Cronus Project, BBN Labs			rsalz@bbn.com
Moderator, comp.sources.unix			sources@uunet.uu.net
