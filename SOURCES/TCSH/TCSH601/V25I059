Newsgroups: comp.sources.unix
From: christos@ee.cornell.edu (Christos Zoulas)
Subject: v25i059: tcsh6.01 - a csh replacement with lots of extra goodies, Part06/18
Message-ID: <1991Dec20.214046.6736@PA.dec.com>
Date: Fri, 20 Dec 91 21:40:46 GMT
Approved: vixie@pa.dec.com

Submitted-By: christos@ee.cornell.edu (Christos Zoulas)
Posting-Number: Volume 25, Issue 59
Archive-Name: tcsh-6.01/part06

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 6 (of 18)."
# Contents:  Makefile sh.decls.h sh.exp.c sh.parse.c tc.alloc.c
#   tc.const.c
# Wrapped by vixie@cognition.pa.dec.com on Fri Dec 20 13:29:26 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(12647 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X# $Id: Makefile,v 1.15 1991/12/19 22:05:32 christos Exp $
X#	Makefile	4.3	6/11/83
X#
X# C Shell with process control; VM/UNIX VAX Makefile
X# Bill Joy UC Berkeley; Jim Kulp IIASA, Austria
X#
X# With an input editor, command completion, etc. and ported to all sorts of
X# things; Paul Placeway, CIS Dept., Ohio State University
X#
SHELL=/bin/sh
VERSION=6.01
BUILD=tcsh
X
X################################################################
X## CFLAGS.  For various -D things, see config.h
X################################################################
X#
X# These are the default suffixes from .c to .o and -c to get there
X# but to use the global optimizer on the mips boxes, see below
X#
SUF=o
CF=-c
X
INCLUDES=-I. -I..
X
LFLAGS=$(INCLUDES)
X#LFLAGS=$(INCLUDES) -Zn10000		# hpux lint
X
X
X#CFLAGS= $(INCLUDES) -g			# debug
X#CFLAGS= $(INCLUDES) -O			# production
X#CFLAGS= $(INCLUDES) 			# Broken optimizers....
X
X#CFLAGS= -g -pg $(INCLUDES) -DPROF
X#CFLAGS= -O -pg $(INCLUDES) -DPROF
X
X# gcc 1.37-
X#CFLAGS=-O $(INCLUDES) -finline-functions -fstrength-reduce 
X
X# gcc 1.37+
CFLAGS=-O $(INCLUDES) -fcombine-regs -finline-functions -fstrength-reduce 
X# add -msoft-float for 68881 machines.
X
X#hpux 8.0
X
X#CFLAGS=  $(INCLUDES) +O3 -Aa
X
X# for silicon graphics (and other mips compilers) -- use the
X# global optimizer! (-O3).
X# On SGI 4.0+ you need to add -D__STDC__ too.
X#CFLAGS= -O3 $(INCLUDES) 
X#CF=-j
X#SUF=u
X#.SUFFIXES: .u 				## Ultrix needs that
X
X# mips systems
X# CFLAGS= $(INCLUDES) -O -systype bsd43 -Wf,-XNd5000 -Wf,-XNp6000 -Olimit 2000
X
X# for at&t machines
X#CFLAGS= -O -Ksd $(INCLUDES)
X
X# for convexen
X#CFLAGS= $(INCLUDES) -ext -tm c1
X
X# Stardent Titan
X#CFLAGS = $(INCLUDES) -O -43
X
X# Stardent Stellar
X#CFLAGS = $(INCLUDES) -O4
X
X# Apollo's with cc [apollo builtins don't work with gcc]
X# and apollo should not define __STDC__ if it does not have
X# the standard header files. RT's (aos4.3) need that too;
X# you might want to skip the -O on the rt's... Not very wise.
X# AIX/ESA needs -D_IBMESA on command line (this may disappear by GA)
X#DFLAGS=-U__STDC__ 
X#DFLAGS=-D_IBMESA
X# On aix2.2.1 we need more compiler space.
X#DFLAGS=-Nd4000 -Nn3000
DFLAGS=
X
X
X################################################################
X## LDLAGS.  Define something here if you need to
X################################################################
LDFLAGS= 			## The simplest, suitable for all.
X#LDFLAGS= -s			## Stripped. Takes less space on disk.
X#LDFLAGS= -s -n			## Pure executable. Spares paging over
X# 				## the network for machines with local
X#				## swap but external /usr/local/bin .
X#LDFLAGS= -s -n -Bstatic	## Without dynamic links. (SunOS)
X
X################################################################
X## LIBES.  Pick one, or roll your own.
X################################################################
LIBES= -ltermcap		## BSD style things, hpux
X#LIBES= -ltermcap -lcs		## Mach
X#LIBES= -lcurses		## Sys V3 w/o networking (and Sys V4)
X#LIBES= -lcurses -lc /usr/ucblib/libucb.a ## Sys V4 with BSDTIMES
X#LIBES= -lcurses		## Sys V4 w/o BSDTIMES
X#LIBES= -lcurses -lnet		## Sys V3 with networking
X#LIBES= -lcurses -ldir		## Sys V2 w/o networking [needs directory lib]
X#LIBES= -lcurses -ldir -lnet	## Sys V2 with networking [needs directory lib]
X#LIBES= -lcurses -lsocket -lbsd	## Amdahl UTS 2.1
X#LIBES= -lcurses -lbsd		## For Irix3.1 on SGI-IRIS4D or ETA10
X#LIBES= -lcurses -lsun -lbsd -lc_s ## For Irix3.3 on SGI-IRIS4D (w/ yp)
X#LIBES= -lcurses -lbsd -lc_s	## For Irix3.3 on SGI-IRIS4D (wo/ yp)
X#LIBES= -lcurses -lbsd		## For aix on an IBM 370 or rs6000 or ps2
X#LIBES= -lcurses		## For aix on the rt
X#LIBES= -lcurses -lcposix	## ISC 2.2 
X#LIBES= -lcposix -lc_s -lcurses -linet ## ISC 2.2 with networking
X#LIBES= -lcurses -linet -lc_s   ## ISC 2.0.2 with networking
X#LIBES= -ltermcap -ldir -lx	## Xenix 386 style things
X#LIBES= -lcurses -lintl		## SCO SysVR3.2v2.0
X#LIBES= -lcurses -lintl -lsocket ## SCO+ODT1.1
X#LIBES= -lposix -ltermcap	## A/UX 2.0
X#LIBES= -ltermcap -lseq		## Sequent's Dynix
X#LIBES= -lcurses -lsocket	## Intel's hypercube and ns32000 based Opus.
X#LIBES= -ldirent -lcurses       ## att3b1 stk cc w/o shared lib & directory lib
X#LIBES= -shlib -ldirent -lcurses ## att3b1 gcc1.40 w/ shared lib & directory lib
X#LIBES=				## Minix.
X#LIBES= -lcurses		## For a stellar
X
X
X# The difficult choice of a c-compiler...
X# First, you should try your own c-compiler. 
X# Gcc -traditional is also a safe choice. 
X# If you think that you have good include files try gcc -Wall...
X# If you want to take out -traditional, make sure that your sys/ioctl.h
X# is fixed correctly, otherwise you'll be stopped for tty input!
CC=	gcc -Wall 
X#CC=	cc
X#CC=	occ
X#CC=	/bin/cc	# For suns, w/o gcc and SVR4
X#CC=	/usr/lib/sun.compile/cc  # FPS 500 (+FPX) with Sun C compiler
XED=	-ed
AS=	-as
RM=	-rm
CXREF=	/usr/ucb/cxref
VGRIND=	csh /usr/ucb/vgrind
CTAGS=	/usr/ucb/ctags
X#XSTR= /usr/ucb/xstr
SCCS=	/usr/local/sccs
PARALLEL=12				# Make the multi-max run fast.
X#P=&					# Use Sequent's parallel make
P=
DESTDIR=/usr/local
MANSECT=1
DESTBIN=${DESTDIR}/bin
DESTMAN=${DESTDIR}/man/man${MANSECT}
XFTPAREA=/usr/spool/ftp
X
ASSRCS=	sh.c sh.dir.c sh.dol.c sh.err.c sh.exec.c sh.char.c \
X	sh.exp.c sh.file.c sh.func.c sh.glob.c sh.hist.c sh.init.c \
X	sh.lex.c sh.misc.c sh.parse.c sh.print.c sh.proc.c sh.sem.c \
X	sh.set.c sh.time.c sh.char.h sh.dir.h sh.proc.h sh.h 
PSSRCS= sh.decls.h glob.c glob.h mi.termios.c mi.wait.h
SHSRCS= ${ASSRCS} ${PSSRCS}
SHOBJS=	sh.${SUF} sh.dir.${SUF} sh.dol.${SUF} sh.err.${SUF} sh.exec.${SUF} \
X	sh.char.${SUF} sh.exp.${SUF} sh.func.${SUF} sh.glob.${SUF} \
X	sh.hist.${SUF} sh.init.${SUF} sh.lex.${SUF} sh.misc.${SUF} \
X	sh.parse.${SUF} sh.print.${SUF} sh.proc.${SUF} sh.sem.${SUF} \
X	sh.set.${SUF} sh.time.${SUF} glob.${SUF} mi.termios.${SUF}
X
TWSRCS= tw.decls.h tw.h tw.help.c tw.init.c tw.parse.c tw.spell.c
TWOBJS=	tw.help.${SUF} tw.init.${SUF} tw.parse.${SUF} tw.spell.${SUF}
X
XEDSRCS= ed.chared.c ed.decls.h ed.defns.c ed.h ed.init.c ed.inputl.c \
X	ed.refresh.c ed.screen.c ed.xmap.c ed.term.c ed.term.h
XEDOBJS=	ed.chared.${SUF} ed.refresh.${SUF} ed.screen.${SUF} ed.init.${SUF} \
X	ed.inputl.${SUF} ed.defns.${SUF} ed.xmap.${SUF} ed.term.${SUF}
X
TCSRCS= tc.alloc.c tc.bind.c tc.const.c tc.decls.h tc.disc.c \
X	tc.func.c tc.os.c tc.os.h tc.printf.c tc.prompt.c \
X	tc.sched.c tc.sig.c tc.sig.h tc.str.c sh.types.h tc.vers.c tc.wait.h \
X	tc.who.c tc.h
TCOBJS=	tc.alloc.${SUF} tc.bind.${SUF} tc.const.${SUF} tc.disc.${SUF} \
X	tc.func.${SUF} tc.os.${SUF} tc.printf.${SUF} \
X	tc.prompt.${SUF} tc.sched.${SUF} tc.sig.${SUF} tc.str.${SUF} \
X	tc.vers.${SUF} tc.who.${SUF} 
X
PVSRCS= Makefile
AVSRCS= Fixes MAKEDIFFS MAKESHAR NewThings README FAQ \
X	WishList config_f.h eight-bit.me glob.3 patchlevel.h \
X	pathnames.h tcsh.man Ported src.desc Imakefile imake.config \
X	README.imake
VHSRCS=${PVSRCS} ${AVSRCS}
X
CONFSRCS=config/config.* 
X
ALLSRCS=  ${SHSRCS} ${TWSRCS} ${EDSRCS} ${TCSRCS} ${VHSRCS}
DISTSRCS= ${PSSRCS} ${TWSRCS} ${EDSRCS} ${TCSRCS} ${AVSRCS}
X
X
OBJS= ${SHOBJS} ${TWOBJS} ${EDOBJS} ${TCOBJS}
X
X
all: ${BUILD}
X
tcsh:$(P) ${OBJS} 
X	rm -f tcsh core
X	${CC} ${LDFLAGS} ${CFLAGS} ${OBJS} -o tcsh ${LIBES}
X
tcsh.ps: tcsh.1
X	rm -f tcsh.ps
X	-ptroff -man tcsh.1 > tcsh.ps
X
X
X.c.${SUF}:
X	${CC} ${CF} ${CFLAGS} ${DFLAGS} $<
X
X# Don't do any special massaging of C files for sharing of strings!!
X# it causes weird segmentation faults on some systems.
X#.c.o:
X#	${CC} -E ${CFLAGS} $*.c | ${XSTR} -c -
X#	${CC} ${CF} ${CFLAGS} x.c 
X#	mv -f x.o $*.o
X#	rm -f x.c
X
X#ed.init.o: ed.init.c
X#	${CC} -E ${CFLAGS} $*.c | ${XSTR} -c -
X#	${CC} -R ${CF} ${CF} x.c 
X#	mv -f x.o $*.o
X#	rm -f x.c
X
X#strings.o: strings
X#	${XSTR}
X#	${CC} -c -R xs.c
X#	mv -f xs.o strings.o
X#	rm -f xs.c
X
X##.DEFAULT:
X##	${SCCS} get $<
X
X##.DEFAULT:
X##	co $<
X
ed.defns.h: ed.defns.c
X	@rm -f $@
X	@echo '/* Do not edit this file, make creates it. */' > $@
X	@echo '#ifndef _h_ed_defns' >> $@
X	@echo '#define _h_ed_defns' >> $@
X	egrep '[FV]_' ed.defns.c | egrep '^#define' >> $@
X	@echo '#endif /* _h_ed_defns */' >> $@
X
sh.err.h: sh.err.c
X	@rm -f $@
X	@echo '/* Do not edit this file, make creates it. */' > $@
X	@echo '#ifndef _h_sh_err' >> $@
X	@echo '#define _h_sh_err' >> $@
X	egrep 'ERR_' sh.err.c | egrep '^#define' >> $@
X	@echo '#endif /* _h_sh_err */' >> $@
X
tc.const.h: tc.const.c sh.char.h config.h config_f.h sh.types.h sh.err.h
X	@rm -f $@
X	@echo '/* Do not edit this file, make creates it. */' > $@
X	${CC} -E $(INCLUDES) ${DFLAGS} tc.const.c | egrep 'Char STR' | \
X	    sed -e 's/Char \([a-zA-Z0-9_]*\)\(.*\)/extern Char \1[];/' | \
X	    sort >> $@
X
csh.prof: ${OBJS} sh.prof.${SUF} mcrt0.${SUF}
X	rm -f csh.prof
X	ld -X mcrt0.${SUF} ${OBJS} -o csh.prof ${LIBES} -lc
X
sh.prof.${SUF}:
X	cp sh.c sh.prof.c
X	${CC} ${CF} ${CFLAGS} -DPROF sh.prof.c
X
lint: tc.const.h ed.defns.h
X	lint ${LFLAGS} sh*.c tw*.c ed*.c tc.*.c ${LIBES}
X
print:
X	@pr READ_ME
X	@pr makefile makefile.*
X	@(size -l a.out; size *.${SUF}) | pr -h SIZES
X	@${CXREF} sh*.c | pr -h XREF
X	@ls -l | pr 
X	@pr sh*.h [a-rt-z]*.h sh*.c alloc.c
X
vprint:
X	@pr -l84 READ_ME TODO
X	@pr -l84 makefile makefile.*
X	@(size -l a.out; size *.${SUF}) | pr -l84 -h SIZES
X	@${CXREF} sh*.c | pr -l84 -h XREF
X	@ls -l | pr -l84
X	@${CXREF} sh*.c | pr -l84 -h XREF
X	@pr -l84 sh*.h [a-rt-z]*.h sh*.c alloc.c
X
vgrind:
X	@cp /dev/null index
X	@for i in *.h; do vgrind -t -h "C Shell" $$i >/crp/bill/csh/$$i.t; done
X	@for i in *.c; do vgrind -t -h "C Shell" $$i >/crp/bill/csh/$$i.t; done
X	@vgrind -t -x -h Index index >/crp/bill/csh/index.t
X
install: tcsh 
X	-mv  ${DESTBIN}/tcsh  ${DESTBIN}/tcsh.old
X	cp tcsh ${DESTBIN}/tcsh
X	strip ${DESTBIN}/tcsh
X	chmod 555 ${DESTBIN}/tcsh
X
manpage: tcsh.man
X	cp tcsh.man ${DESTMAN}/tcsh.${MANSECT}
X	chmod 444 ${DESTMAN}/tcsh.${MANSECT}
X
clean:
X	${RM} -f a.out strings x.c xs.c tcsh _MAKE_LOG core
X	${RM} -f *.${SUF} sh.prof.c ed.defns.h tc.const.h sh.err.h
X
veryclean: clean
X	${RM} -f *~ #*
X
tags:	/tmp
X	${CTAGS} sh*.c
X
tar:
X	rm -f tcsh-${VERSION}.tar.Z
X	rm -rf tcsh-${VERSION} 
X	mkdir tcsh-${VERSION} tcsh-${VERSION}/config
X	cp ${ALLSRCS} tcsh-${VERSION}
X	cp ${CONFSRCS} tcsh-${VERSION}/config
X	tar cvf - tcsh-${VERSION} | compress > tcsh-${VERSION}.tar.Z
X	rm -rf tcsh-${VERSION}
X
shar:	
X	rm -f tcsh-*.shar
X	rm -rf tcsh-${VERSION} 
X	mkdir tcsh-${VERSION} tcsh-${VERSION}/config 
X	cp ${ALLSRCS} tcsh-${VERSION}
X	cp ${CONFSRCS} tcsh-${VERSION}/config
X	MAKESHAR ${VERSION} tcsh-${VERSION}/* tcsh-${VERSION}/config/*
X	rm -rf tcsh-${VERSION}
X
tcsh-${VERSION}.tar.Z:
X	rm -rf tcsh-${VERSION} 
X	rm -f tcsh-${VERSION}.tar tcsh-${VERSION}.tar.Z DIFFS.[123]
X	mkdir tcsh-${VERSION}
X	./MAKEDIFFS bsd
X	mv DIFFS.1 DIFFS.2 DIFFS.3 tcsh-${VERSION}
X	cp ${DISTSRCS} tcsh-${VERSION}
X	mkdir tcsh-${VERSION}/config
X	cp ${CONFSRCS} tcsh-${VERSION}/config
X	cp Makefile tcsh-${VERSION}/Makefile.new
X	tar cvf - tcsh-${VERSION} | compress > tcsh-${VERSION}.tar.Z
X	rm -rf tcsh-${VERSION}
X
tcsh.tahoe-${VERSION}.tar.Z:
X	rm -rf tcsh.tahoe-${VERSION} 
X	rm -f tcsh.tahoe-${VERSION}.tar tcsh.tahoe-${VERSION}.tar.Z DIFFS.[123]
X	mkdir tcsh.tahoe-${VERSION}
X	./MAKEDIFFS tahoe
X	mv DIFFS.1 DIFFS.2 DIFFS.3 tcsh.tahoe-${VERSION}
X	cp ${DISTSRCS} tcsh.tahoe-${VERSION}
X	mkdir tcsh.tahoe-${VERSION}/config
X	cp ${CONFSRCS} tcsh.tahoe-${VERSION}/config
X	cp Makefile tcsh.tahoe-${VERSION}/Makefile.new
X	tar cvf - tcsh.tahoe-${VERSION} | compress > tcsh.tahoe-${VERSION}.tar.Z
X	rm -rf tcsh.tahoe-${VERSION}
X
tcsh.reno-${VERSION}.tar.Z:
X	rm -rf tcsh.reno-${VERSION} 
X	rm -f tcsh.reno-${VERSION}.tar tcsh.reno-${VERSION}.tar.Z DIFFS.[123]
X	mkdir tcsh.reno-${VERSION}
X	./MAKEDIFFS reno
X	mv DIFFS.1 DIFFS.2 DIFFS.3 tcsh.reno-${VERSION}
X	cp ${DISTSRCS} tcsh.reno-${VERSION}
X	mkdir tcsh.reno-${VERSION}/config
X	cp ${CONFSRCS} tcsh.reno-${VERSION}/config
X	cp Makefile tcsh.reno-${VERSION}/Makefile.new
X	tar cvf - tcsh.reno-${VERSION} | compress > tcsh.reno-${VERSION}.tar.Z
X	rm -rf tcsh.reno-${VERSION}
X
ftp: tcsh-${VERSION}.tar.Z tcsh.tahoe-${VERSION}.tar.Z
X	cp tcsh-${VERSION}.tar.Z tcsh.tahoe-${VERSION}.tar.Z ${FTPAREA}
X	cp tcsh.man ${FTPAREA}
X
X#
X# Dependencies
X#
config.h: config_f.h
X
TCH=tc.h tc.const.h tc.decls.h tc.os.h tc.sig.h
SHH=sh.h sh.types.h sh.char.h sh.err.h sh.dir.h sh.proc.h pathnames.h \
X    sh.decls.h ${TCH}
TWH=tw.h tw.decls.h
XEDH=ed.h ed.decls.h
X
X# EDH
XEDINC=sh.${SUF} sh.func.${SUF} sh.lex.${SUF} sh.print.${SUF} sh.proc.${SUF} \
X      sh.set.${SUF} tc.bind.${SUF} tc.os.${SUF} tc.prompt.${SUF} \
X      tc.sched.${SUF} tw.parse.${SUF}
X${EDOBJS} ${EDINC} : ${EDH}
X
X# SHH
X${OBJS}: config.h ${SHH}
X
X# TWH
TWINC=ed.chared.${SUF} ed.inputl.${SUF} sh.exec.${SUF} sh.func.${SUF} \
X      sh.set.${SUF} tc.func.${SUF}
X${TWOBJS} ${TWINC}: ${TWH}
X
X# glob.h
glob.${SUF} sh.glob.${SUF}: glob.h
X
X# ed.defns.h
XEDDINC=tc.bind.${SUF} tc.func.${SUF} tc.os.${SUF}
X${EDOBJS} ${EDDINC}: ed.defns.h
END_OF_FILE
if test 12647 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'sh.decls.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sh.decls.h'\"
else
echo shar: Extracting \"'sh.decls.h'\" \(12518 characters\)
sed "s/^X//" >'sh.decls.h' <<'END_OF_FILE'
X/* $Header: /home/hyperion/mu/christos/src/sys/tcsh-6.01/RCS/sh.decls.h,v 3.7 1991/12/14 20:45:46 christos Exp $ */
X/*
X * sh.decls.h	 External declarations from sh*.c
X */
X/*-
X * Copyright (c) 1980, 1991 The Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by the University of
X *	California, Berkeley and its contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X */
X#ifndef _h_sh_decls
X#define _h_sh_decls
X
X/*
X * sh.c
X */
extern	int	 	  gethdir	__P((Char *));
extern	void		  dosource	__P((Char **, struct command *));
extern	void		  exitstat	__P((void));
extern	void		  goodbye	__P((Char **, struct command *));
extern	void		  importpath	__P((Char *));
extern	void		  initdesc	__P((void));
extern	sigret_t	  pintr		__P((int));
extern	void		  pintr1	__P((bool));
extern	void		  process	__P((bool));
extern	void		  rechist	__P((void));
extern	void		  untty		__P((void));
X#ifdef PROF
extern	void		  done		__P((int));
X#else
extern	void		  xexit		__P((int));
X#endif
X
X/*
X * sh.dir.c
X */
extern	void		  dinit		__P((Char *));
extern	void		  dodirs	__P((Char **, struct command *));
extern	Char		 *dcanon	__P((Char *, Char *));
extern	void		  dtildepr	__P((Char *, Char *));
extern	void		  dtilde	__P((void));
extern	void		  dochngd	__P((Char **, struct command *));
extern	Char		 *dnormalize	__P((Char *));
extern	void		  dopushd	__P((Char **, struct command *));
extern	void		  dopopd	__P((Char **, struct command *));
extern	void		  dfree		__P((struct directory *));
extern	int		  getstakd	__P((Char *, int));
extern	void		  dextract	__P((struct directory *));
X#ifdef	CSHDIRS
extern	void		  recdirs	__P((void));
X#endif
X
X/*
X * sh.dol.c
X */
extern	void		  Dfix		__P((struct command *));
extern	Char		 *Dfix1		__P((Char *));
extern	void		  heredoc	__P((Char *));
X
X/*
X * sh.err.c
X */
extern	void		  seterror	__P((unsigned int, ...));
extern	void		  stderror	__P((unsigned int, ...));
X
X/*
X * sh.exec.c
X */
extern	void		  doexec	__P((struct command *));
extern	void		  dohash	__P((Char **, struct command *));
extern	void		  dounhash	__P((Char **, struct command *));
extern	void		  execash	__P((Char **, struct command *));
X#ifdef VFORK
extern	void		  hashstat	__P((Char **, struct command *));
X#endif
extern	void		  xechoit	__P((Char **));
extern	int		  iscommand	__P((Char *));
extern	int		  executable	__P((Char *, Char *, bool));
extern	void		  tellmewhat	__P((struct wordent *));
extern	void		  dowhere	__P((Char **, struct command *));
X
X/*
X * sh.exp.c
X */
extern	int	 	  expr		__P((Char ***));
extern	int		  exp0		__P((Char ***, bool));
X
X/*
X * sh.file.c
X */
X#ifdef FILEC
extern	int		  tenex		__P((Char *, int));
X#endif
X
X/*
X * sh.func.c
X */
extern	void		  Setenv	__P((Char *, Char *));
extern	void		  Unsetenv	__P((Char *));
extern	void		  doalias	__P((Char **, struct command *));
extern	void		  dobreak	__P((Char **, struct command *));
extern	void		  docontin	__P((Char **, struct command *));
extern	void		  doecho	__P((Char **, struct command *));
extern	void		  doelse	__P((Char **, struct command *));
extern	void		  doend		__P((Char **, struct command *));
extern	void		  doeval	__P((Char **, struct command *));
extern	void		  doexit	__P((Char **, struct command *));
extern	void		  doforeach	__P((Char **, struct command *));
extern	void		  doglob	__P((Char **, struct command *));
extern	void		  dogoto	__P((Char **, struct command *));
extern	void		  doif		__P((Char **, struct command *));
extern	void		  dolimit	__P((Char **, struct command *));
extern	void		  dologin	__P((Char **, struct command *));
extern	void		  dologout	__P((Char **, struct command *));
X#ifdef NEWGRP
extern	void		  donewgrp	__P((Char **, struct command *));
X#endif
extern	void		  donohup	__P((Char **, struct command *));
extern	void		  doonintr	__P((Char **, struct command *));
extern	void		  dorepeat	__P((Char **, struct command *));
extern	void		  dosetenv	__P((Char **, struct command *));
extern	void		  dosuspend	__P((Char **, struct command *));
extern	void		  doswbrk	__P((Char **, struct command *));
extern	void		  doswitch	__P((Char **, struct command *));
extern	void		  doumask	__P((Char **, struct command *));
extern	void		  dounlimit	__P((Char **, struct command *));
extern	void		  dounsetenv	__P((Char **, struct command *));
extern	void		  dowhile	__P((Char **, struct command *));
extern	void		  dozip		__P((Char **, struct command *));
extern	void		  func		__P((struct command *, 
X					     struct biltins *));
extern	void		  gotolab	__P((Char *));
extern struct biltins 	 *isbfunc	__P((struct command *));
extern	void		  prvars	__P((void));
extern	int		  srchx		__P((Char *));
extern	void		  unalias	__P((Char **, struct command *));
extern	void		  wfree		__P((void));
X
X/*
X * sh.glob.c
X */
extern	Char		**dobackp	__P((Char *, bool));
extern	void		  Gcat		__P((Char *, Char *));
extern	Char		 *globone	__P((Char *, int));
extern	int		  Gmatch	__P((Char *, Char *));
extern	void		  ginit		__P((void));
extern	Char		**globall	__P((Char **));
extern	void		  rscan		__P((Char **, void (*)()));
extern	void		  tglob		__P((Char **));
extern	void		  trim		__P((Char **));
X#ifdef FILEC
extern	int		  sortscmp	__P((Char **, Char **));
X#endif
X
X/*
X * sh.hist.c
X */
extern	void	 	  dohist	__P((Char **, struct command *));
extern struct Hist 	 *enthist	__P((int, struct wordent *, bool));
extern	void	 	  savehist	__P((struct wordent *));
X
X
X/*
X * sh.lex.c
X */
extern	void		  addla		__P((Char *));
extern	void		  bseek		__P((struct Ain *));
extern	void		  btell		__P((struct Ain *));
extern	void		  btoeof	__P((void));
extern	void		  copylex	__P((struct wordent *, 
X					     struct wordent *));
extern	Char		 *domod		__P((Char *, int));
extern	void		  freelex	__P((struct wordent *));
extern	int		  lex		__P((struct wordent *));
extern	void		  prlex		__P((struct wordent *));
extern	int		  readc		__P((bool));
extern	void		  settell	__P((void));
extern	void		  unreadc	__P((int));
X
X
X/*
X * sh.misc.c
X */
extern	int		  any		__P((char *, int));
extern	Char		**blkcat	__P((Char **, Char **));
extern	Char		**blkcpy	__P((Char **, Char **));
extern	Char		**blkend	__P((Char **));
extern	void		  blkfree	__P((Char **));
extern	int		  blklen	__P((Char **));
extern	void		  blkpr		__P((Char **));
extern	Char		**blkspl	__P((Char **, Char **));
X#ifndef copy
extern  void		  copy		__P((char *, char *, int));
X#endif
extern	void		  closem	__P((void));
X#ifndef FIOCLEX
extern  void 		  closech	__P((void));
X#endif
extern	Char		**copyblk	__P((Char **));
extern	int		  dcopy		__P((int, int));
extern	int		  dmove		__P((int, int));
extern	void		  donefds	__P((void));
extern	Char		  lastchr	__P((Char *));
extern	void		  lshift	__P((Char **, int));
extern	int		  number	__P((Char *));
extern	int		  prefix	__P((Char *, Char *));
extern	Char		**saveblk	__P((Char **));
extern	void		  setzero	__P((char *, int));
extern	Char		 *strip		__P((Char *));
extern	char		 *strsave	__P((const char *));
extern	char		 *strspl	__P((char *, char *));
X#ifndef POSIX
extern  char   	  	 *strstr	__P((const char *, const char *));
X#endif
extern	void		  udvar		__P((Char *));
X#ifndef SHORT_STRINGS
extern	char		 *strend	__P((char *));
X#endif
X
X/*
X * sh.parse.c
X */
extern	void		  alias		__P((struct wordent *));
extern	void		  freesyn	__P((struct command *));
extern struct command 	 *syntax	__P((struct wordent *, 
X					     struct wordent *, int));
X
X/*
X * sh.print.c
X */
extern	void		  draino	__P((void));
extern	void		  flush		__P((void));
X#ifdef BSDTIMES
extern	void		  pcsecs	__P((long));
X#else /* !BSDTIMES */
X# ifdef POSIX
extern	void		  pcsecs	__P((clock_t));
X# else /* !POSIX */
extern	void		  pcsecs	__P((time_t));
X# endif /* !POSIX */
X#endif /* BSDTIMES */
X#ifdef RLIMIT_CPU
extern	void		  psecs		__P((long));
X#endif /* RLIMIT_CPU */
extern	int		  putpure	__P((int));
extern	int		  putraw	__P((int));
extern	void		  xputchar	__P((int));
X
X
X/*
X * sh.proc.c
X */
extern	void		  dobg		__P((Char **, struct command *));
extern	void		  dobg1		__P((Char **, struct command *));
extern	void		  dofg		__P((Char **, struct command *));
extern	void		  dofg1		__P((Char **, struct command *));
extern	void		  dojobs	__P((Char **, struct command *));
extern	void		  dokill	__P((Char **, struct command *));
extern	void		  donotify	__P((Char **, struct command *));
extern	void		  dostop	__P((Char **, struct command *));
extern	void		  dowait	__P((Char **, struct command *));
extern	void		  palloc	__P((int, struct command *));
extern	void		  panystop	__P((bool));
extern	sigret_t	  pchild	__P((int));
extern	void		  pendjob	__P((void));
extern	struct process 	 *pfind		__P((Char *));
extern	int		  pfork		__P((struct command *, int));
extern	void		  pgetty	__P((int, int));
extern	void		  pjwait	__P((struct process *));
extern	void		  pnote		__P((void));
extern	void		  prestjob	__P((void));
extern	void		  psavejob	__P((void));
extern	void		  pstart	__P((struct process *, int));
extern	void		  pwait		__P((void));
X
X/*
X * sh.sem.c
X */
extern	void		  execute	__P((struct command *, int, int *, 
X					     int *));
extern	void		  mypipe	__P((int *));
X
X/*
X * sh.set.c
X */
extern	struct varent 	 *adrof1	__P((Char *, struct varent *));
extern	void		  doset		__P((Char **, struct command *));
extern	void		  dolet		__P((Char **, struct command *));
extern	Char		 *putn		__P((int));
extern	int		  getn		__P((Char *));
extern	Char		 *value1	__P((Char *, struct varent *));
extern	void		  set		__P((Char *, Char *));
extern	void		  set1		__P((Char *, Char **, struct varent *));
extern	void		  setq		__P((Char *, Char **, struct varent *));
extern	void		  unset		__P((Char **, struct command *));
extern	void		  unset1	__P((Char *[], struct varent *));
extern	void		  unsetv	__P((Char *));
extern	void		  setNS		__P((Char *));
extern	void		  shift		__P((Char **, struct command *));
extern	void		  plist		__P((struct varent *));
X
X/*
X * sh.time.c
X */
extern	void		  donice	__P((Char **, struct command *));
extern	void		  dotime	__P((Char **, struct command *));
X#ifdef BSDTIMES
extern	void		  prusage	__P((struct rusage *, struct rusage *, 
X					     timeval_t *, timeval_t *));
X#else /* BSDTIMES */
X# ifdef _SEQUENT_
extern	void		  prusage	__P((struct process_stats *,
X					     struct process_stats *, 
X					     timeval_t *, timeval_t *));
X# else /* !_SEQUENT_ */
X#  ifdef POSIX
extern	void		  prusage	__P((struct tms *, struct tms *, 
X					     clock_t, clock_t));
X#  else	/* !POSIX */
extern	void		  prusage	__P((struct tms *, struct tms *, 
X					     time_t, time_t));
X#  endif /* !POSIX */
X# endif	/* !_SEQUENT_ */
X#endif /* BSDTIMES */
extern	void		  settimes	__P((void));
X#if defined(BSDTIMES) || defined(_SEQUENT_)
extern	void		  ruadd		__P((struct rusage *, struct rusage *));
extern	void		  tvadd		__P((struct timeval *, 
X					     struct timeval *));
extern	void		  tvsub		__P((struct timeval *, 
X					     struct timeval *, 
X					     struct timeval *));
X#endif /* BSDTIMES || _SEQUENT_ */
X
X#endif /* _h_sh_decls */
END_OF_FILE
if test 12518 -ne `wc -c <'sh.decls.h'`; then
    echo shar: \"'sh.decls.h'\" unpacked with wrong size!
fi
# end of 'sh.decls.h'
fi
if test -f 'sh.exp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sh.exp.c'\"
else
echo shar: Extracting \"'sh.exp.c'\" \(14067 characters\)
sed "s/^X//" >'sh.exp.c' <<'END_OF_FILE'
X/* $Header: /home/hyperion/mu/christos/src/sys/tcsh-6.01/RCS/sh.exp.c,v 3.5 1991/11/11 01:56:34 christos Exp $ */
X/*
X * sh.exp.c: Expression evaluations
X */
X/*-
X * Copyright (c) 1980, 1991 The Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by the University of
X *	California, Berkeley and its contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X */
X#include "sh.h"
X
RCSID("$Id: sh.exp.c,v 3.5 1991/11/11 01:56:34 christos Exp $")
X
X/*
X * C shell
X */
X
X#define IGNORE	1	/* in ignore, it means to ignore value, just parse */
X#define NOGLOB	2	/* in ignore, it means not to globone */
X
X#define	ADDOP	1
X#define	MULOP	2
X#define	EQOP	4
X#define	RELOP	8
X#define	RESTOP	16
X#define	ANYOP	31
X
X#define	EQEQ	1
X#define	GTR	2
X#define	LSS	4
X#define	NOTEQ	6
X#define EQMATCH 7
X#define NOTEQMATCH 8
X
static	int	 exp1	__P((Char ***, bool));
static	int	 exp2	__P((Char ***, bool));
static	int	 exp2a	__P((Char ***, bool));
static	int	 exp2b	__P((Char ***, bool));
static	int	 exp2c	__P((Char ***, bool));
static	Char 	*exp3	__P((Char ***, bool));
static	Char 	*exp3a	__P((Char ***, bool));
static	Char 	*exp4	__P((Char ***, bool));
static	Char 	*exp5	__P((Char ***, bool));
static	Char 	*exp6	__P((Char ***, bool));
static	void	 evalav	__P((Char **));
static	int	 isa	__P((Char *, int));
static	int	 egetn	__P((Char *));
X
X#ifdef EDEBUG
static	void	 etracc	__P((char *, Char *, Char ***));
static	void	 etraci	__P((char *, int, Char ***));
X#endif
X
int
expr(vp)
X    register Char ***vp;
X{
X    return (exp0(vp, 0));
X}
X
int
exp0(vp, ignore)
X    register Char ***vp;
X    bool    ignore;
X{
X    register int p1 = exp1(vp, ignore);
X
X#ifdef EDEBUG
X    etraci("exp0 p1", p1, vp);
X#endif
X    if (**vp && eq(**vp, STRor2)) {
X	register int p2;
X
X	(*vp)++;
X	p2 = exp0(vp, (ignore & IGNORE) || p1);
X#ifdef EDEBUG
X	etraci("exp0 p2", p2, vp);
X#endif
X	return (p1 || p2);
X    }
X    return (p1);
X}
X
static int
exp1(vp, ignore)
X    register Char ***vp;
X    bool    ignore;
X{
X    register int p1 = exp2(vp, ignore);
X
X#ifdef EDEBUG
X    etraci("exp1 p1", p1, vp);
X#endif
X    if (**vp && eq(**vp, STRand2)) {
X	register int p2;
X
X	(*vp)++;
X	p2 = exp1(vp, (ignore & IGNORE) || !p1);
X#ifdef EDEBUG
X	etraci("exp1 p2", p2, vp);
X#endif
X	return (p1 && p2);
X    }
X    return (p1);
X}
X
static int
exp2(vp, ignore)
X    register Char ***vp;
X    bool    ignore;
X{
X    register int p1 = exp2a(vp, ignore);
X
X#ifdef EDEBUG
X    etraci("exp3 p1", p1, vp);
X#endif
X    if (**vp && eq(**vp, STRor)) {
X	register int p2;
X
X	(*vp)++;
X	p2 = exp2(vp, ignore);
X#ifdef EDEBUG
X	etraci("exp3 p2", p2, vp);
X#endif
X	return (p1 | p2);
X    }
X    return (p1);
X}
X
static int
exp2a(vp, ignore)
X    register Char ***vp;
X    bool    ignore;
X{
X    register int p1 = exp2b(vp, ignore);
X
X#ifdef EDEBUG
X    etraci("exp2a p1", p1, vp);
X#endif
X    if (**vp && eq(**vp, STRcaret)) {
X	register int p2;
X
X	(*vp)++;
X	p2 = exp2a(vp, ignore);
X#ifdef EDEBUG
X	etraci("exp2a p2", p2, vp);
X#endif
X	return (p1 ^ p2);
X    }
X    return (p1);
X}
X
static int
exp2b(vp, ignore)
X    register Char ***vp;
X    bool    ignore;
X{
X    register int p1 = exp2c(vp, ignore);
X
X#ifdef EDEBUG
X    etraci("exp2b p1", p1, vp);
X#endif
X    if (**vp && eq(**vp, STRand)) {
X	register int p2;
X
X	(*vp)++;
X	p2 = exp2b(vp, ignore);
X#ifdef EDEBUG
X	etraci("exp2b p2", p2, vp);
X#endif
X	return (p1 & p2);
X    }
X    return (p1);
X}
X
static int
exp2c(vp, ignore)
X    register Char ***vp;
X    bool    ignore;
X{
X    register Char *p1 = exp3(vp, ignore);
X    register Char *p2;
X    register int i;
X
X#ifdef EDEBUG
X    etracc("exp2c p1", p1, vp);
X#endif
X    if (i = isa(**vp, EQOP)) {
X	(*vp)++;
X	if (i == EQMATCH || i == NOTEQMATCH)
X	    ignore |= NOGLOB;
X	p2 = exp3(vp, ignore);
X#ifdef EDEBUG
X	etracc("exp2c p2", p2, vp);
X#endif
X	if (!(ignore & IGNORE))
X	    switch (i) {
X
X	    case EQEQ:
X		i = eq(p1, p2);
X		break;
X
X	    case NOTEQ:
X		i = !eq(p1, p2);
X		break;
X
X	    case EQMATCH:
X		i = Gmatch(p1, p2);
X		break;
X
X	    case NOTEQMATCH:
X		i = !Gmatch(p1, p2);
X		break;
X	    }
X	xfree((ptr_t) p1);
X	xfree((ptr_t) p2);
X	return (i);
X    }
X    i = egetn(p1);
X    xfree((ptr_t) p1);
X    return (i);
X}
X
static Char *
exp3(vp, ignore)
X    register Char ***vp;
X    bool    ignore;
X{
X    register Char *p1, *p2;
X    register int i;
X
X    p1 = exp3a(vp, ignore);
X#ifdef EDEBUG
X    etracc("exp3 p1", p1, vp);
X#endif
X    if (i = isa(**vp, RELOP)) {
X	(*vp)++;
X	if (**vp && eq(**vp, STRequal))
X	    i |= 1, (*vp)++;
X	p2 = exp3(vp, ignore);
X#ifdef EDEBUG
X	etracc("exp3 p2", p2, vp);
X#endif
X	if (!(ignore & IGNORE))
X	    switch (i) {
X
X	    case GTR:
X		i = egetn(p1) > egetn(p2);
X		break;
X
X	    case GTR | 1:
X		i = egetn(p1) >= egetn(p2);
X		break;
X
X	    case LSS:
X		i = egetn(p1) < egetn(p2);
X		break;
X
X	    case LSS | 1:
X		i = egetn(p1) <= egetn(p2);
X		break;
X	    }
X	xfree((ptr_t) p1);
X	xfree((ptr_t) p2);
X	return (putn(i));
X    }
X    return (p1);
X}
X
static Char *
exp3a(vp, ignore)
X    register Char ***vp;
X    bool    ignore;
X{
X    register Char *p1, *p2, *op;
X    register int i;
X
X    p1 = exp4(vp, ignore);
X#ifdef EDEBUG
X    etracc("exp3a p1", p1, vp);
X#endif
X    op = **vp;
X    if (op && any("<>", op[0]) && op[0] == op[1]) {
X	(*vp)++;
X	p2 = exp3a(vp, ignore);
X#ifdef EDEBUG
X	etracc("exp3a p2", p2, vp);
X#endif
X	if (op[0] == '<')
X	    i = egetn(p1) << egetn(p2);
X	else
X	    i = egetn(p1) >> egetn(p2);
X	xfree((ptr_t) p1);
X	xfree((ptr_t) p2);
X	return (putn(i));
X    }
X    return (p1);
X}
X
static Char *
exp4(vp, ignore)
X    register Char ***vp;
X    bool    ignore;
X{
X    register Char *p1, *p2;
X    register int i = 0;
X
X    p1 = exp5(vp, ignore);
X#ifdef EDEBUG
X    etracc("exp4 p1", p1, vp);
X#endif
X    if (isa(**vp, ADDOP)) {
X	register Char *op = *(*vp)++;
X
X	p2 = exp4(vp, ignore);
X#ifdef EDEBUG
X	etracc("exp4 p2", p2, vp);
X#endif
X	if (!(ignore & IGNORE))
X	    switch (op[0]) {
X
X	    case '+':
X		i = egetn(p1) + egetn(p2);
X		break;
X
X	    case '-':
X		i = egetn(p1) - egetn(p2);
X		break;
X	    }
X	xfree((ptr_t) p1);
X	xfree((ptr_t) p2);
X	return (putn(i));
X    }
X    return (p1);
X}
X
static Char *
exp5(vp, ignore)
X    register Char ***vp;
X    bool    ignore;
X{
X    register Char *p1, *p2;
X    register int i = 0;
X
X    p1 = exp6(vp, ignore);
X#ifdef EDEBUG
X    etracc("exp5 p1", p1, vp);
X#endif
X    if (isa(**vp, MULOP)) {
X	register Char *op = *(*vp)++;
X
X	p2 = exp5(vp, ignore);
X#ifdef EDEBUG
X	etracc("exp5 p2", p2, vp);
X#endif
X	if (!(ignore & IGNORE))
X	    switch (op[0]) {
X
X	    case '*':
X		i = egetn(p1) * egetn(p2);
X		break;
X
X	    case '/':
X		i = egetn(p2);
X		if (i == 0)
X		    stderror(ERR_DIV0);
X		i = egetn(p1) / i;
X		break;
X
X	    case '%':
X		i = egetn(p2);
X		if (i == 0)
X		    stderror(ERR_MOD0);
X		i = egetn(p1) % i;
X		break;
X	    }
X	xfree((ptr_t) p1);
X	xfree((ptr_t) p2);
X	return (putn(i));
X    }
X    return (p1);
X}
X
static Char *
exp6(vp, ignore)
X    register Char ***vp;
X    bool    ignore;
X{
X    int     ccode, i = 0;
X    register Char *cp, *dp, *ep;
X
X    if (**vp == 0)
X	stderror(ERR_NAME | ERR_EXPRESSION);
X    if (eq(**vp, STRbang)) {
X	(*vp)++;
X	cp = exp6(vp, ignore);
X#ifdef EDEBUG
X	etracc("exp6 ! cp", cp, vp);
X#endif
X	i = egetn(cp);
X	xfree((ptr_t) cp);
X	return (putn(!i));
X    }
X    if (eq(**vp, STRtilde)) {
X	(*vp)++;
X	cp = exp6(vp, ignore);
X#ifdef EDEBUG
X	etracc("exp6 ~ cp", cp, vp);
X#endif
X	i = egetn(cp);
X	xfree((ptr_t) cp);
X	return (putn(~i));
X    }
X    if (eq(**vp, STRLparen)) {
X	(*vp)++;
X	ccode = exp0(vp, ignore);
X#ifdef EDEBUG
X	etraci("exp6 () ccode", ccode, vp);
X#endif
X	if (*vp == 0 || **vp == 0 || ***vp != ')')
X	    stderror(ERR_NAME | ERR_EXPRESSION);
X	(*vp)++;
X	return (putn(ccode));
X    }
X    if (eq(**vp, STRLbrace)) {
X	register Char **v;
X	struct command faket;
X	Char   *fakecom[2];
X
X	faket.t_dtyp = NODE_COMMAND;
X	faket.t_dflg = 0;
X	faket.t_dcar = faket.t_dcdr = faket.t_dspr = NULL;
X	faket.t_dcom = fakecom;
X	fakecom[0] = STRfakecom;
X	fakecom[1] = NULL;
X	(*vp)++;
X	v = *vp;
X	for (;;) {
X	    if (!**vp)
X		stderror(ERR_NAME | ERR_MISSING, '}');
X	    if (eq(*(*vp)++, STRRbrace))
X		break;
X	}
X	if (ignore & IGNORE)
X	    return (Strsave(STRNULL));
X	psavejob();
X	if (pfork(&faket, -1) == 0) {
X	    *--(*vp) = 0;
X	    evalav(v);
X	    exitstat();
X	}
X	pwait();
X	prestjob();
X#ifdef EDEBUG
X	etraci("exp6 {} status", egetn(value(STRstatus)), vp);
X#endif
X	return (putn(egetn(value(STRstatus)) == 0));
X    }
X    if (isa(**vp, ANYOP))
X	return (Strsave(STRNULL));
X    cp = *(*vp)++;
X    if (*cp == '-' && any("erwxfdzoplst", cp[1])) {
X	struct stat stb;
X
X	if (cp[2] != '\0')
X	    stderror(ERR_NAME | ERR_FILEINQ);
X	/*
X	 * Detect missing file names by checking for operator in the file name
X	 * position.  However, if an operator name appears there, we must make
X	 * sure that there's no file by that name (e.g., "/") before announcing
X	 * an error.  Even this check isn't quite right, since it doesn't take
X	 * globbing into account.
X	 */
X	if (isa(**vp, ANYOP) && stat(short2str(**vp), &stb))
X	    stderror(ERR_NAME | ERR_FILENAME);
X
X	dp = *(*vp)++;
X	if (ignore & IGNORE)
X	    return (Strsave(STRNULL));
X	ep = globone(dp, G_ERROR);
X	switch (cp[1]) {
X
X	case 'r':
X	    i = !access(short2str(ep), R_OK);
X	    break;
X
X	case 'w':
X	    i = !access(short2str(ep), W_OK);
X	    break;
X
X	case 'x':
X	    i = !access(short2str(ep), X_OK);
X	    break;
X
X	case 't':	/* SGI extension, true when file is a tty */
X	    {
X		int fd;
X
X		if ((fd = open(short2str(ep), O_RDONLY)) == -1)
X		    i = 0;
X		else {
X		    i = isatty(fd);
X		    (void) close(fd);
X		}
X	    }
X	    break;
X
X	default:
X	    if (
X#ifdef S_IFLNK
X		cp[1] == 'l' ? lstat(short2str(ep), &stb) :
X#endif
X		stat(short2str(ep), &stb)) {
X		xfree((ptr_t) ep);
X		return (Strsave(STR0));
X	    }
X	    switch (cp[1]) {
X
X	    case 'f':
X		i = S_ISREG(stb.st_mode);
X		break;
X
X	    case 'd':
X		i = S_ISDIR(stb.st_mode);
X		break;
X
X	    case 'p':
X#ifdef S_ISFIFO
X		i = S_ISFIFO(stb.st_mode);
X#else
X		i = 0;
X#endif
X		break;
X
X	    case 'l':
X#ifdef S_ISLNK
X		i = S_ISLNK(stb.st_mode);
X#else
X		i = 0;
X#endif
X		break;
X
X	    case 's':
X#ifdef S_ISSOCK
X		i = S_ISSOCK(stb.st_mode);
X#else
X		i = 0;
X#endif
X		break;
X
X	    case 'z':
X		i = stb.st_size == 0;
X		break;
X
X	    case 'e':
X		i = 1;
X		break;
X
X	    case 'o':
X		i = stb.st_uid == uid;
X		break;
X	    }
X	}
X#ifdef EDEBUG
X	etraci("exp6 -? i", i, vp);
X#endif
X	xfree((ptr_t) ep);
X	return (putn(i));
X    }
X#ifdef EDEBUG
X    etracc("exp6 default", cp, vp);
X#endif
X    return (ignore & NOGLOB ? Strsave(cp) : globone(cp, G_ERROR));
X}
X
static void
evalav(v)
X    register Char **v;
X{
X    struct wordent paraml1;
X    register struct wordent *hp = &paraml1;
X    struct command *t;
X    register struct wordent *wdp = hp;
X
X    set(STRstatus, Strsave(STR0));
X    hp->prev = hp->next = hp;
X    hp->word = STRNULL;
X    while (*v) {
X	register struct wordent *new =
X	(struct wordent *) xcalloc(1, sizeof *wdp);
X
X	new->prev = wdp;
X	new->next = hp;
X	wdp->next = new;
X	wdp = new;
X	wdp->word = Strsave(*v++);
X    }
X    hp->prev = wdp;
X    alias(&paraml1);
X    t = syntax(paraml1.next, &paraml1, 0);
X    if (seterr)
X	stderror(ERR_OLD);
X    execute(t, -1, NULL, NULL);
X    freelex(&paraml1), freesyn(t);
X}
X
static int
isa(cp, what)
X    register Char *cp;
X    register int what;
X{
X    if (cp == 0)
X	return ((what & RESTOP) != 0);
X    if (cp[1] == 0) {
X	if (what & ADDOP && (*cp == '+' || *cp == '-'))
X	    return (1);
X	if (what & MULOP && (*cp == '*' || *cp == '/' || *cp == '%'))
X	    return (1);
X	if (what & RESTOP && (*cp == '(' || *cp == ')' || *cp == '!' ||
X			      *cp == '~' || *cp == '^' || *cp == '"'))
X	    return (1);
X    }
X    else if (cp[2] == 0) {
X	if (what & RESTOP) {
X	    if (cp[0] == '|' && cp[1] == '&')
X		return (1);
X	    if (cp[0] == '<' && cp[1] == '<')
X		return (1);
X	    if (cp[0] == '>' && cp[1] == '>')
X		return (1);
X	}
X	if (what & EQOP) {
X	    if (cp[0] == '=') {
X		if (cp[1] == '=')
X		    return (EQEQ);
X		if (cp[1] == '~')
X		    return (EQMATCH);
X	    }
X	    else if (cp[0] == '!') {
X		if (cp[1] == '=')
X		    return (NOTEQ);
X		if (cp[1] == '~')
X		    return (NOTEQMATCH);
X	    }
X	}
X    }
X    if (what & RELOP) {
X	if (*cp == '<')
X	    return (LSS);
X	if (*cp == '>')
X	    return (GTR);
X    }
X    return (0);
X}
X
static int
egetn(cp)
X    register Char *cp;
X{
X    if (*cp && *cp != '-' && !Isdigit(*cp))
X	stderror(ERR_NAME | ERR_EXPRESSION);
X    return (getn(cp));
X}
X
X/* Phew! */
X
X#ifdef EDEBUG
static void
etraci(str, i, vp)
X    char   *str;
X    int     i;
X    Char ***vp;
X{
X    xprintf("%s=%d\t", str, i);
X    blkpr(*vp);
X    xprintf("\n");
X}
static void
etracc(str, cp, vp)
X    char   *str;
X    Char   *cp;
X    Char ***vp;
X{
X    xprintf("%s=%s\t", str, cp);
X    blkpr(*vp);
X    xprintf("\n");
X}
X#endif
END_OF_FILE
if test 14067 -ne `wc -c <'sh.exp.c'`; then
    echo shar: \"'sh.exp.c'\" unpacked with wrong size!
fi
# end of 'sh.exp.c'
fi
if test -f 'sh.parse.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sh.parse.c'\"
else
echo shar: Extracting \"'sh.parse.c'\" \(14172 characters\)
sed "s/^X//" >'sh.parse.c' <<'END_OF_FILE'
X/* $Header: /home/hyperion/mu/christos/src/sys/tcsh-6.01/RCS/sh.parse.c,v 3.5 1991/11/26 04:41:23 christos Exp $ */
X/*
X * sh.parse.c: Interpret a list of tokens
X */
X/*-
X * Copyright (c) 1980, 1991 The Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by the University of
X *	California, Berkeley and its contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X */
X#include "sh.h"
X
RCSID("$Id: sh.parse.c,v 3.5 1991/11/26 04:41:23 christos Exp $")
X
X/*
X * C shell
X */
static	void		 asyntax __P((struct wordent *, struct wordent *));
static	void		 asyn0 	 __P((struct wordent *, struct wordent *));
static	void		 asyn3	 __P((struct wordent *, struct wordent *));
static	struct wordent	*freenod __P((struct wordent *, struct wordent *));
static	struct command	*syn0	 __P((struct wordent *, struct wordent *, int));
static	struct command	*syn1	 __P((struct wordent *, struct wordent *, int));
static	struct command	*syn1a	 __P((struct wordent *, struct wordent *, int));
static	struct command	*syn1b	 __P((struct wordent *, struct wordent *, int));
static	struct command	*syn2	 __P((struct wordent *, struct wordent *, int));
static	struct command	*syn3	 __P((struct wordent *, struct wordent *, int));
X
X#define ALEFT	51		/* max of 50 alias expansions	 */
X#define HLEFT	11		/* max of 10 history expansions */
X/*
X * Perform aliasing on the word list lex
X * Do a (very rudimentary) parse to separate into commands.
X * If word 0 of a command has an alias, do it.
X * Repeat a maximum of 50 times.
X */
static int aleft;
extern int hleft;
void
alias(lex)
X    register struct wordent *lex;
X{
X    jmp_buf osetexit;
X
X    aleft = ALEFT;
X    hleft = HLEFT;
X    getexit(osetexit);
X    (void) setexit();
X    if (haderr) {
X	resexit(osetexit);
X	reset();
X    }
X    if (--aleft == 0)
X	stderror(ERR_ALIASLOOP);
X    asyntax(lex->next, lex);
X    resexit(osetexit);
X}
X
static void
asyntax(p1, p2)
X    register struct wordent *p1, *p2;
X{
X    while (p1 != p2)
X	if (any(";&\n", p1->word[0]))
X	    p1 = p1->next;
X	else {
X	    asyn0(p1, p2);
X	    return;
X	}
X}
X
static void
asyn0(p1, p2)
X    struct wordent *p1;
X    register struct wordent *p2;
X{
X    register struct wordent *p;
X    register int l = 0;
X
X    for (p = p1; p != p2; p = p->next)
X	switch (p->word[0]) {
X
X	case '(':
X	    l++;
X	    continue;
X
X	case ')':
X	    l--;
X	    if (l < 0)
X		stderror(ERR_TOOMANYRP);
X	    continue;
X
X	case '>':
X	    if (p->next != p2 && eq(p->next->word, STRand))
X		p = p->next;
X	    continue;
X
X	case '&':
X	case '|':
X	case ';':
X	case '\n':
X	    if (l != 0)
X		continue;
X	    asyn3(p1, p);
X	    asyntax(p->next, p2);
X	    return;
X
X	default:
X	    break;
X	}
X    if (l == 0)
X	asyn3(p1, p2);
X}
X
static void
asyn3(p1, p2)
X    struct wordent *p1;
X    register struct wordent *p2;
X{
X    register struct varent *ap;
X    struct wordent alout;
X    register bool redid;
X
X    if (p1 == p2)
X	return;
X    if (p1->word[0] == '(') {
X	for (p2 = p2->prev; p2->word[0] != ')'; p2 = p2->prev)
X	    if (p2 == p1)
X		return;
X	if (p2 == p1->next)
X	    return;
X	asyn0(p1->next, p2);
X	return;
X    }
X    ap = adrof1(p1->word, &aliases);
X    if (ap == 0)
X	return;
X    alhistp = p1->prev;
X    alhistt = p2;
X    alvec = ap->vec;
X    redid = lex(&alout);
X    alhistp = alhistt = 0;
X    alvec = 0;
X    if (seterr) {
X	freelex(&alout);
X	stderror(ERR_OLD);
X    }
X    if (p1->word[0] && eq(p1->word, alout.next->word)) {
X	Char   *cp = alout.next->word;
X
X	alout.next->word = Strspl(STRQNULL, cp);
X	xfree((ptr_t) cp);
X    }
X    p1 = freenod(p1, redid ? p2 : p1->next);
X    if (alout.next != &alout) {
X	p1->next->prev = alout.prev->prev;
X	alout.prev->prev->next = p1->next;
X	alout.next->prev = p1;
X	p1->next = alout.next;
X	xfree((ptr_t) alout.prev->word);
X	xfree((ptr_t) (alout.prev));
X    }
X    reset();			/* throw! */
X}
X
static struct wordent *
freenod(p1, p2)
X    register struct wordent *p1, *p2;
X{
X    register struct wordent *retp = p1->prev;
X
X    while (p1 != p2) {
X	xfree((ptr_t) p1->word);
X	p1 = p1->next;
X	xfree((ptr_t) (p1->prev));
X    }
X    retp->next = p2;
X    p2->prev = retp;
X    return (retp);
X}
X
X#define	P_HERE	1
X#define	P_IN	2
X#define	P_OUT	4
X#define	P_DIAG	8
X
X/*
X * syntax
X *	empty
X *	syn0
X */
struct command *
syntax(p1, p2, flags)
X    register struct wordent *p1, *p2;
X    int     flags;
X{
X
X    while (p1 != p2)
X	if (any(";&\n", p1->word[0]))
X	    p1 = p1->next;
X	else
X	    return (syn0(p1, p2, flags));
X    return (0);
X}
X
X/*
X * syn0
X *	syn1
X *	syn1 & syntax
X */
static struct command *
syn0(p1, p2, flags)
X    struct wordent *p1, *p2;
X    int     flags;
X{
X    register struct wordent *p;
X    register struct command *t, *t1;
X    int     l;
X
X    l = 0;
X    for (p = p1; p != p2; p = p->next)
X	switch (p->word[0]) {
X
X	case '(':
X	    l++;
X	    continue;
X
X	case ')':
X	    l--;
X	    if (l < 0)
X		seterror(ERR_TOOMANYRP);
X	    continue;
X
X	case '|':
X	    if (p->word[1] == '|')
X		continue;
X	    /* fall into ... */
X
X	case '>':
X	    if (p->next != p2 && eq(p->next->word, STRand))
X		p = p->next;
X	    continue;
X
X	case '&':
X	    if (l != 0)
X		break;
X	    if (p->word[1] == '&')
X		continue;
X	    t1 = syn1(p1, p, flags);
X	    if (t1->t_dtyp == NODE_LIST ||
X		t1->t_dtyp == NODE_AND ||
X		t1->t_dtyp == NODE_OR) {
X		t = (struct command *) xcalloc(1, sizeof(*t));
X		t->t_dtyp = NODE_PAREN;
X		t->t_dflg = F_AMPERSAND | F_NOINTERRUPT;
X		t->t_dspr = t1;
X		t1 = t;
X	    }
X	    else
X		t1->t_dflg |= F_AMPERSAND | F_NOINTERRUPT;
X	    t = (struct command *) xcalloc(1, sizeof(*t));
X	    t->t_dtyp = NODE_LIST;
X	    t->t_dflg = 0;
X	    t->t_dcar = t1;
X	    t->t_dcdr = syntax(p, p2, flags);
X	    return (t);
X	default:
X	    break;
X	}
X    if (l == 0)
X	return (syn1(p1, p2, flags));
X    seterror(ERR_TOOMANYLP);
X    return (0);
X}
X
X/*
X * syn1
X *	syn1a
X *	syn1a ; syntax
X */
static struct command *
syn1(p1, p2, flags)
X    struct wordent *p1, *p2;
X    int     flags;
X{
X    register struct wordent *p;
X    register struct command *t;
X    int     l;
X
X    l = 0;
X    for (p = p1; p != p2; p = p->next)
X	switch (p->word[0]) {
X
X	case '(':
X	    l++;
X	    continue;
X
X	case ')':
X	    l--;
X	    continue;
X
X	case ';':
X	case '\n':
X	    if (l != 0)
X		break;
X	    t = (struct command *) xcalloc(1, sizeof(*t));
X	    t->t_dtyp = NODE_LIST;
X	    t->t_dcar = syn1a(p1, p, flags);
X	    t->t_dcdr = syntax(p->next, p2, flags);
X	    if (t->t_dcdr == 0)
X		t->t_dcdr = t->t_dcar, t->t_dcar = 0;
X	    return (t);
X
X	default:
X	    break;
X	}
X    return (syn1a(p1, p2, flags));
X}
X
X/*
X * syn1a
X *	syn1b
X *	syn1b || syn1a
X */
static struct command *
syn1a(p1, p2, flags)
X    struct wordent *p1, *p2;
X    int     flags;
X{
X    register struct wordent *p;
X    register struct command *t;
X    register int l = 0;
X
X    for (p = p1; p != p2; p = p->next)
X	switch (p->word[0]) {
X
X	case '(':
X	    l++;
X	    continue;
X
X	case ')':
X	    l--;
X	    continue;
X
X	case '|':
X	    if (p->word[1] != '|')
X		continue;
X	    if (l == 0) {
X		t = (struct command *) xcalloc(1, sizeof(*t));
X		t->t_dtyp = NODE_OR;
X		t->t_dcar = syn1b(p1, p, flags);
X		t->t_dcdr = syn1a(p->next, p2, flags);
X		t->t_dflg = 0;
X		return (t);
X	    }
X	    continue;
X
X	default:
X	    break;
X	}
X    return (syn1b(p1, p2, flags));
X}
X
X/*
X * syn1b
X *	syn2
X *	syn2 && syn1b
X */
static struct command *
syn1b(p1, p2, flags)
X    struct wordent *p1, *p2;
X    int     flags;
X{
X    register struct wordent *p;
X    register struct command *t;
X    register int l = 0;
X
X    for (p = p1; p != p2; p = p->next)
X	switch (p->word[0]) {
X
X	case '(':
X	    l++;
X	    continue;
X
X	case ')':
X	    l--;
X	    continue;
X
X	case '&':
X	    if (p->word[1] == '&' && l == 0) {
X		t = (struct command *) xcalloc(1, sizeof(*t));
X		t->t_dtyp = NODE_AND;
X		t->t_dcar = syn2(p1, p, flags);
X		t->t_dcdr = syn1b(p->next, p2, flags);
X		t->t_dflg = 0;
X		return (t);
X	    }
X	    continue;
X
X	default:
X	    break;
X	}
X    return (syn2(p1, p2, flags));
X}
X
X/*
X * syn2
X *	syn3
X *	syn3 | syn2
X *	syn3 |& syn2
X */
static struct command *
syn2(p1, p2, flags)
X    struct wordent *p1, *p2;
X    int     flags;
X{
X    register struct wordent *p, *pn;
X    register struct command *t;
X    register int l = 0;
X    int     f;
X
X    for (p = p1; p != p2; p = p->next)
X	switch (p->word[0]) {
X
X	case '(':
X	    l++;
X	    continue;
X
X	case ')':
X	    l--;
X	    continue;
X
X	case '|':
X	    if (l != 0)
X		continue;
X	    t = (struct command *) xcalloc(1, sizeof(*t));
X	    f = flags | P_OUT;
X	    pn = p->next;
X	    if (pn != p2 && pn->word[0] == '&') {
X		f |= P_DIAG;
X		t->t_dflg |= F_STDERR;
X	    }
X	    t->t_dtyp = NODE_PIPE;
X	    t->t_dcar = syn3(p1, p, f);
X	    if (pn != p2 && pn->word[0] == '&')
X		p = pn;
X	    t->t_dcdr = syn2(p->next, p2, flags | P_IN);
X	    return (t);
X
X	default:
X	    break;
X	}
X    return (syn3(p1, p2, flags));
X}
X
static char RELPAR[] = {'<', '>', '(', ')', '\0'};
X
X/*
X * syn3
X *	( syn0 ) [ < in  ] [ > out ]
X *	word word* [ < in ] [ > out ]
X *	KEYWORD ( word* ) word* [ < in ] [ > out ]
X *
X *	KEYWORD = (@ exit foreach if set switch test while)
X */
static struct command *
syn3(p1, p2, flags)
X    struct wordent *p1, *p2;
X    int     flags;
X{
X    register struct wordent *p;
X    struct wordent *lp, *rp;
X    register struct command *t;
X    register int l;
X    Char  **av;
X    int     n, c;
X    bool    specp = 0;
X
X    if (p1 != p2) {
X	p = p1;
again:
X	switch (srchx(p->word)) {
X
X	case T_ELSE:
X	    p = p->next;
X	    if (p != p2)
X		goto again;
X	    break;
X
X	case T_EXIT:
X	case T_FOREACH:
X	case T_IF:
X	case T_LET:
X	case T_SET:
X	case T_SWITCH:
X	case T_WHILE:
X	    specp = 1;
X	    break;
X	default:
X	    break;
X	}
X    }
X    n = 0;
X    l = 0;
X    for (p = p1; p != p2; p = p->next)
X	switch (p->word[0]) {
X
X	case '(':
X	    if (specp)
X		n++;
X	    l++;
X	    continue;
X
X	case ')':
X	    if (specp)
X		n++;
X	    l--;
X	    continue;
X
X	case '>':
X	case '<':
X	    if (l != 0) {
X		if (specp)
X		    n++;
X		continue;
X	    }
X	    if (p->next == p2)
X		continue;
X	    if (any(RELPAR, p->next->word[0]))
X		continue;
X	    n--;
X	    continue;
X
X	default:
X	    if (!specp && l != 0)
X		continue;
X	    n++;
X	    continue;
X	}
X    if (n < 0)
X	n = 0;
X    t = (struct command *) xcalloc(1, sizeof(*t));
X    av = (Char **) xcalloc((size_t) (n + 1), sizeof(Char **));
X    t->t_dcom = av;
X    n = 0;
X    if (p2->word[0] == ')')
X	t->t_dflg = F_NOFORK;
X    lp = 0;
X    rp = 0;
X    l = 0;
X    for (p = p1; p != p2; p = p->next) {
X	c = p->word[0];
X	switch (c) {
X
X	case '(':
X	    if (l == 0) {
X		if (lp != 0 && !specp)
X		    seterror(ERR_BADPLP);
X		lp = p->next;
X	    }
X	    l++;
X	    goto savep;
X
X	case ')':
X	    l--;
X	    if (l == 0)
X		rp = p;
X	    goto savep;
X
X	case '>':
X	    if (l != 0)
X		goto savep;
X	    if (p->word[1] == '>')
X		t->t_dflg |= F_APPEND;
X	    if (p->next != p2 && eq(p->next->word, STRand)) {
X		t->t_dflg |= F_STDERR, p = p->next;
X		if (flags & (P_OUT | P_DIAG)) {
X		    seterror(ERR_OUTRED);
X		    continue;
X		}
X	    }
X	    if (p->next != p2 && eq(p->next->word, STRbang))
X		t->t_dflg |= F_OVERWRITE, p = p->next;
X	    if (p->next == p2) {
X		seterror(ERR_MISRED);
X		continue;
X	    }
X	    p = p->next;
X	    if (any(RELPAR, p->word[0])) {
X		seterror(ERR_MISRED);
X		continue;
X	    }
X	    if (((flags & P_OUT) && (flags & P_DIAG) == 0) || t->t_drit)
X		seterror(ERR_OUTRED);
X	    else
X		t->t_drit = Strsave(p->word);
X	    continue;
X
X	case '<':
X	    if (l != 0)
X		goto savep;
X	    if (p->word[1] == '<')
X		t->t_dflg |= F_READ;
X	    if (p->next == p2) {
X		seterror(ERR_MISRED);
X		continue;
X	    }
X	    p = p->next;
X	    if (any(RELPAR, p->word[0])) {
X		seterror(ERR_MISRED);
X		continue;
X	    }
X	    if ((flags & P_HERE) && (t->t_dflg & F_READ))
X		seterror(ERR_REDPAR);
X	    else if ((flags & P_IN) || t->t_dlef)
X		seterror(ERR_INRED);
X	    else
X		t->t_dlef = Strsave(p->word);
X	    continue;
X
X    savep:
X	    if (!specp)
X		continue;
X	default:
X	    if (l != 0 && !specp)
X		continue;
X	    if (seterr == 0)
X		av[n] = Strsave(p->word);
X	    n++;
X	    continue;
X	}
X    }
X    if (lp != 0 && !specp) {
X	if (n != 0)
X	    seterror(ERR_BADPLPS);
X	t->t_dtyp = NODE_PAREN;
X	t->t_dspr = syn0(lp, rp, P_HERE);
X    }
X    else {
X	if (n == 0)
X	    seterror(ERR_NULLCOM);
X	t->t_dtyp = NODE_COMMAND;
X    }
X    return (t);
X}
X
void
freesyn(t)
X    register struct command *t;
X{
X    register Char **v;
X
X    if (t == 0)
X	return;
X    switch (t->t_dtyp) {
X
X    case NODE_COMMAND:
X	for (v = t->t_dcom; *v; v++)
X	    xfree((ptr_t) * v);
X	xfree((ptr_t) (t->t_dcom));
X	xfree((ptr_t) t->t_dlef);
X	xfree((ptr_t) t->t_drit);
X	break;
X    case NODE_PAREN:
X	freesyn(t->t_dspr);
X	xfree((ptr_t) t->t_dlef);
X	xfree((ptr_t) t->t_drit);
X	break;
X
X    case NODE_AND:
X    case NODE_OR:
X    case NODE_PIPE:
X    case NODE_LIST:
X	freesyn(t->t_dcar), freesyn(t->t_dcdr);
X	break;
X    default:
X	break;
X    }
X    xfree((ptr_t) t);
X}
END_OF_FILE
if test 14172 -ne `wc -c <'sh.parse.c'`; then
    echo shar: \"'sh.parse.c'\" unpacked with wrong size!
fi
# end of 'sh.parse.c'
fi
if test -f 'tc.alloc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tc.alloc.c'\"
else
echo shar: Extracting \"'tc.alloc.c'\" \(14916 characters\)
sed "s/^X//" >'tc.alloc.c' <<'END_OF_FILE'
X/* $Header: /home/hyperion/mu/christos/src/sys/tcsh-6.01/RCS/tc.alloc.c,v 3.7 1991/10/28 06:26:50 christos Exp $ */
X/*
X * tc.alloc.c (Caltech) 2/21/82
X * Chris Kingsley, kingsley@cit-20.
X *
X * This is a very fast storage allocator.  It allocates blocks of a small
X * number of different sizes, and keeps free lists of each size.  Blocks that
X * don't exactly fit are passed up to the next larger size.  In this
X * implementation, the available sizes are 2^n-4 (or 2^n-12) bytes long.
X * This is designed for use in a program that uses vast quantities of memory,
X * but bombs when it runs out.
X */
X/*-
X * Copyright (c) 1980, 1991 The Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by the University of
X *	California, Berkeley and its contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X */
X#include "sh.h"
X
RCSID("$Id: tc.alloc.c,v 3.7 1991/10/28 06:26:50 christos Exp $")
X
char   *memtop = NULL;		/* PWP: top of current memory */
char   *membot = NULL;		/* PWP: bottom of allocatable memory */
X
X#ifndef SYSMALLOC
X
X#undef RCHECK
X#undef DEBUG
X
X
X#ifndef NULL
X#define	NULL 0
X#endif
X
typedef unsigned char U_char;	/* we don't really have signed chars */
typedef unsigned int U_int;
typedef unsigned short U_short;
X
X
X/*
X * The overhead on a block is at least 4 bytes.  When free, this space
X * contains a pointer to the next free block, and the bottom two bits must
X * be zero.  When in use, the first byte is set to MAGIC, and the second
X * byte is the size index.  The remaining bytes are for alignment.
X * If range checking is enabled and the size of the block fits
X * in two bytes, then the top two bytes hold the size of the requested block
X * plus the range checking words, and the header word MINUS ONE.
X */
X
X
X#define MEMALIGN(a) (((a) + ROUNDUP) & ~ROUNDUP)
X
union overhead {
X    union overhead *ov_next;	/* when free */
X    struct {
X	U_char  ovu_magic;	/* magic number */
X	U_char  ovu_index;	/* bucket # */
X#ifdef RCHECK
X	U_short ovu_size;	/* actual block size */
X	U_int   ovu_rmagic;	/* range magic number */
X#endif
X    }       ovu;
X#define	ov_magic	ovu.ovu_magic
X#define	ov_index	ovu.ovu_index
X#define	ov_size		ovu.ovu_size
X#define	ov_rmagic	ovu.ovu_rmagic
X};
X
X#define	MAGIC		0xfd	/* magic # on accounting info */
X#define RMAGIC		0x55555555	/* magic # on range info */
X#ifdef RCHECK
X#define	RSLOP		sizeof (U_int)
X#else
X#define	RSLOP		0
X#endif
X
X
X#define ROUNDUP	7
X
X/*
X * nextf[i] is the pointer to the next free block of size 2^(i+3).  The
X * smallest allocatable block is 8 bytes.  The overhead information
X * precedes the data area returned to the user.
X */
X#define	NBUCKETS 30
static union overhead *nextf[NBUCKETS];
X
X#ifdef notdef
extern char *sbrk();
X
X#endif
X
X/*
X * nmalloc[i] is the difference between the number of mallocs and frees
X * for a given block size.
X */
static U_int nmalloc[NBUCKETS];
X
static	int	findbucket	__P((union overhead *, int));
static	void	morecore	__P((int));
X
X
X#ifdef DEBUG
X# define CHECK(a, str, p) \
X    if (a) { \
X	xprintf(str, p);	\
X	xprintf("memtop = %lx membot = %lx.\n", memtop, membot);	\
X	abort(); \
X    }
X#else
X# define CHECK(a, str, p) \
X    if (a) { \
X	xprintf(str, p);	\
X	xprintf("memtop = %lx membot = %lx.\n", memtop, membot);	\
X	return; \
X    }
X#endif
X
memalign_t
malloc(nbytes)
X    register size_t nbytes;
X{
X#ifndef lint
X    register union overhead *p;
X    register int bucket = 0;
X    register unsigned shiftr;
X
X    /*
X     * Convert amount of memory requested into closest block size stored in
X     * hash buckets which satisfies request.  Account for space used per block
X     * for accounting.
X     */
X#ifdef SUNOS4
X    /*
X     * SunOS localtime() overwrites the 9th byte on an 8 byte malloc()....
X     * so we get one more...
X     * From Michael Schroeder: This is not true. It depends on the 
X     * timezone string. In Europe it can overwrite the 13th byte on a
X     * 12 byte malloc.
X     * So we punt and we always allocate an extra byte.
X     */
X    nbytes++;
X#endif
X
X    nbytes = MEMALIGN(MEMALIGN(sizeof(union overhead)) + nbytes + RSLOP);
X    shiftr = (nbytes - 1) >> 2;
X
X    /* apart from this loop, this is O(1) */
X    while (shiftr >>= 1)
X	bucket++;
X    /*
X     * If nothing in hash bucket right now, request more memory from the
X     * system.
X     */
X    if (nextf[bucket] == NULL)
X	morecore(bucket);
X    if ((p = (union overhead *) nextf[bucket]) == NULL) {
X	child++;
X#ifndef DEBUG
X	stderror(ERR_NOMEM);
X#else
X	showall(NULL, NULL);
X	xprintf("nbytes=%d: Out of memory\n", nbytes);
X	abort();
X#endif
X	/* fool lint */
X	return ((memalign_t) 0);
X    }
X    /* remove from linked list */
X    nextf[bucket] = nextf[bucket]->ov_next;
X    p->ov_magic = MAGIC;
X    p->ov_index = bucket;
X    nmalloc[bucket]++;
X#ifdef RCHECK
X    /*
X     * Record allocated size of block and bound space with magic numbers.
X     */
X    if (nbytes <= 0x10000)
X	p->ov_size = nbytes - 1;
X    p->ov_rmagic = RMAGIC;
X    *((U_int *) (((caddr_t) p) + nbytes - RSLOP)) = RMAGIC;
X#endif
X    return ((memalign_t) (((caddr_t) p) + MEMALIGN(sizeof(union overhead))));
X#else
X    if (nbytes)
X	return ((memalign_t) 0);
X    else
X	return ((memalign_t) 0);
X#endif				/* !lint */
X}
X
X#ifndef lint
X/*
X * Allocate more memory to the indicated bucket.
X */
static void
morecore(bucket)
X    register bucket;
X{
X    register union overhead *op;
X    register int rnu;		/* 2^rnu bytes will be requested */
X    register int nblks;		/* become nblks blocks of the desired size */
X    register int siz;
X
X    if (nextf[bucket])
X	return;
X    /*
X     * Insure memory is allocated on a page boundary.  Should make getpageize
X     * call?
X     */
X    op = (union overhead *) sbrk(0);
X    memtop = (char *) op;
X    if (membot == NULL)
X	membot = memtop;
X    if ((int) op & 0x3ff) {
X	memtop = (char *) sbrk(1024 - ((int) op & 0x3ff));
X	memtop += 1024 - ((int) op & 0x3ff);
X    }
X
X    /* take 2k unless the block is bigger than that */
X    rnu = (bucket <= 8) ? 11 : bucket + 3;
X    nblks = 1 << (rnu - (bucket + 3));	/* how many blocks to get */
X    memtop = (char *) sbrk(1 << rnu);	/* PWP */
X    op = (union overhead *) memtop;
X    memtop += 1 << rnu;
X    /* no more room! */
X    if ((int) op == -1)
X	return;
X    /*
X     * Round up to minimum allocation size boundary and deduct from block count
X     * to reflect.
X     */
X    if (((U_int) op) & ROUNDUP) {
X	op = (union overhead *) (((U_int) op + (ROUNDUP + 1)) & ~ROUNDUP);
X	nblks--;
X    }
X    /*
X     * Add new memory allocated to that on free list for this hash bucket.
X     */
X    nextf[bucket] = op;
X    siz = 1 << (bucket + 3);
X    while (--nblks > 0) {
X	op->ov_next = (union overhead *) (((caddr_t) op) + siz);
X	op = (union overhead *) (((caddr_t) op) + siz);
X    }
X    op->ov_next = NULL;
X}
X
X#endif
X
void
free(cp)
X    ptr_t   cp;
X{
X#ifndef lint
X    register int size;
X    register union overhead *op;
X
X    if (cp == NULL)
X	return;
X    CHECK(!memtop || !membot, "free(%lx) called before any allocations.", cp);
X    CHECK(cp > (ptr_t) memtop, "free(%lx) above top of memory.", cp);
X    CHECK(cp < (ptr_t) membot, "free(%lx) above top of memory.", cp);
X    op = (union overhead *) (((caddr_t) cp) - MEMALIGN(sizeof(union overhead)));
X    CHECK(op->ov_magic != MAGIC, "free(%lx) bad block.", cp);
X
X#ifdef RCHECK
X    if (op->ov_index <= 13)
X	CHECK(*(U_int *) ((caddr_t) op + op->ov_size + 1 - RSLOP) != RMAGIC,
X	      "free(%lx) bad range check.", cp);
X#endif
X    CHECK(op->ov_index >= NBUCKETS, "free(%lx) bad block index.", cp);
X    size = op->ov_index;
X    op->ov_next = nextf[size];
X    nextf[size] = op;
X
X    nmalloc[size]--;
X
X#else
X    if (cp == NULL)
X	return;
X#endif
X}
X
memalign_t
calloc(i, j)
X    size_t  i, j;
X{
X#ifndef lint
X    register char *cp, *scp;
X
X    i *= j;
X    scp = cp = (char *) xmalloc((size_t) i);
X    if (i != 0)
X	do
X	    *cp++ = 0;
X	while (--i);
X
X    return ((memalign_t) scp);
X#else
X    if (i && j)
X	return ((memalign_t) 0);
X    else
X	return ((memalign_t) 0);
X#endif
X}
X
X#ifndef lint
X/* PWP: a bcopy that does overlapping extents correctly */
static void
mybcopy(from, to, len)
X    char   *from, *to;
X    register unsigned len;
X{
X    register char *sp, *dp;
X
X    if (from == to)
X	return;
X    if (from < to) {
X	/* len is unsigned, len > 0 is equivalent to len != 0 */
X	for (sp = &from[len - 1], dp = &to[len - 1]; len != 0; len--, sp--, dp--)
X	    *dp = *sp;
X    }
X    else {
X	/* len is unsigned, len > 0 is equivalent to len != 0 */
X	for (sp = from, dp = to; len != 0; len--, sp++, dp++)
X	    *dp = *sp;
X    }
X}
X
X#endif
X
X/*
X * When a program attempts "storage compaction" as mentioned in the
X * old malloc man page, it realloc's an already freed block.  Usually
X * this is the last block it freed; occasionally it might be farther
X * back.  We have to search all the free lists for the block in order
X * to determine its bucket: 1st we make one pass thru the lists
X * checking only the first block in each; if that fails we search
X * ``realloc_srchlen'' blocks in each list for a match (the variable
X * is extern so the caller can modify it).  If that fails we just copy
X * however many bytes was given to realloc() and hope it's not huge.
X */
X#ifndef lint
int     realloc_srchlen = 4;	/* 4 should be plenty, -1 =>'s whole list */
X
X#endif				/* lint */
X
memalign_t
realloc(cp, nbytes)
X    ptr_t   cp;
X    size_t  nbytes;
X{
X#ifndef lint
X    register U_int onb;
X    union overhead *op;
X    char   *res;
X    register int i;
X    int     was_alloced = 0;
X
X    if (cp == NULL)
X	return (malloc(nbytes));
X    op = (union overhead *) (((caddr_t) cp) - MEMALIGN(sizeof(union overhead)));
X    if (op->ov_magic == MAGIC) {
X	was_alloced++;
X	i = op->ov_index;
X    }
X    else
X	/*
X	 * Already free, doing "compaction".
X	 * 
X	 * Search for the old block of memory on the free list.  First, check the
X	 * most common case (last element free'd), then (this failing) the last
X	 * ``realloc_srchlen'' items free'd. If all lookups fail, then assume
X	 * the size of the memory block being realloc'd is the smallest
X	 * possible.
X	 */
X	if ((i = findbucket(op, 1)) < 0 &&
X	    (i = findbucket(op, realloc_srchlen)) < 0)
X	i = 0;
X
X    onb = MEMALIGN(nbytes + MEMALIGN(sizeof(union overhead)) + RSLOP);
X
X    /* avoid the copy if same size block */
X    if (was_alloced && (onb <= (U_int) (1 << (i + 3))) && 
X	(onb > (U_int) (1 << (i + 2))))
X	return ((memalign_t) cp);
X    if ((res = malloc(nbytes)) == NULL)
X	return ((memalign_t) NULL);
X    if (cp != res)		/* common optimization */
X	mybcopy(cp, res, nbytes);
X    if (was_alloced)
X	free(cp);
X    return ((memalign_t) res);
X#else
X    if (cp && nbytes)
X	return ((memalign_t) 0);
X    else
X	return ((memalign_t) 0);
X#endif				/* !lint */
X}
X
X
X
X#ifndef lint
X/*
X * Search ``srchlen'' elements of each free list for a block whose
X * header starts at ``freep''.  If srchlen is -1 search the whole list.
X * Return bucket number, or -1 if not found.
X */
static int
findbucket(freep, srchlen)
X    union overhead *freep;
X    int     srchlen;
X{
X    register union overhead *p;
X    register int i, j;
X
X    for (i = 0; i < NBUCKETS; i++) {
X	j = 0;
X	for (p = nextf[i]; p && j != srchlen; p = p->ov_next) {
X	    if (p == freep)
X		return (i);
X	    j++;
X	}
X    }
X    return (-1);
X}
X
X#endif
X
X
X#else				/* SYSMALLOC */
X
X/**
X ** ``Protected versions'' of malloc, realloc, calloc, and free
X **
X ** On many systems:
X **
X ** 1. malloc(0) is bad
X ** 2. free(0) is bad
X ** 3. realloc(0, n) is bad
X ** 4. realloc(n, 0) is bad
X **
X ** Also we call our error routine if we run out of memory.
X **/
memalign_t
Malloc(n)
X    size_t  n;
X{
X    ptr_t   ptr;
X
X    n = n ? n : 1;
X
X    if ((ptr = malloc(n)) == (ptr_t) 0) {
X	child++;
X	stderror(ERR_NOMEM);
X    }
X    return ((memalign_t) ptr);
X}
X
memalign_t
Realloc(p, n)
X    ptr_t   p;
X    size_t  n;
X{
X    ptr_t   ptr;
X
X    n = n ? n : 1;
X    if ((ptr = (p ? realloc(p, n) : malloc(n))) == (ptr_t) 0) {
X	child++;
X	stderror(ERR_NOMEM);
X    }
X    return ((memalign_t) ptr);
X}
X
memalign_t
Calloc(s, n)
X    size_t  s, n;
X{
X    char   *sptr;
X    ptr_t   ptr;
X
X    n *= s;
X    n = n ? n : 1;
X    if ((ptr = malloc(n)) == (ptr_t) 0) {
X	child++;
X	stderror(ERR_NOMEM);
X    }
X
X    sptr = (char *) ptr;
X    if (n != 0)
X	do
X	    *sptr++ = 0;
X	while (--n);
X
X    return ((memalign_t) ptr);
X}
X
void
XFree(p)
X    ptr_t   p;
X{
X    if (p)
X	free(p);
X}
X
X#endif				/* SYSMALLOC */
X
X/*
X * mstats - print out statistics about malloc
X *
X * Prints two lines of numbers, one showing the length of the free list
X * for each size category, the second showing the number of mallocs -
X * frees for each size category.
X */
X/*ARGSUSED*/
void
showall(v, c)
X    Char **v;
X    struct command *c;
X{
X#ifndef SYSMALLOC
X    register int i, j;
X    register union overhead *p;
X    int     totfree = 0, totused = 0;
X
X    xprintf("tcsh current memory allocation:\nfree:\t");
X    for (i = 0; i < NBUCKETS; i++) {
X	for (j = 0, p = nextf[i]; p; p = p->ov_next, j++);
X	xprintf(" %4d", j);
X	totfree += j * (1 << (i + 3));
X    }
X    xprintf("\nused:\t");
X    for (i = 0; i < NBUCKETS; i++) {
X	xprintf(" %4d", nmalloc[i]);
X	totused += nmalloc[i] * (1 << (i + 3));
X    }
X    xprintf("\n\tTotal in use: %d, total free: %d\n",
X	    totused, totfree);
X    xprintf("\tAllocated memory from 0x%lx to 0x%lx.  Real top at 0x%lx\n",
X	    membot, memtop, (char *) sbrk(0));
X#else
X    xprintf("Allocated memory from 0x%lx to 0x%lx (%ld).\n",
X	    membot, memtop = (char *) sbrk(0), memtop - membot);
X#endif				/* SYSMALLOC */
X}
END_OF_FILE
if test 14916 -ne `wc -c <'tc.alloc.c'`; then
    echo shar: \"'tc.alloc.c'\" unpacked with wrong size!
fi
# end of 'tc.alloc.c'
fi
if test -f 'tc.const.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tc.const.c'\"
else
echo shar: Extracting \"'tc.const.c'\" \(13434 characters\)
sed "s/^X//" >'tc.const.c' <<'END_OF_FILE'
X/* $Header: /home/hyperion/mu/christos/src/sys/tcsh-6.01/RCS/tc.const.c,v 3.7 1991/11/22 02:28:12 christos Exp $ */
X/*
X * sh.const.c: String constants for tcsh.
X */
X/*-
X * Copyright (c) 1980, 1991 The Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by the University of
X *	California, Berkeley and its contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X */
X#include "sh.h"
X
RCSID("$Id: tc.const.c,v 3.7 1991/11/22 02:28:12 christos Exp $")
X
Char STRlogout[]        = { 'l', 'o', 'g', 'o', 'u', 't', '\0' };
Char STRautologout[]    = { 'a', 'u', 't', 'o', 'l', 'o', 'g', 'o', 'u', 't', 
X			    '\0' };
Char STRdefautologout[] = { '6', '0', '\0' };
Char STRautomatic[]     = { 'a', 'u', 't', 'o', 'm', 'a', 't', 'i', 'c', '\0' };
Char STRaout[]          = { 'a', '.', 'o', 'u', 't', '\0' };
Char STRtty[]           = { 't', 't', 'y', '\0' };
Char STRany[]           = { 'a', 'n', 'y', '\0' };
Char STRstatus[]        = { 's', 't', 'a', 't', 'u', 's', '\0' };
Char STR0[]             = { '0', '\0' };
Char STR1[]             = { '1', '\0' };
Char STRNULL[]          = { '\0' };
Char STRtcsh[]          = { 't', 'c', 's', 'h', '\0' };
Char STRhome[]          = { 'h', 'o', 'm', 'e', '\0' };
Char STRuser[]          = { 'u', 's', 'e', 'r', '\0' };
Char STRterm[]          = { 't', 'e', 'r', 'm', '\0' };
Char STRversion[]       = { 'v', 'e', 'r', 's', 'i', 'o', 'n', '\0' };
Char STRuid[]           = { 'u', 'i', 'd', '\0' };
Char STRgid[]           = { 'g', 'i', 'd', '\0' };
Char STRHOST[]          = { 'H', 'O', 'S', 'T', '\0' };
Char STRHOSTTYPE[]      = { 'H', 'O', 'S', 'T', 'T', 'Y', 'P', 'E', '\0' };
Char STRedit[]          = { 'e', 'd', 'i', 't', '\0' };
Char STRaddsuffix[]     = { 'a', 'd', 'd', 's', 'u', 'f', 'f', 'i', 'x', '\0' };
Char STRshell[]         = { 's', 'h', 'e', 'l', 'l', '\0' };
Char STRtmpsh[]         = { '/', 't', 'm', 'p', '/', 's', 'h', '\0' };
Char STRverbose[]       = { 'v', 'e', 'r', 'b', 'o', 's', 'e', '\0' };
Char STRecho[]          = { 'e', 'c', 'h', 'o', '\0' };
Char STRpath[]          = { 'p', 'a', 't', 'h', '\0' };
Char STRprompt[]        = { 'p', 'r', 'o', 'm', 'p', 't', '\0' };
Char STRprompt2[]       = { 'p', 'r', 'o', 'm', 'p', 't', '2', '\0' };
Char STRprompt3[]       = { 'p', 'r', 'o', 'm', 'p', 't', '3', '\0' };
Char STRcwd[]           = { 'c', 'w', 'd', '\0' };
Char STRstar[]          = { '*', '\0' };
Char STRdot[]           = { '.', '\0' };
Char STRhistory[] 	= { 'h', 'i', 's', 't', 'o', 'r', 'y', '\0' };
Char STRhistfile[] 	= { 'h', 'i', 's', 't', 'f', 'i', 'l', 'e', '\0' };
Char STRsource[]        = { 's', 'o', 'u', 'r', 'c', 'e', '\0' };
Char STRmh[]            = { '-', 'h', '\0' };
Char STRtildothist[]    = { '~', '/', '.', 'h', 'i', 's', 't', 'o', 'r', 
X		            'y', '\0' };
X
X#ifdef CSHDIRS
Char STRdirfile[]     = { '~', '/', '.', 'c', 's', 'h', 'd', 'i', 'r',
X                          's', '\0' };
Char STRsldtdirs[]    = { '/', '.', 'c', 's', 'h', 'd', 'i', 'r', 's', '\0' };
Char STRsavedirs[]    = { 's', 'a', 'v', 'e', 'd', 'i', 'r', 's', '\0' };
X#endif
X
Char STRargv[]          = { 'a', 'r', 'g', 'v', '\0' };
Char STRsavehist[]      = { 's', 'a', 'v', 'e', 'h', 'i', 's', 't', '\0' };
Char STRsldthist[]      = { '/', '.', 'h', 'i', 's', 't', 'o', 'r', 'y', '\0' };
Char STRnormal[]        = { 'n', 'o', 'r', 'm', 'a', 'l', '\0' };
Char STRsldtlogout[]    = { '/', '.', 'l', 'o', 'g', 'o', 'u', 't', '\0' };
Char STRjobs[]          = { 'j', 'o', 'b', 's', '\0' };
Char STRsymhash[]       = { '#', ' ', '\0' };
Char STRsymarrow[]      = { '>', ' ', '\0' };
Char STRmquestion[]     = { '%', 'R', '?' | QUOTE, ' ', '\0' };
Char STRCORRECT[]       = { 'C', 'O', 'R', 'R', 'E', 'C', 'T', '>', '%', 'R', 
X			    ' ', '(', 'y', '|', 'n', '|', 'e', ')', 
X			    '?' | QUOTE, ' ', '\0' };
Char STRunalias[]       = { 'u', 'n', 'a', 'l', 'i', 'a', 's', '\0' };
Char STRalias[]         = { 'a', 'l', 'i', 'a', 's', '\0' };
Char STRprecmd[]        = { 'p', 'r', 'e', 'c', 'm', 'd', '\0' };
Char STRcwdcmd[]        = { 'c', 'w', 'd', 'c', 'm', 'd', '\0' };
Char STRperiodic[]      = { 'p', 'e', 'r', 'i', 'o', 'd', 'i', 'c', '\0' };
Char STRtperiod[]       = { 't', 'p', 'e', 'r', 'i', 'o', 'd', '\0' };
Char STRml[]		= { '-', 'l', '\0' };
Char STRslash[]		= { '/', '\0' };
Char STRdotsl[]		= { '.', '/', '\0' };
Char STRdotdotsl[]	= { '.', '.', '/', '\0' };
Char STRcdpath[]	= { 'c', 'd', 'p', 'a', 't', 'h', '\0' };
Char STRpushdtohome[]	= { 'p', 'u', 's', 'h', 'd', 't', 'o', 'h', 'o', 'm',
X			    'e', '\0' };
Char STRpushdsilent[]	= { 'p', 'u', 's', 'h', 'd', 's', 'i', 'l', 'e', 'n',
X			    't', '\0' };
Char STRdextract[]	= { 'd', 'e', 'x', 't', 'r', 'a', 'c', 't', '\0' };
Char STRignore_symlinks[] = { 'i', 'g', 'n', 'o', 'r', 'e', '_', 's', 'y', 'm',
X			    'l', 'i', 'n', 'k', 's', '\0' };
Char STRchase_symlinks[] = { 'c', 'h', 'a', 's', 'e', '_', 's', 'y', 'm', 'l', 
X			    'i', 'n', 'k', 's', '\0' };
Char STRPWD[]		= { 'P', 'W', 'D', '\0' };
Char STRor2[]		= { '|', '|', '\0' };
Char STRand2[]		= { '&', '&', '\0' };
Char STRor[]		= { '|', '\0' };
Char STRcaret[]		= { '^', '\0' };
Char STRand[]		= { '&', '\0' };
Char STRequal[]		= { '=', '\0' };
Char STRbang[]		= { '!', '\0' };
Char STRtilde[]		= { '~', '\0' };
Char STRLparen[]	= { '(', '\0' };
Char STRLbrace[]	= { '{', '\0' };
Char STRfakecom[]	= { '{', ' ', '.', '.', '.', ' ', '}', '\0' };
Char STRRbrace[]	= { '}', '\0' };
Char STRPATH[] 		= { 'P', 'A', 'T', 'H', '\0' };
Char STRdefault[]	= { 'd', 'e', 'f', 'a', 'u', 'l', 't', '\0' };
Char STRmn[]		= { '-', 'n', '\0' };
Char STRminus[]		= { '-', '\0' };
Char STRnoglob[]	= { 'n', 'o', 'g', 'l', 'o', 'b', '\0' };
Char STRnonomatch[]	= { 'n', 'o', 'n', 'o', 'm', 'a', 't', 'c', 'h', '\0' };
Char STRfakecom1[]	= { '`', ' ', '.', '.', '.', ' ', '`', '\0' };
Char STRampm[]		= { 'a', 'm', 'p', 'm', '\0' };
Char STRchild[]		= { 'c', 'h', 'i', 'l', 'd', '\0' };
Char STRtime[]		= { 't', 'i', 'm', 'e', '\0' };
Char STRnotify[]	= { 'n', 'o', 't', 'i', 'f', 'y', '\0' };
Char STRprintexitvalue[] = { 'p', 'r', 'i', 'n', 't', 'e', 'x', 'i', 't', 'v', 
X			    'a', 'l', 'u', 'e', '\0' };
Char STRLparensp[]	= { '(', ' ', '\0' };
Char STRspRparen[]	= { ' ', ')', '\0' };
Char STRspace[]		= { ' ', '\0' };
Char STRspor2sp[]	= { ' ', '|', '|', ' ', '\0' };
Char STRspand2sp[]	= { ' ', '&', '&', ' ', '\0' };
Char STRsporsp[]	= { ' ', '|', ' ', '\0' };
Char STRsemisp[]	= { ';', ' ', '\0' };
Char STRsemi[]		= { ';', '\0' };
Char STRQQ[]		= { '"', '"', '\0' };
Char STRBB[]		= { '[', ']', '\0' };
Char STRspLarrow2sp[]	= { ' ', '<', '<', ' ', '\0' };
Char STRspLarrowsp[]	= { ' ', '<', ' ', '\0' };
Char STRspRarrow2[]	= { ' ', '>', '>', '\0' };
Char STRspRarrow[]	= { ' ', '>', '\0' };
Char STRgt[]		= { '>', '\0' };
Char STRsp3dots[]	= { ' ', '.', '.', '.', '\0' };
Char STRcent2[] 	= { '%', '%', '\0' };
Char STRcentplus[] 	= { '%', '+', '\0' };
Char STRcentminus[] 	= { '%', '-', '\0' };
Char STRcenthash[] 	= { '%', '#', '\0' };
X#ifdef BSDJOBS
Char STRcontinue[]	= { 'c', 'o', 'n', 't', 'i', 'n', 'u', 'e', '\0' };
Char STRcontinue_args[]	= { 'c', 'o', 'n', 't', 'i', 'n', 'u', 'e', '_', 'a',
X			    'r', 'g', 's', '\0' };
Char STRunderpause[]	= { '_', 'p', 'a', 'u', 's', 'e', '\0' };
X#endif
Char STRbackqpwd[]	= { '`', 'p', 'w', 'd', '`', '\0' };
Char STRhistchars[]	= { 'h', 'i', 's', 't', 'c', 'h', 'a', 'r', 's', '\0' };
Char STRhistlit[]	= { 'h', 'i', 's', 't', 'l', 'i', 't', '\0' };
Char STRUSER[]		= { 'U', 'S', 'E', 'R', '\0' };
Char STRLOGNAME[]	= { 'L', 'O', 'G', 'N', 'A', 'M', 'E', '\0' };
Char STRwordchars[]	= { 'w', 'o', 'r', 'd', 'c', 'h', 'a', 'r', 's', '\0' };
Char STRTERM[]		= { 'T', 'E', 'R', 'M', '\0' };
Char STRHOME[]		= { 'H', 'O', 'M', 'E', '\0' };
Char STRbackslash_quote[] = { 'b', 'a', 'c', 'k', 's', 'l', 'a', 's', 'h', '_',
X			     'q', 'u', 'o', 't', 'e', '\0' };
Char STRRparen[]	= { ')', '\0' };
Char STRcolon[]		= { ':', '\0' };
Char STRmail[]		= { 'm', 'a', 'i', 'l', '\0' };
Char STRwatch[]		= { 'w', 'a', 't', 'c', 'h', '\0' };
X
Char STRsldottcshrc[]	= { '/', '.', 't', 'c', 's', 'h', 'r', 'c', '\0' };
Char STRsldotcshrc[]	= { '/', '.', 'c', 's', 'h', 'r', 'c', '\0' };
Char STRsldotlogin[]	= { '/', '.', 'l', 'o', 'g', 'i', 'n', '\0' };
Char STRignoreeof[]	= { 'i', 'g', 'n', 'o', 'r', 'e', 'e', 'o', 'f', '\0' };
Char STRnoclobber[]	= { 'n', 'o', 'c', 'l', 'o', 'b', 'b', 'e', 'r', '\0' };
Char STRhelpcommand[]	= { 'h', 'e', 'l', 'p', 'c', 'o', 'm', 'm', 'a', 'n', 
X			    'd', '\0' };
Char STRfignore[]	= { 'f', 'i', 'g', 'n', 'o', 'r', 'e', '\0' };
Char STRrecexact[]	= { 'r', 'e', 'c', 'e', 'x', 'a', 'c', 't', '\0' };
Char STRlistmax[]	= { 'l', 'i', 's', 't', 'm', 'a', 'x', '\0' };
Char STRlistlinks[]	= { 'l', 'i', 's', 't', 'l', 'i', 'n', 'k', 's', '\0' };
Char STRDING[]		= { 'D', 'I', 'N', 'G', '!', '\0' };
Char STRQNULL[]		= { '\0' | QUOTE, '\0' };
Char STRcorrect[]	= { 'c', 'o', 'r', 'r', 'e', 'c', 't', '\0' };
Char STRcmd[]		= { 'c', 'm', 'd', '\0' };
Char STRall[]		= { 'a', 'l', 'l', '\0' };
Char STRautoexpand[]	= { 'a', 'u', 't', 'o', 'e', 'x', 'p', 'a', 'n', 'd',
X			    '\0' };
Char STRautocorrect[]	= { 'a', 'u', 't', 'o', 'c', 'o', 'r', 'r', 'e', 'c',
X			    't', '\0' };
Char STRautolist[]	= { 'a', 'u', 't', 'o', 'l', 'i', 's', 't', '\0' };
Char STRbeepcmd[]	= { 'b', 'e', 'e', 'p', 'c', 'm', 'd', '\0' };
Char STRmatchbeep[]	= { 'm', 'a', 't', 'c', 'h', 'b', 'e', 'e', 'p', '\0' };
Char STRnomatch[]	= { 'n', 'o', 'm', 'a', 't', 'c', 'h', '\0' };
Char STRambiguous[]	= { 'a', 'm', 'b', 'i', 'g', 'u', 'o', 'u', 's', '\0' };
Char STRnotunique[]	= { 'n', 'o', 't', 'u', 'n', 'i', 'q', 'u', 'e', '\0' };
Char STRret[]		= { '\n', '\0' };
Char STRnobeep[]	= { 'n', 'o', 'b', 'e', 'e', 'p', '\0' };
Char STRnoambiguous[]	= { 'n', 'o', 'a', 'm', 'b', 'i', 'g', 'u', 'o', 'u', 
X			    's', '\0' };
Char STRvisiblebell[]	= { 'v', 'i', 's', 'i', 'b', 'l', 'e', 'b', 'e', 'l', 
X			    'l', '\0' };
Char STRrecognize_only_executables[] = { 'r', 'e', 'c', 'o', 'g', 'n', 'i', 'z',
X					 'e', '_', 'o', 'n', 'l', 'y', '_', 'e',
X					 'x', 'e', 'c', 'u', 't', 'a', 'b', 'l',
X					 'e', 's', '\0' };
Char STRinputmode[]	= { 'i', 'n', 'p', 'u', 't', 'm', 'o', 'd', 'e', '\0' };
Char STRoverwrite[]	= { 'o', 'v', 'e', 'r', 'w', 'r', 'i', 't', 'e', '\0' };
Char STRinsert[]	= { 'i', 'n', 's', 'e', 'r', 't', '\0' };
Char STRnohup[]		= { 'n', 'o', 'h', 'u', 'p', '\0' };
Char STRnice[]		= { 'n', 'i', 'c', 'e', '\0' };
Char STRlistpathnum[]	= { 'l', 'i', 's', 't', 'p', 'a', 't', 'h', 'n', 'u', 
X			    'm', '\0' };
Char STRshowdots[]	= { 's', 'h', 'o', 'w', 'd', 'o', 't', 's', '\0' };
Char STRthen[]		= { 't', 'h', 'e', 'n', '\0' };
Char STReof[]		= { '^', 'D', '\b', '\b', '\0' };
Char STRlistjobs[]	= { 'l', 'i', 's', 't', 'j', 'o', 'b', 's', '\0' };
Char STRlong[]		= { 'l', 'o', 'n', 'g', '\0' };
Char STRwho[]		= { 'w', 'h', 'o', '\0' };
Char STRrmstar[]        = { 'r', 'm', 's', 't', 'a', 'r', '\0' };
Char STRrm[]            = { 'r', 'm', '\0' };
Char STRshlvl[]		= { 's', 'h', 'l', 'v', 'l', '\0' };
Char STRSHLVL[]		= { 'S', 'H', 'L', 'V', 'L', '\0' };
X
Char STRLANG[]  = { 'L', 'A', 'N', 'G', '\0' };
Char STRLC_CTYPE[] = { 'L', 'C', '_', 'C', 'T', 'Y', 'P', 'E' ,'\0' };
Char STRNOREBIND[] = { 'N', 'O', 'R', 'E', 'B', 'I', 'N', 'D', '\0' };
X
X#ifdef SIG_WINDOW
Char STRLINES[] = { 'L', 'I', 'N', 'E', 'S', '\0'};
Char STRCOLUMNS[] = { 'C', 'O', 'L', 'U', 'M', 'N', 'S', '\0'};
Char STRTERMCAP[] = { 'T', 'E', 'R', 'M', 'C', 'A', 'P', '\0'};
X#endif /* SIG_WINDOW */
X
X#ifdef WARP
Char STRwarp[] = { 'w', 'a', 'r', 'p', '\0' };
X#endif /* WARP */
X
X#ifdef apollo
Char STRSYSTYPE[] = { 'S', 'Y', 'S', 'T', 'Y', 'P', 'E', '\0' };
Char STRoid[] = { 'o', 'i', 'd', '\0' };
Char STRbsd43[] = { 'b', 's', 'd', '4', '.', '3', '\0' };
Char STRsys53[] = { 's', 'y', 's', '5', '.', '3', '\0' };
Char STRver[] = { 'v', 'e', 'r', '\0' };
X#endif /* apollo */
END_OF_FILE
if test 13434 -ne `wc -c <'tc.const.c'`; then
    echo shar: \"'tc.const.c'\" unpacked with wrong size!
fi
# end of 'tc.const.c'
fi
echo shar: End of archive 6 \(of 18\).
cp /dev/null ark6isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
