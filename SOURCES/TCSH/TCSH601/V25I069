Newsgroups: comp.sources.unix
From: christos@ee.cornell.edu (Christos Zoulas)
Subject: v25i069: tcsh6.01 - a csh replacement with lots of extra goodies, Part16/18
Message-ID: <1991Dec20.214632.8040@PA.dec.com>
Date: Fri, 20 Dec 91 21:46:32 GMT
Approved: vixie@pa.dec.com

Submitted-By: christos@ee.cornell.edu (Christos Zoulas)
Posting-Number: Volume 25, Issue 69
Archive-Name: tcsh-6.01/part16

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 16 (of 18)."
# Contents:  sh.proc.c
# Wrapped by vixie@cognition.pa.dec.com on Fri Dec 20 13:29:30 1991
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'sh.proc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sh.proc.c'\"
else
echo shar: Extracting \"'sh.proc.c'\" \(47893 characters\)
sed "s/^X//" >'sh.proc.c' <<'END_OF_FILE'
X/* $Header: /home/hyperion/mu/christos/src/sys/tcsh-6.01/RCS/sh.proc.c,v 3.19 1991/11/26 04:28:26 christos Exp $ */
X/*
X * sh.proc.c: Job manipulations
X */
X/*-
X * Copyright (c) 1980, 1991 The Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by the University of
X *	California, Berkeley and its contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X */
X#include "sh.h"
X
RCSID("$Id: sh.proc.c,v 3.19 1991/11/26 04:28:26 christos Exp $")
X
X#include "ed.h"
X#include "tc.h"
X#include "tc.wait.h"
X
X#if !defined(NSIG) && defined(SIGMAX)
X# define NSIG (SIGMAX+1)
X#endif /* !NSIG && SIGMAX */
X#if !defined(NSIG) && defined(_NSIG)
X# define NSIG _NSIG
X#endif /* !NSIG && _NSIG */
X
X#ifdef aiws
X# undef HZ
X# define HZ 16
X#endif /* aiws */
X
X#ifndef HZ
X# define HZ	100		/* for division into seconds */
X#endif
X
X#if (defined(_BSD) && defined(_BSD_INCLUDES)) || (defined(IRIS4D) && __STDC__)
X# define BSDWAIT
X#endif
X#ifndef WTERMSIG
X# define WTERMSIG(w)	(((union wait *) &(w))->w_termsig)
X# ifndef BSDWAIT
X#  define BSDWAIT
X# endif
X#endif /* !WTERMSIG */
X#ifndef WEXITSTATUS
X# define WEXITSTATUS(w)	(((union wait *) &(w))->w_retcode)
X#endif /* !WEXITSTATUS */
X#ifndef WSTOPSIG
X# define WSTOPSIG(w)	(((union wait *) &(w))->w_stopsig)
X#endif /* WSTOPSIG */
X
X#ifndef WCOREDUMP
X# ifdef BSDWAIT
X#  define WCOREDUMP(w)	(((union wait *) &(w))->w_coredump)
X# else /* !BSDWAIT */
X#  define WCOREDUMP(w)	((w) & 0200)
X# endif /* !BSDWAIT */
X#endif /* !WCOREDUMP */
X
X/*
X * C Shell - functions that manage processes, handling hanging, termination
X */
X
X#define BIGINDEX	9	/* largest desirable job index */
X
X#ifdef BSDTIMES
X# if defined(sun) || defined(hp9000)
static struct rusage zru = {{0L, 0L}, {0L, 0L}, 0L, 0L, 0L, 0L,
X			    0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L};
X
X# else /* !sun && !hp9000 */
X#  ifdef masscomp
X/*
X * Initialization of this structure under RTU 4.1A & RTU 5.0 is problematic
X * because the first two elements are unions of a time_t and a struct timeval.
X * So we'll just have to trust the loader to do the "right thing", DAS DEC-90.
X */
static struct rusage zru;
X#  else	/* masscomp */
static struct rusage zru = {{0L, 0L}, {0L, 0L}, 0, 0, 0, 0, 0, 0, 0, 
X			    0, 0, 0, 0, 0, 0};
X#  endif /* masscomp */
X# endif	/* !sun && !hp9000 */
X#else /* ! BSDTIMES */
X# ifdef _SEQUENT_
static struct process_stats zru = {{0L, 0L}, {0L, 0L}, 0, 0, 0, 0, 0, 0, 0,
X				   0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
X# else /* !_SEQUENT_ */
static struct tms zru = {0L, 0L, 0L, 0L}, lru = {0L, 0L, 0L, 0L};
X# endif	/* !_SEQUENT_ */
X#endif /* !BSDTIMES */
X
X#ifndef RUSAGE_CHILDREN
X# define	RUSAGE_CHILDREN	-1
X#endif
X
static	void		 pflushall	__P((void));
static	void		 pflush		__P((struct process *));
static	void		 pclrcurr	__P((struct process *));
static	void		 padd		__P((struct command *));
static	int		 pprint		__P((struct process *, int));
static	void		 ptprint	__P((struct process *));
static	void		 pads		__P((Char *));
static	void		 pkill		__P((Char **, int));
static	struct process	*pgetcurr	__P((struct process *));
static	void		 okpcntl	__P((void));
X
X/*
X * pchild - called at interrupt level by the SIGCHLD signal
X *	indicating that at least one child has terminated or stopped
X *	thus at least one wait system call will definitely return a
X *	childs status.  Top level routines (like pwait) must be sure
X *	to mask interrupts when playing with the proclist data structures!
X */
sigret_t
X/*ARGSUSED*/
pchild(snum)
int snum;
X{
X    register struct process *pp;
X    register struct process *fp;
X    register int pid;
X    extern int insource;
X#ifdef BSDWAIT
X    union wait w;
X#else /* !BSDWAIT */
X    int     w;
X#endif /* !BSDWAIT */
X    int     jobflags;
X#ifdef BSDTIMES
X    struct rusage ru;
X#else /* !BSDTIMES */
X# ifdef _SEQUENT_
X    struct process_stats ru;
X    struct process_stats cpst1, cpst2;
X    timeval_t tv;
X# else /* !_SEQUENT_ */
X    struct tms proctimes;
X
X    if (!timesdone) {
X	timesdone++;
X	(void) times(&shtimes);
X    }
X# endif	/* _SEQUENT_ */
X#endif /* BSDTIMES */
X
X#ifdef JOBDEBUG
X    xprintf("pchild()\n");
X#endif	/* JOBDEBUG */
X
X/* Christos on where the signal(SIGCHLD, pchild) shoud be:
X *
X * I think that it should go *after* the wait, unlike most signal handlers.
X *
X * In release two (for which I have manuals), it says that wait will remove
X * the first child from the queue of dead children.
X * All the rest of the children that die while in the signal handler of the
X * SIGC(H)LD, will be placed in the queue. If signal is called to re-establish
X * the signal handler, and there are items in the queue, the process will
X * receive another SIGC(H)LD before signal returns. BTW this is from the
X * manual page on comp-sim... Maybe it is not applicable to the hp's, but
X * I read on the news in comp.unix.wizards or comp.unix.questions yesterday
X * that another person was claiming the the signal() call should be after
X * the wait().
X */
X
loop:
X    errno = 0;			/* reset, just in case */
X#ifdef JOBDEBUG
X    xprintf("Waiting...\n");
X    flush();
X#endif
X#ifdef BSDJOBS
X# ifdef BSDTIMES
X    /* both a wait3 and rusage */
X#  if !defined(BSDWAIT) || defined(NeXT) || (defined(IRIS4D) && __STDC__)
X    pid = wait3(&w,
X       (setintr && (intty || insource) ? WNOHANG | WUNTRACED : WNOHANG), &ru);
X#  else /* BSDWAIT */
X    pid = wait3(&w.w_status,
X       (setintr && (intty || insource) ? WNOHANG | WUNTRACED : WNOHANG), &ru);
X#  endif /* BSDWAIT */
X# else /* !BSDTIMES */
X#  ifdef _SEQUENT_
X    (void) get_process_stats(&tv, PS_SELF, 0, &cpst1);
X    pid = waitpid(-1, &w,
X	    (setintr && (intty || insource) ? WNOHANG | WUNTRACED : WNOHANG));
X    (void) get_process_stats(&tv, PS_SELF, 0, &cpst2);
X    pr_stat_sub(&cpst2, &cpst1, &ru);
X#  else	/* !_SEQUENT_ */
X#   ifndef POSIX
X    /* we have a wait3, but no rusage stuff */
X    pid = wait3(&w.w_status,
X	 (setintr && (intty || insource) ? WNOHANG | WUNTRACED : WNOHANG), 0);
X#   else /* POSIX */
X    pid = waitpid(-1, &w,
X	    (setintr && (intty || insource) ? WNOHANG | WUNTRACED : WNOHANG));
X#   endif /* POSIX */
X#  endif /* !_SEQUENT_ */
X# endif	/* !BSDTIMES */
X#else /* !BSDJOBS */
X# ifdef BSDTIMES
X#  define HAVEwait3
X    /* both a wait3 and rusage */
X#  ifdef hpux
X    pid = wait3(&w.w_status, WNOHANG, 0);
X#  else	/* !hpux */
X    pid = wait3(&w.w_status, WNOHANG, &ru);
X#  endif /* !hpux */
X# else /* !BSDTIMES */
X# ifdef ODT  /* For Sco Unix 3.2.0 or ODT 1.0 */
X#  define HAVEwait3
X    pid = waitpid(-1, &w,
X	    (setintr && (intty || insource) ? WNOHANG | WUNTRACED : WNOHANG));
X# endif /* ODT */	    
X# if defined(aiws) || defined(uts)
X#  define HAVEwait3
X    pid = wait3(&w.w_status, 
X	(setintr && (intty || insource) ? WNOHANG | WUNTRACED : WNOHANG), 0);
X# endif /* aiws || uts */
X# ifndef HAVEwait3
X#  ifdef UNRELSIGS
X    /* no wait3, therefore no rusage */
X    /* on Sys V, this may hang.  I hope it's not going to be a problem */
X#   ifdef _MINIX
X    pid = wait(&w);
X#   else /* !_MINIX */
X    pid = ourwait(&w.w_status);
X#   endif /* _MINIX */
X#  else	/* UNRELSIGS */
X    /* 
X     * XXX: for greater than 3 we should use waitpid(). 
X     * but then again, SVR4 falls into the POSIX/BSDJOBS category.
X     */
X    pid = wait(&w.w_status);
X#  endif /* SVID >= 3 */
X# endif /* HAVEwait3 */
X# endif	/* BSDTIMES */
X# ifndef BSDSIGS
X    (void) sigset(SIGCHLD, pchild);
X# endif /* !BSDSIGS */
X#endif /* BSDJOBS */
X
X#ifdef JOBDEBUG
X    {
X	char    buffer[100];
X	xsprintf(buffer, "pid %d, retval %x termsig %x retcode %x\n",
X		 pid, w, WTERMSIG(w), WEXITSTATUS(w));
X	xprintf(buffer);
X	flush();
X    }
X#endif /* JOBDEBUG */
X
X    if (pid <= 0) {
X#ifdef JOBDEBUG
X	xprintf("errno == %d\n", errno);
X#endif
X	if (errno == EINTR) {
X	    errno = 0;
X	    goto loop;
X	}
X	pnoprocesses = pid == -1;
X#ifndef SIGVOID
X	return (0);
X#else /* !SIGVOID */
X	return;
X#endif /* SIGVOID */
X    }
X    for (pp = proclist.p_next; pp != NULL; pp = pp->p_next)
X	if (pid == pp->p_procid)
X	    goto found;
X#ifndef BSDJOBS
X    /* this should never have happened */
X    stderror(ERR_SYNC, pid);
X    xexit(0);
X#else /* BSDJOBS */
X    goto loop;
X#endif /* BSDJOBS */
found:
X    if (pid == atoi(short2str(value(STRchild))))
X	unsetv(STRchild);
X    pp->p_flags &= ~(PRUNNING | PSTOPPED | PREPORTED);
X    if (WIFSTOPPED(w)) {
X	pp->p_flags |= PSTOPPED;
X	pp->p_reason = WSTOPSIG(w);
X    }
X    else {
X	if (pp->p_flags & (PTIME | PPTIME) || adrof(STRtime))
X#ifndef BSDTIMES
X# ifdef _SEQUENT_
X	    (void) get_process_stats(&pp->p_etime, PS_SELF, NULL, NULL);
X# else	/* !_SEQUENT_ */
X	    pp->p_etime = times(&proctimes);
X# endif	/* !_SEQUENT_ */
X#else /* BSDTIMES */
X	    (void) gettimeofday(&pp->p_etime, NULL);
X#endif /* BSDTIMES */
X
X
X#if defined(BSDTIMES) || defined(_SEQUENT_)
X	pp->p_rusage = ru;
X#else /* !BSDTIMES && !_SEQUENT_ */
X	(void) times(&proctimes);
X	pp->p_utime = proctimes.tms_cutime - shtimes.tms_cutime;
X	pp->p_stime = proctimes.tms_cstime - shtimes.tms_cstime;
X	shtimes = proctimes;
X#endif /* !BSDTIMES && !_SEQUENT_ */
X	if (WIFSIGNALED(w)) {
X	    if (WTERMSIG(w) == SIGINT)
X		pp->p_flags |= PINTERRUPTED;
X	    else
X		pp->p_flags |= PSIGNALED;
X	    if (WCOREDUMP(w))
X		pp->p_flags |= PDUMPED;
X	    pp->p_reason = WTERMSIG(w);
X	}
X	else {
X	    pp->p_reason = WEXITSTATUS(w);
X	    if (pp->p_reason != 0)
X		pp->p_flags |= PAEXITED;
X	    else
X		pp->p_flags |= PNEXITED;
X	}
X    }
X    jobflags = 0;
X    fp = pp;
X    do {
X	if ((fp->p_flags & (PPTIME | PRUNNING | PSTOPPED)) == 0 &&
X	    !child && adrof(STRtime) &&
X#ifdef BSDTIMES
X	    fp->p_rusage.ru_utime.tv_sec + fp->p_rusage.ru_stime.tv_sec
X#else /* !BSDTIMES */
X# ifdef _SEQUENT_
X	    fp->p_rusage.ps_utime.tv_sec + fp->p_rusage.ps_stime.tv_sec
X# else /* !_SEQUENT_ */
X#  ifndef POSIX
X	    (fp->p_utime + fp->p_stime) / HZ
X#  else /* POSIX */
X	    (fp->p_utime + fp->p_stime) / CLK_TCK
X#  endif /* POSIX */
X# endif /* !_SEQUENT_ */
X#endif /* !BSDTIMES */
X	    >= atoi(short2str(value(STRtime))))
X	    fp->p_flags |= PTIME;
X	jobflags |= fp->p_flags;
X    } while ((fp = fp->p_friends) != pp);
X    pp->p_flags &= ~PFOREGND;
X    if (pp == pp->p_friends && (pp->p_flags & PPTIME)) {
X	pp->p_flags &= ~PPTIME;
X	pp->p_flags |= PTIME;
X    }
X    if ((jobflags & (PRUNNING | PREPORTED)) == 0) {
X	fp = pp;
X	do {
X	    if (fp->p_flags & PSTOPPED)
X		fp->p_flags |= PREPORTED;
X	} while ((fp = fp->p_friends) != pp);
X	while (fp->p_procid != fp->p_jobid)
X	    fp = fp->p_friends;
X	if (jobflags & PSTOPPED) {
X	    if (pcurrent && pcurrent != fp)
X		pprevious = pcurrent;
X	    pcurrent = fp;
X	}
X	else
X	    pclrcurr(fp);
X	if (jobflags & PFOREGND) {
X	    if (jobflags & (PSIGNALED | PSTOPPED | PPTIME) ||
X#ifdef IIASA
X		jobflags & PAEXITED ||
X#endif /* IIASA */
X		!eq(dcwd->di_name, fp->p_cwd->di_name)) {
X		;		/* print in pjwait */
X	    }
X	    /* PWP: print a newline after ^C */
X	    else if (jobflags & PINTERRUPTED)
X#ifdef SHORT_STRINGS
X		xputchar('\r' | QUOTE), xputchar('\n');
X#else /* !SHORT_STRINGS */
X		xprintf("\215\n");	/* \215 is a quoted ^M */
X#endif /* !SHORT_STRINGS */
X#ifdef notdef
X		else if ((jobflags & (PTIME|PSTOPPED)) == PTIME)
X				ptprint(fp);
X#endif
X	}
X	else {
X	    if (jobflags & PNOTIFY || adrof(STRnotify)) {
X#ifdef SHORT_STRINGS
X		xputchar('\r' | QUOTE), xputchar('\n');
X#else /* !SHORT_STRINGS */
X		xprintf("\215\n");	/* \215 is a quoted ^M */
X#endif /* !SHORT_STRINGS */
X		(void) pprint(pp, NUMBER | NAME | REASON);
X		if ((jobflags & PSTOPPED) == 0)
X		    pflush(pp);
X		{
X		    extern Char GettingInput;
X
X		    if (GettingInput) {
X			errno = 0;
X			(void) Rawmode();
X			ClearLines();
X			ClearDisp();
X			Refresh();
X		    }
X		}
X	    }
X	    else {
X		fp->p_flags |= PNEEDNOTE;
X		neednote++;
X	    }
X	}
X    }
X#if defined(BSDJOBS) || defined(HAVEwait3)
X    goto loop;
X#endif /* BSDJOBS || HAVEwait3 */
X}
X
void
pnote()
X{
X    register struct process *pp;
X    int     flags;
X#ifdef BSDSIGS
X    sigmask_t omask;
X#endif /* BSDSIGS */
X
X    neednote = 0;
X    for (pp = proclist.p_next; pp != NULL; pp = pp->p_next) {
X	if (pp->p_flags & PNEEDNOTE) {
X#ifdef BSDSIGS
X	    omask = sigblock(sigmask(SIGCHLD));
X#else /* !BSDSIGS */
X	    (void) sighold(SIGCHLD);
X#endif /* !BSDSIGS */
X	    pp->p_flags &= ~PNEEDNOTE;
X	    flags = pprint(pp, NUMBER | NAME | REASON);
X	    if ((flags & (PRUNNING | PSTOPPED)) == 0)
X		pflush(pp);
X#ifdef BSDSIGS
X	    (void) sigsetmask(omask);
X#else /* !BSDSIGS */
X	    (void) sigrelse(SIGCHLD);
X#endif /* !BSDSIGS */
X	}
X    }
X}
X
X/*
X * pwait - wait for current job to terminate, maintaining integrity
X *	of current and previous job indicators.
X */
void
pwait()
X{
X    register struct process *fp, *pp;
X#ifdef BSDSIGS
X    sigmask_t omask;
X#endif /* BSDSIGS */
X
X    /*
X     * Here's where dead procs get flushed.
X     */
X#ifdef BSDSIGS
X    omask = sigblock(sigmask(SIGCHLD));
X#else /* !BSDSIGS */
X    (void) sighold(SIGCHLD);
X#endif /* !BSDSIGS */
X    for (pp = (fp = &proclist)->p_next; pp != NULL; pp = (fp = pp)->p_next)
X	if (pp->p_procid == 0) {
X	    fp->p_next = pp->p_next;
X	    xfree((ptr_t) pp->p_command);
X	    if (pp->p_cwd && --pp->p_cwd->di_count == 0)
X		if (pp->p_cwd->di_next == 0)
X		    dfree(pp->p_cwd);
X	    xfree((ptr_t) pp);
X	    pp = fp;
X	}
X#ifdef BSDSIGS
X    (void) sigsetmask(omask);
X#else /* !BSDSIGS */
X    (void) sigrelse(SIGCHLD);
X# ifdef notdef
X    if (setintr)
X	sigignore(SIGINT);
X# endif
X#endif /* !BSDSIGS */
X    pjwait(pcurrjob);
X}
X
X
X/*
X * pjwait - wait for a job to finish or become stopped
X *	It is assumed to be in the foreground state (PFOREGND)
X */
void
pjwait(pp)
X    register struct process *pp;
X{
X    register struct process *fp;
X    int     jobflags, reason;
X#ifdef BSDSIGS
X    sigmask_t omask;
X#endif /* BSDSIGS */
X#ifdef UNRELSIGS
X    sigret_t (*inthandler)();
X#endif /* UNRELSIGS */
X
X    while (pp->p_procid != pp->p_jobid)
X	pp = pp->p_friends;
X    fp = pp;
X
X    do {
X	if ((fp->p_flags & (PFOREGND | PRUNNING)) == PRUNNING)
X	    xprintf("BUG: waiting for background job!\n");
X    } while ((fp = fp->p_friends) != pp);
X    /*
X     * Now keep pausing as long as we are not interrupted (SIGINT), and the
X     * target process, or any of its friends, are running
X     */
X    fp = pp;
X#ifdef BSDSIGS
X    omask = sigblock(sigmask(SIGCHLD));
X#endif /* BSDSIGS */
X#ifdef UNRELSIGS
X    if (setintr)
X        inthandler = signal(SIGINT, SIG_IGN);
X#endif /* UNRELSIGS */
X    for (;;) {
X#ifndef BSDSIGS
X	(void) sighold(SIGCHLD);
X#endif /* !BSDSIGS */
X	jobflags = 0;
X	do
X	    jobflags |= fp->p_flags;
X	while ((fp = (fp->p_friends)) != pp);
X	if ((jobflags & PRUNNING) == 0)
X	    break;
X#ifdef JOBDEBUG
X	xprintf("starting to sigpause for  SIGCHLD on %d\n", fp->p_procid);
X#endif /* JOBDEBUG */
X#ifdef BSDSIGS
X	/* sigpause(sigblock((sigmask_t) 0) &~ sigmask(SIGCHLD)); */
X	(void) sigpause(omask & ~sigmask(SIGCHLD));
X#else /* !BSDSIGS */
X	(void) sigpause(SIGCHLD);
X#endif /* !BSDSIGS */
X    }
X#ifdef BSDSIGS
X    (void) sigsetmask(omask);
X#else /* !BSDSIGS */
X    (void) sigrelse(SIGCHLD);
X#endif /* !BSDSIGS */
X#ifdef UNRELSIGS
X    if (setintr)
X        (void) signal(SIGINT, inthandler);
X#endif /* UNRELSIGS */
X#ifdef BSDJOBS
X    if (tpgrp > 0)		/* get tty back */
X	(void) tcsetpgrp(FSHTTY, tpgrp);
X#endif /* BSDJOBS */
X    if ((jobflags & (PSIGNALED | PSTOPPED | PTIME)) ||
X	!eq(dcwd->di_name, fp->p_cwd->di_name)) {
X	if (jobflags & PSTOPPED) {
X	    xprintf("\n");
X	    if (adrof(STRlistjobs)) {
X		Char   *jobcommand[3];
X
X		jobcommand[0] = STRjobs;
X		if (eq(value(STRlistjobs), STRlong))
X		    jobcommand[1] = STRml;
X		else
X		    jobcommand[1] = NULL;
X		jobcommand[2] = NULL;
X
X		dojobs(jobcommand, NULL);
X		(void) pprint(pp, SHELLDIR);
X	    }
X	    else
X		(void) pprint(pp, AREASON | SHELLDIR);
X	}
X	else
X	    (void) pprint(pp, AREASON | SHELLDIR);
X    }
X    if ((jobflags & (PINTERRUPTED | PSTOPPED)) && setintr &&
X	(!gointr || !eq(gointr, STRminus))) {
X	if ((jobflags & PSTOPPED) == 0)
X	    pflush(pp);
X	pintr1(0);
X	/* NOTREACHED */
X    }
X    reason = 0;
X    fp = pp;
X    do {
X	if (fp->p_reason)
X	    reason = fp->p_flags & (PSIGNALED | PINTERRUPTED) ?
X		fp->p_reason | META : fp->p_reason;
X    } while ((fp = fp->p_friends) != pp);
X    if ((reason != 0) && (adrof(STRprintexitvalue)))	/* PWP */
X	xprintf("Exit %d\n", reason);
X    set(STRstatus, putn(reason));
X    if (reason && exiterr)
X	exitstat();
X    pflush(pp);
X}
X
X/*
X * dowait - wait for all processes to finish
X */
X
X/*ARGSUSED*/
void
dowait(v, c)
X    Char **v;
X    struct command *c;
X{
X    register struct process *pp;
X#ifdef BSDSIGS
X    sigmask_t omask;
X#endif /* BSDSIGS */
X
X    pjobs++;
X#ifdef BSDSIGS
X    omask = sigblock(sigmask(SIGCHLD));
loop:
X#else /* !BSDSIGS */
X    if (setintr)
X	(void) sigrelse(SIGINT);
loop:
X    (void) sighold(SIGCHLD);
X#endif /* !BSDSIGS */
X    for (pp = proclist.p_next; pp; pp = pp->p_next)
X	if (pp->p_procid &&	/* pp->p_procid == pp->p_jobid && */
X	    pp->p_flags & PRUNNING) {
X#ifdef BSDSIGS
X	    (void) sigpause((sigmask_t) 0);
X#else /* !BSDSIGS */
X	    (void) sigpause(SIGCHLD);
X#endif /* !BSDSIGS */
X	    goto loop;
X	}
X#ifdef BSDSIGS
X    (void) sigsetmask(omask);
X#else /* !BSDSIGS */
X    (void) sigrelse(SIGCHLD);
X#endif /* !BSDSIGS */
X    pjobs = 0;
X}
X
X/*
X * pflushall - flush all jobs from list (e.g. at fork())
X */
static void
pflushall()
X{
X    register struct process *pp;
X
X    for (pp = proclist.p_next; pp != NULL; pp = pp->p_next)
X	if (pp->p_procid)
X	    pflush(pp);
X}
X
X/*
X * pflush - flag all process structures in the same job as the
X *	the argument process for deletion.  The actual free of the
X *	space is not done here since pflush is called at interrupt level.
X */
static void
pflush(pp)
X    register struct process *pp;
X{
X    register struct process *np;
X    register int idx;
X
X    if (pp->p_procid == 0) {
X	xprintf("BUG: process flushed twice");
X	return;
X    }
X    while (pp->p_procid != pp->p_jobid)
X	pp = pp->p_friends;
X    pclrcurr(pp);
X    if (pp == pcurrjob)
X	pcurrjob = 0;
X    idx = pp->p_index;
X    np = pp;
X    do {
X	np->p_index = np->p_procid = 0;
X	np->p_flags &= ~PNEEDNOTE;
X    } while ((np = np->p_friends) != pp);
X    if (idx == pmaxindex) {
X	for (np = proclist.p_next, idx = 0; np; np = np->p_next)
X	    if (np->p_index > idx)
X		idx = np->p_index;
X	pmaxindex = idx;
X    }
X}
X
X/*
X * pclrcurr - make sure the given job is not the current or previous job;
X *	pp MUST be the job leader
X */
static void
pclrcurr(pp)
X    register struct process *pp;
X{
X    if (pp == pcurrent)
X	if (pprevious != NULL) {
X	    pcurrent = pprevious;
X	    pprevious = pgetcurr(pp);
X	}
X	else {
X	    pcurrent = pgetcurr(pp);
X	    pprevious = pgetcurr(pp);
X	}
X    else if (pp == pprevious)
X	pprevious = pgetcurr(pp);
X}
X
X/* +4 here is 1 for '\0', 1 ea for << >& >> */
static Char command[PMAXLEN + 4];
static int cmdlen;
static Char *cmdp;
X
X/*
X * palloc - allocate a process structure and fill it up.
X *	an important assumption is made that the process is running.
X */
void
palloc(pid, t)
X    int     pid;
X    register struct command *t;
X{
X    register struct process *pp;
X    int     i;
X
X    pp = (struct process *) xcalloc(1, (size_t) sizeof(struct process));
X    pp->p_procid = pid;
X    pp->p_flags = t->t_dflg & F_AMPERSAND ? PRUNNING : PRUNNING | PFOREGND;
X    if (t->t_dflg & F_TIME)
X	pp->p_flags |= PPTIME;
X    cmdp = command;
X    cmdlen = 0;
X    padd(t);
X    *cmdp++ = 0;
X    if (t->t_dflg & F_PIPEOUT) {
X	pp->p_flags |= PPOU;
X	if (t->t_dflg & F_STDERR)
X	    pp->p_flags |= PDIAG;
X    }
X    pp->p_command = Strsave(command);
X    if (pcurrjob) {
X	struct process *fp;
X
X	/* careful here with interrupt level */
X	pp->p_cwd = 0;
X	pp->p_index = pcurrjob->p_index;
X	pp->p_friends = pcurrjob;
X	pp->p_jobid = pcurrjob->p_procid;
X	for (fp = pcurrjob; fp->p_friends != pcurrjob; fp = fp->p_friends);
X	fp->p_friends = pp;
X    }
X    else {
X	pcurrjob = pp;
X	pp->p_jobid = pid;
X	pp->p_friends = pp;
X	pp->p_cwd = dcwd;
X	dcwd->di_count++;
X	if (pmaxindex < BIGINDEX)
X	    pp->p_index = ++pmaxindex;
X	else {
X	    struct process *np;
X
X	    for (i = 1;; i++) {
X		for (np = proclist.p_next; np; np = np->p_next)
X		    if (np->p_index == i)
X			goto tryagain;
X		pp->p_index = i;
X		if (i > pmaxindex)
X		    pmaxindex = i;
X		break;
X	tryagain:;
X	    }
X	}
X	if (pcurrent == NULL)
X	    pcurrent = pp;
X	else if (pprevious == NULL)
X	    pprevious = pp;
X    }
X    pp->p_next = proclist.p_next;
X    proclist.p_next = pp;
X#ifdef BSDTIMES
X    (void) gettimeofday(&pp->p_btime, NULL);
X#else /* !BSDTIMES */
X# ifdef _SEQUENT_
X    (void) get_process_stats(&pp->p_btime, PS_SELF, NULL, NULL);
X# else /* !_SEQUENT_ */
X    {
X	struct tms tmptimes;
X
X	pp->p_btime = times(&tmptimes);
X    }
X# endif /* !_SEQUENT_ */
X#endif /* !BSDTIMES */
X}
X
static void
padd(t)
X    register struct command *t;
X{
X    Char  **argp;
X
X    if (t == 0)
X	return;
X    switch (t->t_dtyp) {
X
X    case NODE_PAREN:
X	pads(STRLparensp);
X	padd(t->t_dspr);
X	pads(STRspRparen);
X	break;
X
X    case NODE_COMMAND:
X	for (argp = t->t_dcom; *argp; argp++) {
X	    pads(*argp);
X	    if (argp[1])
X		pads(STRspace);
X	}
X	break;
X
X    case NODE_OR:
X    case NODE_AND:
X    case NODE_PIPE:
X    case NODE_LIST:
X	padd(t->t_dcar);
X	switch (t->t_dtyp) {
X	case NODE_OR:
X	    pads(STRspor2sp);
X	    break;
X	case NODE_AND:
X	    pads(STRspand2sp);
X	    break;
X	case NODE_PIPE:
X	    pads(STRsporsp);
X	    break;
X	case NODE_LIST:
X	    pads(STRsemisp);
X	    break;
X	default:
X	    break;
X	}
X	padd(t->t_dcdr);
X	return;
X
X    default:
X	break;
X    }
X    if ((t->t_dflg & F_PIPEIN) == 0 && t->t_dlef) {
X	pads((t->t_dflg & F_READ) ? STRspLarrow2sp : STRspLarrowsp);
X	pads(t->t_dlef);
X    }
X    if ((t->t_dflg & F_PIPEOUT) == 0 && t->t_drit) {
X	pads((t->t_dflg & F_APPEND) ? STRspRarrow2 : STRspRarrow);
X	if (t->t_dflg & F_STDERR)
X	    pads(STRand);
X	pads(STRspace);
X	pads(t->t_drit);
X    }
X}
X
static void
pads(cp)
X    Char   *cp;
X{
X    register int i;
X
X    /*
X     * Avoid the Quoted Space alias hack! Reported by:
X     * sam@john-bigboote.ICS.UCI.EDU (Sam Horrocks)
X     */
X    if (cp[0] == STRQNULL[0])
X	cp++;
X
X    i = Strlen(cp);
X
X    if (cmdlen >= PMAXLEN)
X	return;
X    if (cmdlen + i >= PMAXLEN) {
X	(void) Strcpy(cmdp, STRsp3dots);
X	cmdlen = PMAXLEN;
X	cmdp += 4;
X	return;
X    }
X    (void) Strcpy(cmdp, cp);
X    cmdp += i;
X    cmdlen += i;
X}
X
X/*
X * psavejob - temporarily save the current job on a one level stack
X *	so another job can be created.  Used for { } in exp6
X *	and `` in globbing.
X */
void
psavejob()
X{
X    pholdjob = pcurrjob;
X    pcurrjob = NULL;
X}
X
X/*
X * prestjob - opposite of psavejob.  This may be missed if we are interrupted
X *	somewhere, but pendjob cleans up anyway.
X */
void
prestjob()
X{
X    pcurrjob = pholdjob;
X    pholdjob = NULL;
X}
X
X/*
X * pendjob - indicate that a job (set of commands) has been completed
X *	or is about to begin.
X */
void
pendjob()
X{
X    register struct process *pp, *tp;
X
X    if (pcurrjob && (pcurrjob->p_flags & (PFOREGND | PSTOPPED)) == 0) {
X	pp = pcurrjob;
X	while (pp->p_procid != pp->p_jobid)
X	    pp = pp->p_friends;
X	xprintf("[%d]", pp->p_index);
X	tp = pp;
X	do {
X	    xprintf(" %d", pp->p_procid);
X	    pp = pp->p_friends;
X	} while (pp != tp);
X	xprintf("\n");
X    }
X    pholdjob = pcurrjob = 0;
X}
X
X/*
X * pprint - print a job
X */
X
X/*
X * Hacks have been added for SVR4 to deal with pipe's being spawned in
X * reverse order
X *
X * David Dawes (dawes@physics.su.oz.au) Oct 1991
X */
X
static int
pprint(pp, flag)
X    register struct process *pp;
X    bool    flag;
X{
X    register status, reason;
X    struct process *tp;
X    extern char *linp, linbuf[];
X    int     jobflags, pstatus, pcond;
X    char   *format;
X
X#ifdef BACKPIPE
X    struct process *pipehead, *pipetail, *pmarker;
X    int inpipe = 0;
X#endif /* BACKPIPE */
X
X    while (pp->p_procid != pp->p_jobid)
X	pp = pp->p_friends;
X    if (pp == pp->p_friends && (pp->p_flags & PPTIME)) {
X	pp->p_flags &= ~PPTIME;
X	pp->p_flags |= PTIME;
X    }
X    tp = pp;
X    status = reason = -1;
X    jobflags = 0;
X    do {
X#ifdef BACKPIPE
X	/*
X	 * The pipeline is reversed, so locate the real head of the pipeline
X	 * if pp is at the tail of a pipe (and not already in a pipeline)
X	 */
X	if ((pp->p_friends->p_flags & PPOU) && !inpipe && (flag & NAME)) {
X	    inpipe = 1;
X	    pipetail = pp;
X	    do 
X		pp = pp->p_friends;
X	    while (pp->p_friends->p_flags & PPOU);
X	    pipehead = pp;
X	    pmarker = pp;
X	/*
X	 * pmarker is used to hold the place of the proc being processed, so
X	 * we can search for the next one downstream later.
X	 */
X	}
X	pcond = (tp != pp || (inpipe && tp == pp));
X#else /* !BACKPIPE */
X	pcond = (tp != pp);
X#endif /* BACKPIPE */	    
X
X	jobflags |= pp->p_flags;
X	pstatus = pp->p_flags & PALLSTATES;
X	if (pcond && linp != linbuf && !(flag & FANCY) &&
X	    ((pstatus == status && pp->p_reason == reason) ||
X	     !(flag & REASON)))
X	    xprintf(" ");
X	else {
X	    if (pcond && linp != linbuf)
X		xprintf("\n");
X	    if (flag & NUMBER) {
X#ifdef BACKPIPE
X		pcond = ((pp == tp && !inpipe) ||
X			 (inpipe && pipetail == tp && pp == pipehead));
X#else /* BACKPIPE */
X		pcond = (pp == tp);
X#endif /* BACKPIPE */
X		if (pcond)
X		    xprintf("[%d]%s %c ", pp->p_index,
X			    pp->p_index < 10 ? " " : "",
X			    pp == pcurrent ? '+' :
X			    (pp == pprevious ? '-' : ' '));
X		else
X		    xprintf("       ");
X	    }
X	    if (flag & FANCY) {
X#ifdef TCF
X		extern char *sitename();
X
X#endif /* TCF */
X		xprintf("%5d ", pp->p_procid);
X#ifdef TCF
X		xprintf("%11s ", sitename(pp->p_procid));
X#endif /* TCF */
X	    }
X	    if (flag & (REASON | AREASON)) {
X		if (flag & NAME)
X#ifdef SUSPENDED
X		    format = "%-23s";
X#else /* !SUSPENDED */
X		    format = "%-21s";
X#endif /* !SUSPENDED */
X		else
X		    format = "%s";
X		if (pstatus == status)
X		    if (pp->p_reason == reason) {
X			xprintf(format, "");
X			goto prcomd;
X		    }
X		    else
X			reason = pp->p_reason;
X		else {
X		    status = pstatus;
X		    reason = pp->p_reason;
X		}
X		switch (status) {
X
X		case PRUNNING:
X		    xprintf(format, "Running ");
X		    break;
X
X		case PINTERRUPTED:
X		case PSTOPPED:
X		case PSIGNALED:
X		    /*
X		     * tell what happened to the background job
X		     * From: Michael Schroeder 
X		     * <mlschroe@immd4.informatik.uni-erlangen.de>
X		     */
X		    if ((flag & REASON)
X			|| ((flag & AREASON)
X			    && reason != SIGINT
X			    && (reason != SIGPIPE
X				|| (pp->p_flags & PPOU) == 0)))
X			xprintf(format, mesg[pp->p_reason & ASCII].pname);
X		    else
X			reason = -1;
X		    break;
X
X		case PNEXITED:
X		case PAEXITED:
X		    if (flag & REASON)
X			if (pp->p_reason)
X#ifdef SUSPENDED
X			    xprintf("Exit %-18d", pp->p_reason);
X#else /* SUSPENDED */
X			    xprintf("Exit %-16d", pp->p_reason);
X#endif /* SUSPENDED */
X			else
X			    xprintf(format, "Done");
X		    break;
X
X		default:
X		    xprintf("BUG: status=%-9o", status);
X		}
X	    }
X	}
prcomd:
X	if (flag & NAME) {
X	    xprintf("%s", short2str(pp->p_command));
X	    if (pp->p_flags & PPOU)
X		xprintf(" |");
X	    if (pp->p_flags & PDIAG)
X		xprintf("&");
X	}
X	if (flag & (REASON | AREASON) && pp->p_flags & PDUMPED)
X	    xprintf(" (core dumped)");
X	if (tp == pp->p_friends) {
X	    if (flag & AMPERSAND)
X		xprintf(" &");
X	    if (flag & JOBDIR &&
X		!eq(tp->p_cwd->di_name, dcwd->di_name)) {
X		xprintf(" (wd: ");
X		dtildepr(value(STRhome), tp->p_cwd->di_name);
X		xprintf(")");
X	    }
X	}
X	if (pp->p_flags & PPTIME && !(status & (PSTOPPED | PRUNNING))) {
X	    if (linp != linbuf)
X		xprintf("\n\t");
X#if defined(BSDTIMES) || defined(_SEQUENT_)
X	    prusage(&zru, &pp->p_rusage, &pp->p_etime,
X		    &pp->p_btime);
X#else /* !BSDTIMES && !SEQUENT */
X	    lru.tms_utime = pp->p_utime;
X	    lru.tms_stime = pp->p_stime;
X	    lru.tms_cutime = 0;
X	    lru.tms_cstime = 0;
X	    prusage(&zru, &lru, pp->p_etime,
X		    pp->p_btime);
X#endif /* !BSDTIMES && !SEQUENT */
X
X	}
X#ifdef BACKPIPE
X	pcond = ((tp == pp->p_friends && !inpipe) ||
X		 (inpipe && pipehead->p_friends == tp && pp == pipetail));
X#else  /* !BACKPIPE */
X	pcond = (tp == pp->p_friends);
X#endif /* BACKPIPE */
X	if (pcond) {
X	    if (linp != linbuf)
X		xprintf("\n");
X	    if (flag & SHELLDIR && !eq(tp->p_cwd->di_name, dcwd->di_name)) {
X		xprintf("(wd now: ");
X		dtildepr(value(STRhome), dcwd->di_name);
X		xprintf(")\n");
X	    }
X	}
X#ifdef BACKPIPE
X	if (inpipe) {
X	    /*
X	     * if pmaker == pipetail, we are finished that pipeline, and
X	     * can now skip to past the head
X	     */
X	    if (pmarker == pipetail) {
X		inpipe = 0;
X		pp = pipehead;
X	    }
X	    else {
X	    /*
X	     * set pp to one before the one we want next, so the while below
X	     * increments to the correct spot.
X	     */
X		do
X		    pp = pp->p_friends;
X	    	while (pp->p_friends->p_friends != pmarker);
X	    	pmarker = pp->p_friends;
X	    }
X	}
X	pcond = ((pp = pp->p_friends) != tp || inpipe);
X#else /* !BACKPIPE */
X	pcond = ((pp = pp->p_friends) != tp);
X#endif /* BACKPIPE */
X    } while (pcond);
X
X    if (jobflags & PTIME && (jobflags & (PSTOPPED | PRUNNING)) == 0) {
X	if (jobflags & NUMBER)
X	    xprintf("       ");
X	ptprint(tp);
X    }
X    return (jobflags);
X}
X
static void
ptprint(tp)
X    register struct process *tp;
X{
X#ifdef BSDTIMES
X    struct timeval tetime, diff;
X    static struct timeval ztime;
X    struct rusage ru;
X    static struct rusage zru;
X    register struct process *pp = tp;
X
X    ru = zru;
X    tetime = ztime;
X    do {
X	ruadd(&ru, &pp->p_rusage);
X	tvsub(&diff, &pp->p_etime, &pp->p_btime);
X	if (timercmp(&diff, &tetime, >))
X	    tetime = diff;
X    } while ((pp = pp->p_friends) != tp);
X    prusage(&zru, &ru, &tetime, &ztime);
X#else /* !BSDTIMES */
X# ifdef _SEQUENT_
X#  define timercmp(tvp, uvp, cmp) \
X      ((tvp)->tv_sec cmp (uvp)->tv_sec || \
X       (tvp)->tv_sec == (uvp)->tv_sec && (tvp)->tv_usec cmp (uvp)->tv_usec)
X    timeval_t tetime, diff;
X    static timeval_t ztime;
X    struct process_stats ru;
X    static struct process_stats zru;
X    register struct process *pp = tp;
X
X    ru = zru;
X    tetime = ztime;
X    do {
X	ruadd(&ru, &pp->p_rusage);
X	tvsub(&diff, &pp->p_etime, &pp->p_btime);
X	if (timercmp(&diff, &tetime, >))
X	    tetime = diff;
X    } while ((pp = pp->p_friends) != tp);
X    prusage(&zru, &ru, &tetime, &ztime);
X# else /* !_SEQUENT_ */
X#  ifndef POSIX
X    static time_t ztime = 0;
X    static time_t zu_time = 0;
X    static time_t zs_time = 0;
X    time_t  tetime, diff;
X    time_t  u_time, s_time;
X
X#  else	/* POSIX */
X    static clock_t ztime = 0;
X    static clock_t zu_time = 0;
X    static clock_t zs_time = 0;
X    clock_t tetime, diff;
X    clock_t u_time, s_time;
X
X#  endif /* POSIX */
X    struct tms zts, rts;
X    register struct process *pp = tp;
X
X    u_time = zu_time;
X    s_time = zs_time;
X    tetime = ztime;
X    do {
X	u_time += pp->p_utime;
X	s_time += pp->p_stime;
X	diff = pp->p_etime - pp->p_btime;
X	if (diff > tetime)
X	    tetime = diff;
X    } while ((pp = pp->p_friends) != tp);
X    zts.tms_utime = zu_time;
X    zts.tms_stime = zs_time;
X    zts.tms_cutime = 0;
X    zts.tms_cstime = 0;
X    rts.tms_utime = u_time;
X    rts.tms_stime = s_time;
X    rts.tms_cutime = 0;
X    rts.tms_cstime = 0;
X    prusage(&zts, &rts, tetime, ztime);
X# endif /* !_SEQUENT_ */
X#endif	/* !BSDTIMES */
X}
X
X/*
X * dojobs - print all jobs
X */
X/*ARGSUSED*/
void
dojobs(v, c)
X    Char  **v;
X    struct command *c;
X{
X    register struct process *pp;
X    register int flag = NUMBER | NAME | REASON;
X    int     i;
X
X    if (chkstop)
X	chkstop = 2;
X    if (*++v) {
X	if (v[1] || !eq(*v, STRml))
X	    stderror(ERR_JOBS);
X	flag |= FANCY | JOBDIR;
X    }
X    for (i = 1; i <= pmaxindex; i++)
X	for (pp = proclist.p_next; pp; pp = pp->p_next)
X	    if (pp->p_index == i && pp->p_procid == pp->p_jobid) {
X		pp->p_flags &= ~PNEEDNOTE;
X		if (!(pprint(pp, flag) & (PRUNNING | PSTOPPED)))
X		    pflush(pp);
X		break;
X	    }
X}
X
X/*
X * dofg - builtin - put the job into the foreground
X */
X/*ARGSUSED*/
void
dofg(v, c)
X    Char  **v;
X    struct command *c;
X{
X    register struct process *pp;
X
X    okpcntl();
X    ++v;
X    do {
X	pp = pfind(*v);
X	pstart(pp, 1);
X#ifndef BSDSIGS
X# ifdef notdef
X	if (setintr)
X	    sigignore(SIGINT);
X# endif
X#endif /* !BSDSIGS */
X	pjwait(pp);
X    } while (*v && *++v);
X}
X
X/*
X * %... - builtin - put the job into the foreground
X */
X/*ARGSUSED*/
void
dofg1(v, c)
X    Char  **v;
X    struct command *c;
X{
X    register struct process *pp;
X
X    okpcntl();
X    pp = pfind(v[0]);
X    pstart(pp, 1);
X#ifndef BSDSIGS
X# ifdef notdef
X    if (setintr)
X	sigignore(SIGINT);
X# endif
X#endif /* !BSDSIGS */
X    pjwait(pp);
X}
X
X/*
X * dobg - builtin - put the job into the background
X */
X/*ARGSUSED*/
void
dobg(v, c)
X    Char  **v;
X    struct command *c;
X{
X    register struct process *pp;
X
X    okpcntl();
X    ++v;
X    do {
X	pp = pfind(*v);
X	pstart(pp, 0);
X    } while (*v && *++v);
X}
X
X/*
X * %... & - builtin - put the job into the background
X */
X/*ARGSUSED*/
void
dobg1(v, c)
X    Char  **v;
X    struct command *c;
X{
X    register struct process *pp;
X
X    pp = pfind(v[0]);
X    pstart(pp, 0);
X}
X
X/*
X * dostop - builtin - stop the job
X */
X/*ARGSUSED*/
void
dostop(v, c)
X    Char  **v;
X    struct command *c;
X{
X#ifdef BSDJOBS
X    pkill(++v, SIGSTOP);
X#endif /* BSDJOBS */
X}
X
X/*
X * dokill - builtin - superset of kill (1)
X */
X/*ARGSUSED*/
void
dokill(v, c)
X    Char  **v;
X    struct command *c;
X{
X    register int signum, len = 0;
X    register char *name;
X    extern int T_Cols;
X
X    v++;
X    if (v[0] && v[0][0] == '-') {
X	if (v[0][1] == 'l') {
X	    for (signum = 1; signum <= NSIG; signum++) {
X		if ((name = mesg[signum].iname) != NULL) {
X		    len += strlen(name) + 1;
X		    if (len >= T_Cols - 1) {
X			xprintf("\n");
X			len = strlen(name) + 1;
X		    }
X		    xprintf("%s ", name);
X		}
X	    }
X	    xprintf("\n");
X	    return;
X	}
X	if (Isdigit(v[0][1])) {
X	    signum = atoi(short2str(v[0] + 1));
X	    if (signum < 0 || signum > NSIG)
X		stderror(ERR_NAME | ERR_BADSIG);
X	}
X	else {
X	    for (signum = 1; signum <= NSIG; signum++)
X		if (mesg[signum].iname &&
X		    eq(&v[0][1], str2short(mesg[signum].iname)))
X		    goto gotsig;
X	    setname(short2str(&v[0][1]));
X	    stderror(ERR_NAME | ERR_UNKSIG);
X	}
gotsig:
X	v++;
X    }
X    else
X	signum = SIGTERM;
X    pkill(v, signum);
X}
X
static void
pkill(v, signum)
X    Char  **v;
X    int     signum;
X{
X    register struct process *pp, *np;
X    int jobflags = 0, err1 = 0;
X    pid_t     pid;
X#ifdef BSDSIGS
X    sigmask_t omask;
X#endif /* BSDSIGS */
X    Char   *cp;
X
X#ifdef BSDSIGS
X    omask = sigmask(SIGCHLD);
X    if (setintr)
X	omask |= sigmask(SIGINT);
X    omask = sigblock(omask) & ~omask;
X#else /* !BSDSIGS */
X    if (setintr)
X	(void) sighold(SIGINT);
X    (void) sighold(SIGCHLD);
X#endif /* !BSDSIGS */
X    gflag = 0, tglob(v);
X    if (gflag) {
X	v = globall(v);
X	if (v == 0)
X	    stderror(ERR_NAME | ERR_NOMATCH);
X    }
X    else {
X	v = gargv = saveblk(v);
X	trim(v);
X    }
X
X    while (v && (cp = *v)) {
X	if (*cp == '%') {
X	    np = pp = pfind(cp);
X	    do
X		jobflags |= np->p_flags;
X	    while ((np = np->p_friends) != pp);
X#ifdef BSDJOBS
X	    switch (signum) {
X
X	    case SIGSTOP:
X	    case SIGTSTP:
X	    case SIGTTIN:
X	    case SIGTTOU:
X		if ((jobflags & PRUNNING) == 0) {
X# ifdef SUSPENDED
X		    xprintf("%s: Already suspended\n",
X			    short2str(cp));
X# else /* !SUSPENDED */
X		    xprintf("%s: Already stopped\n",
X			    short2str(cp));
X# endif /* !SUSPENDED */
X		    err1++;
X		    goto cont;
X		}
X		break;
X		/*
X		 * suspend a process, kill -CONT %, then type jobs; the shell
X		 * says it is suspended, but it is running; thanks jaap..
X		 */
X	    case SIGCONT:
X		pstart(pp, 0);
X		goto cont;
X	    default:
X		break;
X	    }
X#endif /* BSDJOBS */
X	    if (killpg(pp->p_jobid, signum) < 0) {
X		xprintf("%s: %s\n", short2str(cp), strerror(errno));
X		err1++;
X	    }
X#ifdef BSDJOBS
X	    if (signum == SIGTERM || signum == SIGHUP)
X		(void) killpg(pp->p_jobid, SIGCONT);
X#endif /* BSDJOBS */
X	}
X	else if (!(Isdigit(*cp) || *cp == '-'))
X	    stderror(ERR_NAME | ERR_JOBARGS);
X	else {
X	    pid = atoi(short2str(cp));
X	    if (kill(pid, signum) < 0) {
X		xprintf("%d: %s\n", pid, strerror(errno));
X		err1++;
X		goto cont;
X	    }
X#ifdef BSDJOBS
X	    if (signum == SIGTERM || signum == SIGHUP)
X		(void) kill(pid, SIGCONT);
X#endif /* BSDJOBS */
X	}
cont:
X	v++;
X    }
X    if (gargv)
X	blkfree(gargv), gargv = 0;
X#ifdef BSDSIGS
X    (void) sigsetmask(omask);
X#else /* !BSDSIGS */
X    (void) sigrelse(SIGCHLD);
X    if (setintr)
X	(void) sigrelse(SIGINT);
X#endif /* !BSDSIGS */
X    if (err1)
X	stderror(ERR_SILENT);
X}
X
X/*
X * pstart - start the job in foreground/background
X */
void
pstart(pp, foregnd)
X    register struct process *pp;
X    int     foregnd;
X{
X    register struct process *np;
X#ifdef BSDSIGS
X    sigmask_t omask;
X#endif /* BSDSIGS */
X    long    jobflags = 0;
X
X#ifdef BSDSIGS
X    omask = sigblock(sigmask(SIGCHLD));
X#else /* !BSDSIGS */
X    (void) sighold(SIGCHLD);
X#endif
X    np = pp;
X    do {
X	jobflags |= np->p_flags;
X	if (np->p_flags & (PRUNNING | PSTOPPED)) {
X	    np->p_flags |= PRUNNING;
X	    np->p_flags &= ~PSTOPPED;
X	    if (foregnd)
X		np->p_flags |= PFOREGND;
X	    else
X		np->p_flags &= ~PFOREGND;
X	}
X    } while ((np = np->p_friends) != pp);
X    if (!foregnd)
X	pclrcurr(pp);
X    (void) pprint(pp, foregnd ? NAME | JOBDIR : NUMBER | NAME | AMPERSAND);
X#ifdef BSDJOBS
X    if (foregnd)
X	(void) tcsetpgrp(FSHTTY, pp->p_jobid);
X    if (jobflags & PSTOPPED)
X	(void) killpg(pp->p_jobid, SIGCONT);
X#endif /* BSDJOBS */
X#ifdef BSDSIGS
X    (void) sigsetmask(omask);
X#else /* !BSDSIGS */
X    (void) sigrelse(SIGCHLD);
X#endif /* !BSDSIGS */
X}
X
void
panystop(neednl)
X    bool    neednl;
X{
X    register struct process *pp;
X
X    chkstop = 2;
X    for (pp = proclist.p_next; pp; pp = pp->p_next)
X	if (pp->p_flags & PSTOPPED)
X	    stderror(ERR_STOPPED, neednl ? "\n" : "");
X}
X
struct process *
pfind(cp)
X    Char   *cp;
X{
X    register struct process *pp, *np;
X
X    if (cp == 0 || cp[1] == 0 || eq(cp, STRcent2) || eq(cp, STRcentplus)) {
X	if (pcurrent == NULL)
X	    stderror(ERR_NAME | ERR_JOBCUR);
X	return (pcurrent);
X    }
X    if (eq(cp, STRcentminus) || eq(cp, STRcenthash)) {
X	if (pprevious == NULL)
X	    stderror(ERR_NAME | ERR_JOBPREV);
X	return (pprevious);
X    }
X    if (Isdigit(cp[1])) {
X	int     idx = atoi(short2str(cp + 1));
X
X	for (pp = proclist.p_next; pp; pp = pp->p_next)
X	    if (pp->p_index == idx && pp->p_procid == pp->p_jobid)
X		return (pp);
X	stderror(ERR_NAME | ERR_NOSUCHJOB);
X    }
X    np = NULL;
X    for (pp = proclist.p_next; pp; pp = pp->p_next)
X	if (pp->p_procid == pp->p_jobid) {
X	    if (cp[1] == '?') {
X		register Char *dp;
X
X		for (dp = pp->p_command; *dp; dp++) {
X		    if (*dp != cp[2])
X			continue;
X		    if (prefix(cp + 2, dp))
X			goto match;
X		}
X	    }
X	    else if (prefix(cp + 1, pp->p_command)) {
X	match:
X		if (np)
X		    stderror(ERR_NAME | ERR_AMBIG);
X		np = pp;
X	    }
X	}
X    if (np)
X	return (np);
X    stderror(ERR_NAME | cp[1] == '?' ? ERR_JOBPAT : ERR_NOSUCHJOB);
X    /* NOTREACHED */
X    return (0);
X}
X
X
X/*
X * pgetcurr - find most recent job that is not pp, preferably stopped
X */
static struct process *
pgetcurr(pp)
X    register struct process *pp;
X{
X    register struct process *np;
X    register struct process *xp = NULL;
X
X    for (np = proclist.p_next; np; np = np->p_next)
X	if (np != pcurrent && np != pp && np->p_procid &&
X	    np->p_procid == np->p_jobid) {
X	    if (np->p_flags & PSTOPPED)
X		return (np);
X	    if (xp == NULL)
X		xp = np;
X	}
X    return (xp);
X}
X
X/*
X * donotify - flag the job so as to report termination asynchronously
X */
X/*ARGSUSED*/
void
donotify(v, c)
X    Char  **v;
X    struct command *c;
X{
X    register struct process *pp;
X
X    pp = pfind(*++v);
X    pp->p_flags |= PNOTIFY;
X}
X
X/*
X * Do the fork and whatever should be done in the child side that
X * should not be done if we are not forking at all (like for simple builtin's)
X * Also do everything that needs any signals fiddled with in the parent side
X *
X * Wanttty tells whether process and/or tty pgrps are to be manipulated:
X *	-1:	leave tty alone; inherit pgrp from parent
X *	 0:	already have tty; manipulate process pgrps only
X *	 1:	want to claim tty; manipulate process and tty pgrps
X * It is usually just the value of tpgrp.
X */
X
int
pfork(t, wanttty)
X    struct command *t;		/* command we are forking for */
X    int     wanttty;
X{
X    register int pid;
X    bool    ignint = 0;
X    int     pgrp;
X#ifdef BSDSIGS
X    sigmask_t omask;
X#endif /* BSDSIGS */
X#ifdef SIGSYNCH
X    sigvec_t osv;
X    static sigvec_t nsv = {synch_handler, ~0, 0};
X#endif /* SIGSYNCH */
X
X    /*
X     * A child will be uninterruptible only under very special conditions.
X     * Remember that the semantics of '&' is implemented by disconnecting the
X     * process from the tty so signals do not need to ignored just for '&'.
X     * Thus signals are set to default action for children unless: we have had
X     * an "onintr -" (then specifically ignored) we are not playing with
X     * signals (inherit action)
X     */
X    if (setintr)
X	ignint = (tpgrp == -1 && (t->t_dflg & F_NOINTERRUPT))
X	    || (gointr && eq(gointr, STRminus));
X    /*
X     * Check for maximum nesting of 16 processes to avoid Forking loops
X     */
X    if (child == 16)
X	stderror(ERR_NESTING, 16);
X    /*
X     * Hold SIGCHLD until we have the process installed in our table.
X     */
X#ifdef SIGSYNCH
X    if (mysigvec(SIGSYNCH, &nsv, &osv))
X	stderror(ERR_SYSTEM, "pfork: sigvec set", strerror(errno));
X#endif /* SIGSYNCH */
X#ifdef BSDSIGS
X    omask = sigblock(sigmask(SIGCHLD));
X#else /* !BSDSIGS */
X    (void) sighold(SIGCHLD);
X#endif /* !BSDSIGS */
X    while ((pid = fork()) < 0)
X	if (setintr == 0)
X	    (void) sleep(FORKSLEEP);
X	else {
X#ifdef BSDSIGS
X	    (void) sigsetmask(omask);
X#else /* !BSDSIGS */
X	    (void) sigrelse(SIGINT);
X	    (void) sigrelse(SIGCHLD);
X#endif /* !BSDSIGS */
X	    stderror(ERR_NOPROC);
X	}
X    if (pid == 0) {
X	settimes();
X	pgrp = pcurrjob ? pcurrjob->p_jobid : getpid();
X	pflushall();
X	pcurrjob = NULL;
X#if !defined(BSDTIMES) && !defined(_SEQUENT_) 
X	timesdone = 0;
X#endif /* !defined(BSDTIMES) && !defined(_SEQUENT_) */
X	child++;
X	if (setintr) {
X	    setintr = 0;	/* until I think otherwise */
X#ifndef BSDSIGS
X	    (void) sigrelse(SIGCHLD);
X#endif /* !BSDSIGS */
X	    /*
X	     * Children just get blown away on SIGINT, SIGQUIT unless "onintr
X	     * -" seen.
X	     */
X	    (void) signal(SIGINT, ignint ? SIG_IGN : SIG_DFL);
X	    (void) signal(SIGQUIT, ignint ? SIG_IGN : SIG_DFL);
X#ifdef BSDJOBS
X	    if (wanttty >= 0) {
X		/* make stoppable */
X		(void) signal(SIGTSTP, SIG_DFL);
X		(void) signal(SIGTTIN, SIG_DFL);
X		(void) signal(SIGTTOU, SIG_DFL);
X	    }
X#endif /* BSDJOBS */
X	    (void) signal(SIGTERM, parterm);
X	}
X	else if (tpgrp == -1 && (t->t_dflg & F_NOINTERRUPT)) {
X	    (void) signal(SIGINT, SIG_IGN);
X	    (void) signal(SIGQUIT, SIG_IGN);
X	}
X#ifdef OREO
X	sigignore(SIGIO);	/* ignore SIGIO in child too */
X#endif /* OREO */
X
X	pgetty(wanttty, pgrp);
X	/*
X	 * Nohup and nice apply only to NODE_COMMAND's but it would be nice
X	 * (?!?) if you could say "nohup (foo;bar)" Then the parser would have
X	 * to know about nice/nohup/time
X	 */
X	if (t->t_dflg & F_NOHUP)
X	    (void) signal(SIGHUP, SIG_IGN);
X	if (t->t_dflg & F_NICE)
X#ifdef BSDNICE
X	    (void) setpriority(PRIO_PROCESS, 0, t->t_nice);
X#else /* !BSDNICE */
X	    (void) nice(t->t_nice);
X#endif /* !BSDNICE */
X#ifdef F_VER
X        if (t->t_dflg & F_VER) {
X	    Setenv(STRSYSTYPE, t->t_systype ? STRbsd43 : STRsys53);
X	    dohash(NULL, NULL);
X	}
X#endif /* F_VER */
X#ifdef SIGSYNCH
X	/* rfw 8/89 now parent can continue */
X	if (kill(getppid(), SIGSYNCH))
X	    stderror(ERR_SYSTEM, "pfork child: kill", strerror(errno));
X#endif /* SIGSYNCH */
X
X    }
X    else {
X#ifdef POSIXJOBS
X	if (wanttty >= 0)
X	    (void) setpgid(pid, pcurrjob ? pcurrjob->p_jobid : pid);
X#endif /* POSIXJOBS */
X	palloc(pid, t);
X#ifdef SIGSYNCH
X	/*
X	 * rfw 8/89 Wait for child to own terminal.  Solves half of ugly
X	 * synchronization problem.  With this change, we know that the only
X	 * reason setpgrp to a previous process in a pipeline can fail is that
X	 * the previous process has already exited. Without this hack, he may
X	 * either have exited or not yet started to run.  Two uglies become
X	 * one.
X	 */
X	sigpause(omask & ~SYNCHMASK);
X	if (mysigvec(SIGSYNCH, &osv, NULL))
X	    stderror(ERR_SYSTEM, "pfork parent: sigvec restore",
X		     strerror(errno));
X#endif /* SIGSYNCH */
X
X#ifdef BSDSIGS
X	(void) sigsetmask(omask);
X#else /* !BSDSIGS */
X	(void) sigrelse(SIGCHLD);
X#endif /* !BSDSIGS */
X    }
X    return (pid);
X}
X
static void
okpcntl()
X{
X    if (tpgrp == -1)
X	stderror(ERR_JOBCONTROL);
X    if (tpgrp == 0)
X	stderror(ERR_JOBCTRLSUB);
X}
X
X/*
X * if we don't have vfork(), things can still go in the wrong order
X * resulting in the famous 'Stopped (tty output)'. But some systems
X * don't permit the setpgid() call, (these are more recent secure
X * systems such as ibm's aix), when they do. Then we'd rather print 
X * an error message than hang the shell!
X * I am open to suggestions how to fix that.
X */
void
pgetty(wanttty, pgrp)
X    int     wanttty, pgrp;
X{
X#ifdef BSDJOBS
X# if defined(BSDSIGS) && defined(POSIXJOBS)
X    sigmask_t omask = 0;
X# endif /* BSDSIGS && POSIXJOBS */
X
X# ifdef JOBDEBUG
X    xprintf("wanttty %d\n", wanttty);
X# endif
X
X# ifdef POSIXJOBS
X    /*
X     * christos: I am blocking the tty signals till I've set things
X     * correctly....
X     */
X    if (wanttty > 0)
X#  ifdef BSDSIGS
X	omask = sigblock(sigmask(SIGTSTP)|sigmask(SIGTTIN)|sigmask(SIGTTOU));
X#  else /* !BSDSIGS */
X    {
X	(void) sighold(SIGTSTP);
X	(void) sighold(SIGTTIN);
X	(void) sighold(SIGTTOU);
X    }
X#  endif /* !BSDSIGS */
X# endif /* POSIXJOBS */
X
X# ifndef POSIXJOBS
X    if (wanttty > 0)
X	(void) tcsetpgrp(FSHTTY, pgrp);
X# endif /* !POSIXJOBS */
X
X    /*
X     * From: Michael Schroeder <mlschroe@immd4.informatik.uni-erlangen.de>
X     * Don't check for tpgrp >= 0 so even non-interactive shells give
X     * background jobs process groups Same for the comparison in the other part
X     * of the #ifdef
X     */
X    if (wanttty >= 0)
X	if (setpgid(0, pgrp) == -1) {
X# ifdef BACKPIPE
X	    /*
X     	     * This usually happens in svr4 when the last command in a pipe
X	     * either couldn't be started, or exits without waiting for input.
X	     * Putting in the xexit() hangs the shell, so leave it out.
X	     * (DHD)
X     	     */
X#  ifdef JOBDEBUG
X	    xprintf("tcsh: setpgid error (%s).\n", strerror(errno));
X	    xprintf("pgrp = %d, shell pid = %d\n",pgrp,getpid());
X#  endif /* JOBDEBUG */
X# else /* !BACKPIPE */
X#  if !defined(ISC) && !defined(SCO) && !defined(cray)
X	    /* XXX: Wrong but why? */
X	    xprintf("tcsh: setpgid error (%s).\n", strerror(errno));
X#  endif /* !ISC && !SCO && !cray */
X	    xexit(0);
X# endif /* BACKPIPE */
X	}
X
X# ifdef POSIXJOBS
X    if (wanttty > 0) {
X	(void) tcsetpgrp(FSHTTY, pgrp);
X#  ifdef BSDSIGS
X	(void) sigsetmask(omask);
X#  else /* BSDSIGS */
X	(void) sigrelse(SIGTSTP);
X	(void) sigrelse(SIGTTIN);
X	(void) sigrelse(SIGTTOU);
X#  endif /* !BSDSIGS */
X    }
X# endif /* POSIXJOBS */
X
X    if (tpgrp > 0)
X	tpgrp = 0;		/* gave tty away */
X#endif /* BSDJOBS */
X}
END_OF_FILE
if test 47893 -ne `wc -c <'sh.proc.c'`; then
    echo shar: \"'sh.proc.c'\" unpacked with wrong size!
fi
# end of 'sh.proc.c'
fi
echo shar: End of archive 16 \(of 18\).
cp /dev/null ark16isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
